(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            currentQueue[queueIndex].run();
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],2:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcCoreFamousEngine = require('famous/src/core/FamousEngine');

var _famousSrcCoreFamousEngine2 = _interopRequireDefault(_famousSrcCoreFamousEngine);

var _logo = require('../logo/');

var _sidebar = require('../sidebar/');

var _main = require('../main/');

var _modal = require('../modal/');

var _layers = require('../layers/');

var App = (function (_Node) {
    _inherits(App, _Node);

    function App(options) {
        _classCallCheck(this, App);

        _get(Object.getPrototypeOf(App.prototype), 'constructor', this).call(this, options);

        this.modal = this.addChild(new _layers.Layer({
            id: 'modal',
            zIndex: 5
        })).addChild(new _modal.Modal());

        this.logo = this.addChild(new _layers.Layer({
            id: 'logo',
            zIndex: 4
        })).addChild(new _logo.Logo());

        this.sidebar = this.addChild(new _layers.Layer({
            id: 'sidebar',
            zIndex: 3
        })).addChild(new _sidebar.Sidebar());

        this.main = this.addChild(new _layers.Layer({
            id: 'main',
            zIndex: 2,
            backgroundColor: '#212121'
        })). // perspective: '2000px'
        addChild(new _main.MainController());

        this.backgroundLayer = this.addChild(new _layers.Layer({
            id: 'background',
            zIndex: 1
        }));
    }

    return App;
})(_famousSrcCoreNode2['default']);

exports.App = App;

},{"../layers/":14,"../logo/":16,"../main/":17,"../modal/":18,"../sidebar/":23,"famous/src/core/FamousEngine":35,"famous/src/core/Node":36}],3:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _helpersColors = require('../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var Blurb = (function (_Node) {
    _inherits(Blurb, _Node);

    function Blurb(options) {
        _classCallCheck(this, Blurb);

        _get(Object.getPrototypeOf(Blurb.prototype), 'constructor', this).call(this, options);

        this.setSizeMode(2, 2, 2);
        this.el = new _famousSrcDomRenderablesDOMElement2['default']({
            content: options.content,
            styles: options.properties
        });
    }

    return Blurb;
})(_famousSrcCoreNode2['default']);

exports.Blurb = Blurb;

},{"../helpers/colors":12,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46}],4:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _helpersColors = require('../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var _layoutsGrid = require('../layouts/Grid');

var _layoutsGrid2 = _interopRequireDefault(_layoutsGrid);

var ListeningTo = (function (_Node) {
    _inherits(ListeningTo, _Node);

    function ListeningTo(options) {
        _classCallCheck(this, ListeningTo);

        _get(Object.getPrototypeOf(ListeningTo.prototype), 'constructor', this).call(this, options);

        var test = [[0, 0], [1, 0], [0, 1], [1, 1]];
        var youtubeUrls = ['<iframe style="width: 100%; height: 100%" src="https://www.youtube.com/embed/r4G0nbpLySI" frameborder="0" allowfullscreen></iframe>', '<iframe style="width: 100%; height: 100%" src="https://www.youtube.com/embed/x2AOjb9HW2E" frameborder="0" allowfullscreen></iframe>', '<iframe style="width: 100%; height: 100%" src="https://www.youtube.com/embed/H7bqZIpC3Pg" frameborder="0" allowfullscreen></iframe>', '<iframe style="width: 100%; height: 100%" src="https://www.youtube.com/embed/spUcxBFEpBM" frameborder="0" allowfullscreen></iframe>'];

        for (var i = 0; i < 4; i++) {
            var node = this.addChild();
            node.setDifferentialSize(-20, -20, 0);
            node.setProportionalSize(.5, .5, 0);
            node.setMountPoint(test[i][0], test[i][1]);
            node.setAlign(test[i][0], test[i][1]);
            var el = new _famousSrcDomRenderablesDOMElement2['default'](node, {
                content: youtubeUrls[i]
            });
        }
    }

    return ListeningTo;
})(_famousSrcCoreNode2['default']);

exports.ListeningTo = ListeningTo;

},{"../helpers/colors":12,"../layouts/Grid":15,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46}],5:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _helpersColors = require('../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var Playing = (function (_Node) {
    _inherits(Playing, _Node);

    function Playing(options) {
        _classCallCheck(this, Playing);

        _get(Object.getPrototypeOf(Playing.prototype), 'constructor', this).call(this, options);
    }

    return Playing;
})(_famousSrcCoreNode2['default']);

exports.Playing = Playing;

},{"../helpers/colors":12,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46}],6:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _helpersColors = require('../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var Reading = (function (_Node) {
    _inherits(Reading, _Node);

    function Reading(options) {
        _classCallCheck(this, Reading);

        _get(Object.getPrototypeOf(Reading.prototype), 'constructor', this).call(this, options);
    }

    return Reading;
})(_famousSrcCoreNode2['default']);

exports.Reading = Reading;

},{"../helpers/colors":12,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46}],7:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _helpersColors = require('../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var _Blurb = require('./Blurb');

var _Blurb2 = _interopRequireDefault(_Blurb);

var _Reading = require('./Reading');

var _Reading2 = _interopRequireDefault(_Reading);

var _Playing = require('./Playing');

var _Playing2 = _interopRequireDefault(_Playing);

var _ListeningTo = require('./ListeningTo');

var About = (function (_Node) {
    _inherits(About, _Node);

    function About(options) {
        _classCallCheck(this, About);

        _get(Object.getPrototypeOf(About.prototype), 'constructor', this).call(this, options);

        this.root = this.addChild();
        this.rootEl = new _famousSrcDomRenderablesDOMElement2['default'](this.root, {
            properties: {
                overflow: 'scroll'
            }
        });

        this.root = this.root.addChild();
        this.root.setAbsoluteSize(600, null, null);
        this.root.setSizeMode(1, 0, 0);
        this.root.setAlign(.5, 0, 0);
        this.root.setMountPoint(.5, 0, 0);

        this.titleNode = this.root.addChild();
        this.titleNode.setPosition(0, 100, 0);
        this.titleNode.setAbsoluteSize(null, 100, null);
        this.titleNode.setSizeMode(0, 1, 0);
        this.titleEl = new _famousSrcDomRenderablesDOMElement2['default'](this.titleNode, {
            content: 'ABOUT',
            properties: {
                color: 'white',
                fontFamily: 'futura',
                fontSize: '48px',
                lineHeight: '100px',
                textAlign: 'right'
            }
        });

        this.blurbNode = this.titleNode.addChild();
        this.blurbNode.setPosition(0, 100, 0);
        this.blurbEl = new _famousSrcDomRenderablesDOMElement2['default'](this.blurbNode, {
            content: 'Hi, I\'m Mike O\'Brien, and I love to find patterns in everything.  I am currently a Software Engineer at Famous where I work on the rendering engine and using it to build great experiences.<br><br>Hope you enjoy my site and see the progress that gets made here as I continue my efforts to learn all I can.  Live your life unapologetically.',
            properties: {
                color: 'white',
                fontFamily: 'futura',
                fontSize: '18px',
                fontSpacing: '2px',
                lineHeight: '22px',
                textAlign: 'left'
            }
        });

        this.listeningToTitle = this.blurbNode.addChild();
        this.listeningToTitle.setPosition(0, 200, 0);
        this.listeningToTitleEl = new _famousSrcDomRenderablesDOMElement2['default'](this.listeningToTitle, {
            content: 'What I am listening to',
            properties: {
                color: 'white',
                fontFamily: 'futura',
                fontSize: '32px',
                fontSpacing: '2px',
                lineHeight: '22px',
                textAlign: 'right'
            }
        });

        this.listeningTo = this.listeningToTitle.addChild(new _ListeningTo.ListeningTo());
        this.listeningTo.setPosition(0, 100, 0);
        this.listeningTo.setSizeMode(0, 1, 0);
        this.listeningTo.setAbsoluteSize(null, 400, null);
    }

    return About;
})(_famousSrcCoreNode2['default']);

exports.About = About;

},{"../helpers/colors":12,"./Blurb":3,"./ListeningTo":4,"./Playing":5,"./Reading":6,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46}],8:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _helpersColors = require('../../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var Box = (function (_Node) {
    _inherits(Box, _Node);

    function Box(options) {
        _classCallCheck(this, Box);

        _get(Object.getPrototypeOf(Box.prototype), 'constructor', this).call(this, options);
        this.faces = [];
        this.opacity = options.opacity || 1;
        this._width = options.width || 0;
        this._height = options.height || 0;
        this._depth = options.depth || 0;

        this.setOrigin(.5, .5, .5);
        this.setMountPoint(.5, .5, .5);
        this.setAlign(.5, .5, .5);

        var self = this;
        this.addComponent({
            onSizeChange: function onSizeChange(width, height, depth) {
                self._width = width;
                self._height = height;
                self._depth = depth;

                self.resize();
            }
        });

        this._constructFaces();
    }

    _createClass(Box, [{
        key: '_constructFaces',
        value: function _constructFaces() {
            this.faces.push(this.addChild());
            new _famousSrcDomRenderablesDOMElement2['default'](this.faces[0], {
                properties: {
                    opacity: this.opacity,
                    backgroundColor: _helpersColors2['default'].pink[500],
                    border: '2px solid black'
                }
            });

            this.faces.push(this.addChild());
            this.faces[1].setRotation(0, Math.PI, 0);
            this.faces[1].setOrigin(.5, .5, .5);
            new _famousSrcDomRenderablesDOMElement2['default'](this.faces[1], {
                properties: {
                    opacity: this.opacity,
                    backgroundColor: _helpersColors2['default'].pink[500],
                    border: '2px solid black',
                    backfaceVisibility: 'visible'
                }
            });

            this.faces.push(this.addChild());
            this.faces[2].setRotation(0, Math.PI / 2, 0);
            this.faces[2].setOrigin(.5, .5, .5);
            new _famousSrcDomRenderablesDOMElement2['default'](this.faces[2], {
                properties: {
                    opacity: this.opacity,
                    backgroundColor: _helpersColors2['default'].yellow[500],
                    border: '2px solid black',
                    backfaceVisibility: 'visible'
                }
            });

            this.faces.push(this.addChild());
            this.faces[3].setRotation(0, -Math.PI / 2, 0);
            this.faces[3].setOrigin(.5, .5, .5);
            new _famousSrcDomRenderablesDOMElement2['default'](this.faces[3], {
                properties: {
                    opacity: this.opacity,
                    backgroundColor: _helpersColors2['default'].yellow[500],
                    border: '2px solid black',
                    backfaceVisibility: 'visible'
                }
            });

            this.faces.push(this.addChild());
            this.faces[4].setRotation(Math.PI / 2, 0, 0);
            this.faces[4].setOrigin(.5, .5, .5);
            new _famousSrcDomRenderablesDOMElement2['default'](this.faces[4], {
                properties: {
                    opacity: this.opacity,
                    backgroundColor: _helpersColors2['default'].deepOrange[500],
                    border: '2px solid black',
                    backfaceVisibility: 'visible'
                }
            });

            this.faces.push(this.addChild());
            this.faces[5].setRotation(-Math.PI / 2, 0, 0);
            this.faces[5].setOrigin(.5, .5, .5);
            new _famousSrcDomRenderablesDOMElement2['default'](this.faces[5], {
                properties: {
                    opacity: this.opacity,
                    backgroundColor: _helpersColors2['default'].deepOrange[500],
                    border: '2px solid black',
                    backfaceVisibility: 'visible'
                }
            });

            this.resize();
        }
    }, {
        key: 'resize',
        value: function resize() {
            this.faces[0].setPosition(0, 0, this._depth / 2);
            this.faces[1].setPosition(0, 0, -this._depth / 2);
            this.faces[2].setPosition(-this._width / 2, 0, 0);
            this.faces[3].setPosition(this._width / 2, 0, 0);
            this.faces[4].setPosition(0, this._height / 2, 0);
            this.faces[5].setPosition(0, -this._height / 2, 0);
        }
    }]);

    return Box;
})(_famousSrcCoreNode2['default']);

exports.Box = Box;

},{"../../helpers/colors":12,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46}],9:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

var _famousSrcTransitionsTransitionable = require('famous/src/transitions/Transitionable');

var _famousSrcTransitionsTransitionable2 = _interopRequireDefault(_famousSrcTransitionsTransitionable);

var mainTransitionable = new _famousSrcTransitionsTransitionable2['default'](0);

function breathe() {
    mainTransitionable.set(1, { duration: 2000, curve: 'easeInOut' }, function () {
        mainTransitionable.set(0, { duration: 2000, curve: 'easeInOut' }, breathe);
    });
}
breathe();

var Breather = (function () {
    function Breather(node, options) {
        _classCallCheck(this, Breather);

        options = options || {};
        this._node = node;
        this.direction = options.direction || '-x';
        this._id = node.addComponent(this);
        this._node.requestUpdate(this._id);
        this._width = 0;
        this._height = 0;
        this._depth = 0;
    }

    _createClass(Breather, [{
        key: 'onSizeChange',
        value: function onSizeChange(width, height, depth) {
            this._width = width;
            this._height = height;
            this._depth = depth;
        }
    }, {
        key: 'onUpdate',
        value: function onUpdate(time) {
            switch (this.direction) {
                case '-x':
                    this._node.setPosition(-this._width * 2 - this._width * mainTransitionable.get(), 0, 0);
                    break;
                case '+x':
                    this._node.setPosition(this._width * 2 + this._width * mainTransitionable.get(), 0, 0);
                    break;
                case '-y':
                    this._node.setPosition(0, -this._height * 2 - this._height * mainTransitionable.get(), 0);
                    break;
                case '+y':
                    this._node.setPosition(0, this._height * 2 + this._height * mainTransitionable.get(), 0);
                    break;
                case '-z':
                    this._node.setPosition(0, 0, -this._depth * 2 - this._depth * mainTransitionable.get());
                    break;
                case '+z':
                    this._node.setPosition(0, 0, this._depth * 2 + this._depth * mainTransitionable.get());
                    break;
            }

            this._node.requestUpdateOnNextTick(this._id);
        }
    }]);

    return Breather;
})();

exports.Breather = Breather;

},{"famous/src/transitions/Transitionable":68}],10:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _helpersColors = require('../../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var _helpersBoxBreather = require('../../helpers/box/Breather');

var _helpersBoxBox = require('../../helpers/box/Box');

var _helpersBoxOuterBox = require('../../helpers/box/OuterBox');

var MiddleBox = (function (_Node) {
    _inherits(MiddleBox, _Node);

    function MiddleBox(options) {
        _classCallCheck(this, MiddleBox);

        _get(Object.getPrototypeOf(MiddleBox.prototype), 'constructor', this).call(this, options);
        this.options = options || {};

        new _helpersBoxBreather.Breather(this, { direction: options.direction });
        this.addChild(new _helpersBoxBox.Box({
            colors: [],
            type: 'dom'
        }));

        this.outerRotationNode = this.addChild();
        this.outerRotationNode.setProportionalSize(.5, .5, .5);
        this.outerRotationNode.setAlign(.5, .5, .5);
        this.outerRotationNode.setOrigin(.5, .5, .5);
        this.outerRotationNode.setMountPoint(.5, .5, .5);
        this.outerRotationNode.addChild(new _helpersBoxBox.Box({ colors: [], type: 'dom' }));
    }

    _createClass(MiddleBox, [{
        key: 'onSizeChange',
        value: function onSizeChange(width, height, depth) {
            switch (this.options.direction) {
                case '+x':
                    this.outerRotationNode.setPosition();
            }
        }
    }]);

    return MiddleBox;
})(_famousSrcCoreNode2['default']);

exports.MiddleBox = MiddleBox;

},{"../../helpers/box/Box":8,"../../helpers/box/Breather":9,"../../helpers/box/OuterBox":11,"../../helpers/colors":12,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _helpersBoxBox = require('../../helpers/box/Box');

var OuterBox = (function (_Node) {
    _inherits(OuterBox, _Node);

    function OuterBox(options) {
        _classCallCheck(this, OuterBox);

        _get(Object.getPrototypeOf(OuterBox.prototype), 'constructor', this).call(this, options);
        this.options = options || {};

        this.rotationNode = this.addChild();
        this.rotationNode.setPosition();
        this.rotationNode.setProportionalSize(.5, .5, .5);

        this.rotationNode.addChild(new _helpersBoxBox.Box({
            colors: [],
            type: 'dom'
        }));
    }

    return OuterBox;
})(_famousSrcCoreNode2['default']);

exports.OuterBox = OuterBox;

},{"../../helpers/box/Box":8,"famous/src/core/Node":36}],12:[function(require,module,exports){
// Google style palette (http://www.google.com/design/spec/style/color.html)
'use strict';

module.exports = {
    'red': {
        '50': '#FFEBEE',
        '100': '#FFCDD2',
        '200': '#EF9A9A',
        '300': '#E57373',
        '400': '#EF5350',
        '500': '#F44336',
        '600': '#E53935',
        '700': '#D32F2F',
        '800': '#C62828',
        '900': '#B71C1C',
        'A100': '#FF8A80',
        'A200': '#FF5252',
        'A400': '#FF1744',
        'A700': '#D50000'
    },
    'pink': {
        '50': '#FCE4EC',
        '100': '#F8BBD0',
        '200': '#F48FB1',
        '300': '#F06292',
        '400': '#EC407A',
        '500': '#E91E63',
        '600': '#D81B60',
        '700': '#C2185B',
        '800': '#AD1457',
        '900': '#880E4F',
        'A100': '#FF80AB',
        'A200': '#FF4081',
        'A400': '#F50057',
        'A700': '#C51162'
    },
    'purple': {
        '50': '#F3E5F5',
        '100': '#E1BEE7',
        '200': '#CE93D8',
        '300': '#BA68C8',
        '400': '#AB47BC',
        '500': '#9C27B0',
        '600': '#8E24AA',
        '700': '#7B1FA2',
        '800': '#6A1B9A',
        '900': '#4A148C',
        'A100': '#EA80FC',
        'A200': '#E040FB',
        'A400': '#D500F9',
        'A700': '#AA00FF'
    },
    'deepPurple': {
        '50': '#EDE7F6',
        '100': '#D1C4E9',
        '200': '#B39DDB',
        '300': '#9575CD',
        '400': '#7E57C2',
        '500': '#673AB7',
        '600': '#5E35B1',
        '700': '#512DA8',
        '800': '#4527A0',
        '900': '#311B92',
        'A100': '#B388FF',
        'A200': '#7C4DFF',
        'A400': '#651FFF',
        'A700': '#6200EA'
    },
    'indigo': {
        '50': '#E8EAF6',
        '100': '#C5CAE9',
        '200': '#9FA8DA',
        '300': '#7986CB',
        '400': '#5C6BC0',
        '500': '#3F51B5',
        '600': '#3949AB',
        '700': '#303F9F',
        '800': '#283593',
        '900': '#1A237E',
        'A100': '#8C9EFF',
        'A200': '#536DFE',
        'A400': '#3D5AFE',
        'A700': '#304FFE'
    },
    'blue': {
        '50': '#E3F2FD',
        '100': '#BBDEFB',
        '200': '#90CAF9',
        '300': '#64B5F6',
        '400': '#42A5F5',
        '500': '#2196F3',
        '600': '#1E88E5',
        '700': '#1976D2',
        '800': '#1565C0',
        '900': '#0D47A1',
        'A100': '#82B1FF',
        'A200': '#448AFF',
        'A400': '#2979FF',
        'A700': '#2962FF'
    },
    'lightBlue': {
        '50': '#E1F5FE',
        '100': '#B3E5FC',
        '200': '#81D4FA',
        '300': '#4FC3F7',
        '400': '#29B6F6',
        '500': '#03A9F4',
        '600': '#039BE5',
        '700': '#0288D1',
        '800': '#0277BD',
        '900': '#01579B',
        'A100': '#80D8FF',
        'A200': '#40C4FF',
        'A400': '#00B0FF',
        'A700': '#0091EA'
    },
    'cyan': {
        '50': '#E0F7FA',
        '100': '#B2EBF2',
        '200': '#80DEEA',
        '300': '#4DD0E1',
        '400': '#26C6DA',
        '500': '#00BCD4',
        '600': '#00ACC1',
        '700': '#0097A7',
        '800': '#00838F',
        '900': '#006064',
        'A100': '#84FFFF',
        'A200': '#18FFFF',
        'A400': '#00E5FF',
        'A700': '#00B8D4'
    },
    'teal': {
        '50': '#E0F2F1',
        '100': '#B2DFDB',
        '200': '#80CBC4',
        '300': '#4DB6AC',
        '400': '#26A69A',
        '500': '#009688',
        '600': '#00897B',
        '700': '#00796B',
        '800': '#00695C',
        '900': '#004D40',
        'A100': '#A7FFEB',
        'A200': '#64FFDA',
        'A400': '#1DE9B6',
        'A700': '#00BFA5'
    },
    'green': {
        '50': '#E8F5E9',
        '100': '#C8E6C9',
        '200': '#A5D6A7',
        '300': '#81C784',
        '400': '#66BB6A',
        '500': '#4CAF50',
        '600': '#43A047',
        '700': '#388E3C',
        '800': '#2E7D32',
        '900': '#1B5E20',
        'A100': '#B9F6CA',
        'A200': '#69F0AE',
        'A400': '#00E676',
        'A700': '#00C853'
    },
    'lightGreen': {
        '50': '#F1F8E9',
        '100': '#DCEDC8',
        '200': '#C5E1A5',
        '300': '#AED581',
        '400': '#9CCC65',
        '500': '#8BC34A',
        '600': '#7CB342',
        '700': '#689F38',
        '800': '#558B2F',
        '900': '#33691E',
        'A100': '#CCFF90',
        'A200': '#B2FF59',
        'A400': '#76FF03',
        'A700': '#64DD17'
    },
    'lime': {
        '50': '#F9FBE7',
        '100': '#F0F4C3',
        '200': '#E6EE9C',
        '300': '#DCE775',
        '400': '#D4E157',
        '500': '#CDDC39',
        '600': '#C0CA33',
        '700': '#AFB42B',
        '800': '#9E9D24',
        '900': '#827717',
        'A100': '#F4FF81',
        'A200': '#EEFF41',
        'A400': '#C6FF00',
        'A700': '#AEEA00'
    },
    'yellow': {
        '50': '#FFFDE7',
        '100': '#FFF9C4',
        '200': '#FFF59D',
        '300': '#FFF176',
        '400': '#FFEE58',
        '500': '#FFEB3B',
        '600': '#FDD835',
        '700': '#FBC02D',
        '800': '#F9A825',
        '900': '#F57F17',
        'A100': '#FFFF8D',
        'A200': '#FFFF00',
        'A400': '#FFEA00',
        'A700': '#FFD600'
    },
    'amber': {
        '50': '#FFF8E1',
        '100': '#FFECB3',
        '200': '#FFE082',
        '300': '#FFD54F',
        '400': '#FFCA28',
        '500': '#FFC107',
        '600': '#FFB300',
        '700': '#FFA000',
        '800': '#FF8F00',
        '900': '#FF6F00',
        'A100': '#FFE57F',
        'A200': '#FFD740',
        'A400': '#FFC400',
        'A700': '#FFAB00'
    },
    'orange': {
        '50': '#FFF3E0',
        '100': '#FFE0B2',
        '200': '#FFCC80',
        '300': '#FFB74D',
        '400': '#FFA726',
        '500': '#FF9800',
        '600': '#FB8C00',
        '700': '#F57C00',
        '800': '#EF6C00',
        '900': '#E65100',
        'A100': '#FFD180',
        'A200': '#FFAB40',
        'A400': '#FF9100',
        'A700': '#FF6D00'
    },
    'deepOrange': {
        '50': '#FBE9E7',
        '100': '#FFCCBC',
        '200': '#FFAB91',
        '300': '#FF8A65',
        '400': '#FF7043',
        '500': '#FF5722',
        '600': '#F4511E',
        '700': '#E64A19',
        '800': '#D84315',
        '900': '#BF360C',
        'A100': '#FF9E80',
        'A200': '#FF6E40',
        'A400': '#FF3D00',
        'A700': '#DD2C00'
    },
    'brown': {
        '50': '#EFEBE9',
        '100': '#D7CCC8',
        '200': '#BCAAA4',
        '300': '#A1887F',
        '400': '#8D6E63',
        '500': '#795548',
        '600': '#6D4C41',
        '700': '#5D4037',
        '800': '#4E342E',
        '900': '#3E2723'
    },
    'grey': {
        '50': '#FAFAFA',
        '100': '#F5F5F5',
        '200': '#EEEEEE',
        '300': '#E0E0E0',
        '400': '#BDBDBD',
        '500': '#9E9E9E',
        '600': '#757575',
        '700': '#616161',
        '800': '#424242',
        '900': '#212121'
    },
    'blueGrey': {
        '50': '#ECEFF1',
        '100': '#CFD8DC',
        '200': '#B0BEC5',
        '300': '#90A4AE',
        '400': '#78909C',
        '500': '#607D8B',
        '600': '#546E7A',
        '700': '#455A64',
        '800': '#37474F',
        '900': '#263238'
    },
    'black': {
        '500': '#000000',
        'text': 'rgba(0,0,0,0.87)',
        'secondaryText': 'rgba(0,0,0,0.54)',
        'icons': 'rgba(0,0,0,0.54)',
        'disabled': 'rgba(0,0,0,0.26)',
        'hintText': 'rgba(0,0,0,0.26)',
        'dividers': 'rgba(0,0,0,0.12)'
    },
    'white': {
        '500': '#ffffff',
        'text': '#ffffff',
        'secondaryText': 'rgba(255,255,255,0.7)',
        'icons': '#ffffff',
        'disabled': 'rgba(255,255,255,0.3)',
        'hintText': 'rgba(255,255,255,0.3)',
        'dividers': 'rgba(255,255,255,0.12)'
    },
    getRandomColor: function getRandomColor() {
        var keys = Object.keys(this);
        var key;
        do {
            key = keys[Math.random() * keys.length << 0];
        } while (key !== 'getRandomColor');

        return this[key][500];
    }
};

},{}],13:[function(require,module,exports){
'use strict';

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

var _famousSrcCoreFamousEngine = require('famous/src/core/FamousEngine');

var _famousSrcCoreFamousEngine2 = _interopRequireDefault(_famousSrcCoreFamousEngine);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _App = require('./App/');

_famousSrcCoreFamousEngine2['default'].init();
var scene = _famousSrcCoreFamousEngine2['default'].createScene();
scene.addChild(new _App.App());

// var JITTER = scene.addChild();
// JITTER.setSizeMode(1, 1, 1);
// JITTER.setAbsoluteSize(1, 1, 1)
// var el = new DOMElement(JITTER, {content: ' '});
// var id = JITTER.addComponent({
//     onUpdate: function(time) {
//         JITTER.setPosition(3000 + time % 100, 0, -40000);
//         if (time < 2000) JITTER.requestUpdateOnNextTick(id);

//     }
// });

// JITTER.requestUpdate(id);

},{"./App/":2,"famous/src/core/FamousEngine":35,"famous/src/dom-renderables/DOMElement":46}],14:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var Layer = (function (_Node) {
    _inherits(Layer, _Node);

    function Layer(options) {
        _classCallCheck(this, Layer);

        _get(Object.getPrototypeOf(Layer.prototype), 'constructor', this).call(this, options);
        new _famousSrcDomRenderablesDOMElement2['default'](this, {
            id: options.id,
            properties: {
                backgroundColor: options.backgroundColor,
                transformStyle: 'flat',
                overflow: 'hidden',
                zIndex: options.zIndex,
                'pointer-events': 'none'
            }
        });

        this.exposedNode = _famousSrcCoreNode2['default'].prototype.addChild.call(this);
        new _famousSrcDomRenderablesDOMElement2['default'](this.exposedNode, {
            properties: {
                transformStyle: 'preserve-3d',
                perspective: options.perspective,
                'pointer-events': 'none'
            }
        });
    }

    _createClass(Layer, [{
        key: 'addChild',
        value: function addChild(node) {
            return this.exposedNode.addChild(node);
        }
    }]);

    return Layer;
})(_famousSrcCoreNode2['default']);

exports.Layer = Layer;

},{"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46}],15:[function(require,module,exports){
'use strict';

var Node = require('famous/src/core/Node');

function Grid(options) {
    this.options = Object.create(Grid.DEFAULT_PROPERTIES);
    Node.apply(this, options);

    this.setOptions(options);

    _layout(this);

    var _this = this;
    this.addComponent({
        onSizeChange: function onSizeChange(size) {
            _layout(_this);
        }
    });
}

Grid.prototype = Object.create(Node.prototype);
Grid.prototype.constructor = Grid;

Grid.DEFAULT_PROPERTIES = {
    dimensions: [0, 0],
    verticalSpacing: 0,
    horizontalSpacing: 0
};

function _layout(grid) {
    var size = grid.getSize();
    var usableSize = [size[0] - grid.options.verticalSpacing * (grid.options.dimensions[0] - 1), size[1] - grid.options.horizontalSpacing * (grid.options.dimensions[1] - 1)];
    var itemSize = [usableSize[0] / grid.options.dimensions[0], usableSize[1] / grid.options.dimensions[1]];
    var offsetX = 0;
    var offsetY = 0;
    var children = Node.prototype.getChildren.call(grid);
    var layoutNode;

    for (var i = 0; i < grid.options.dimensions[0]; i++) {
        for (var j = 0; j < grid.options.dimensions[1]; j++) {
            layoutNode = children[i * grid.options.dimensions[1] + j];

            if (!layoutNode) return;

            layoutNode.setAbsoluteSize(itemSize[0], itemSize[1]);
            layoutNode.setPosition(offsetX, offsetY);
            offsetX += grid.options.verticalSpacing + itemSize[0];
        }

        offsetX = 0;
        offsetY += grid.options.horizontalSpacing + itemSize[1];
    }
}

Grid.prototype.getChildren = function getChildren() {
    var children = Node.prototype.getChildren.call(this);
    var len = children.length;
    var result = [];

    for (var i = 0; i < len; i++) result.push(children[i].getChildren()[0]);

    return result;
};

Grid.prototype.addChild = function addChild() {
    var layoutNode = Node.prototype.addChild.call(this);
    layoutNode.setSizeMode(1, 1, 0);
    layoutNode.addChild();
    _layout(this);

    return layoutNode;
};

Grid.prototype.getChildAtIndex = function getChildAtIndex(index) {
    return Node.prototype.getChildren.call(this)[index].getChildren()[0];
};

Grid.prototype.getRow = function getRow(index) {
    var result = [];
    var children = Node.prototype.getChildren.call(this);

    for (var i = 0; i < this.options.dimensions[1]; i++) {
        result.push(children[row * this.options.dimensions[1] + i].getChildren()[0]);
    }

    return result;
};

Grid.prototype.getColumn = function getColumn(index) {
    var result = [];
    var children = Node.prototype.getChildren.call(this);

    for (var i = 0; i < this.options.dimensions[0]; i++) {
        result.push(children[i]);
    }

    return result;
};

Grid.prototype.getChildAtRowColumn = function getChildAtRowColumn(row, col) {
    return Node.prototype.getChildren.call(this)[row * this.options.dimensions[1] + col].getChildren()[0];
};

Grid.prototype.setOptions = function setOptions(options) {
    if (options.dimensions) this.setDimensions(options.dimensions[0], options.dimensions[1]);
    if (options.verticalSpacing) this.setVerticalSpacing(options.verticalSpacing);
    if (options.horizontalSpacing) this.setHorizontalSpacing(options.horizontalSpacing);
};

Grid.prototype.setVerticalSpacing = function setVerticalSpacing(verticalSpacing) {
    this.options.verticalSpacing = verticalSpacing;
    _layout(this);
};

Grid.prototype.getVerticalSpacing = function getVerticalSpacing() {
    return this.options.verticalSpacing;
};

Grid.prototype.setHorizontalSpacing = function setHorizontalSpacing(horizontalSpacing) {
    this.options.horizontalSpacing = horizontalSpacing;
    _layout(this);
};

Grid.prototype.getHorizontalSpacing = function getHorizontalSpacing() {
    return this.options.horizontalSpacing;
};

Grid.prototype.setDimensions = function setDimensions(x, y) {
    this.options.dimensions[0] = x;
    this.options.dimensions[1] = y;
};

Grid.prototype.getDimensions = function getDimensions() {
    return this.options.dimensions;
};

module.exports = Grid;

},{"famous/src/core/Node":36}],16:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcComponentsMountPoint = require('famous/src/components/MountPoint');

var _famousSrcComponentsMountPoint2 = _interopRequireDefault(_famousSrcComponentsMountPoint);

var _famousSrcComponentsAlign = require('famous/src/components/Align');

var _famousSrcComponentsAlign2 = _interopRequireDefault(_famousSrcComponentsAlign);

var _famousSrcComponentsSize = require('famous/src/components/Size');

var _famousSrcComponentsSize2 = _interopRequireDefault(_famousSrcComponentsSize);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _famousSrcTransitionsTransitionable = require('famous/src/transitions/Transitionable');

var _famousSrcTransitionsTransitionable2 = _interopRequireDefault(_famousSrcTransitionsTransitionable);

var _helpersColors = require('../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var Logo = (function (_Node) {
    _inherits(Logo, _Node);

    function Logo(options) {
        _classCallCheck(this, Logo);

        _get(Object.getPrototypeOf(Logo.prototype), 'constructor', this).call(this, options);

        this.root = this.addChild();
        this.root.setOrigin(.5, .5);
        var logoAlign = new _famousSrcComponentsAlign2['default'](this.root);
        logoAlign.set(.5, .5);
        var logoMountPoint = new _famousSrcComponentsMountPoint2['default'](this.root);
        logoMountPoint.set(.5, .5);
        var logoSize = new _famousSrcComponentsSize2['default'](this.root);
        logoSize.setAbsolute(300, 70, 0);
        this.root.setSizeMode(1, 1, 1);

        setTimeout(function () {
            logoAlign.set(.05, .05, 0, { curve: 'easeOut', duration: 0 });
            logoMountPoint.set(0, 0, 0, { curve: 'easeOut', duration: 0 });
            logoSize.setAbsolute(50, 70, 0, { curve: 'easeOut', duration: 0 });
        }, 1);

        this.el = new _famousSrcDomRenderablesDOMElement2['default'](this.root, {
            content: 'M',
            properties: {
                color: 'white',
                fontSize: '48px',
                fontFamily: 'futura',
                lineHeight: '60px',
                textAlign: 'center',
                cursor: 'pointer'
            }
        });

        this.bottom = this.root.addChild();
        this.bottom.setAbsoluteSize(null, 8, null);
        this.bottom.setSizeMode(0, 1, 0);
        this.bottom.setAlign(0, 1, 0);
        this.bottom.setMountPoint(0, 1, 0);
        this.createBar();

        this.animateOut();
    }

    _createClass(Logo, [{
        key: 'createBar',
        value: function createBar() {
            var node;
            var barColors = ['pink', 'orange', 'yellow', 'green', 'lightBlue', 'purple'];

            for (var i = 0; i < 6; i++) {
                node = this.bottom.addChild();
                node.setAlign(i / 6, 0, 0);
                node.setProportionalSize(1 / 6, 1, 1);
                new _famousSrcDomRenderablesDOMElement2['default'](node, {
                    properties: {
                        backgroundColor: _helpersColors2['default'][barColors[i]][500]
                    }
                });
            }
        }
    }, {
        key: 'animateOut',
        value: function animateOut() {}
    }]);

    return Logo;
})(_famousSrcCoreNode2['default']);

exports.Logo = Logo;

},{"../helpers/colors":12,"famous/src/components/Align":24,"famous/src/components/MountPoint":26,"famous/src/components/Size":29,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46,"famous/src/transitions/Transitionable":68}],17:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcComponentsOpacity = require('famous/src/components/Opacity');

var _famousSrcComponentsOpacity2 = _interopRequireDefault(_famousSrcComponentsOpacity);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _famousSrcTransitionsTransitionable = require('famous/src/transitions/Transitionable');

var _famousSrcTransitionsTransitionable2 = _interopRequireDefault(_famousSrcTransitionsTransitionable);

var _helpersColors = require('../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var _sandbox = require('../sandbox/');

var _about = require('../about/');

var MainController = (function (_Node) {
    _inherits(MainController, _Node);

    function MainController(options) {
        _classCallCheck(this, MainController);

        _get(Object.getPrototypeOf(MainController.prototype), 'constructor', this).call(this, options);

        var _this = this;
        var myUpdaterComponentID = this.addComponent({
            onUpdate: function onUpdate(time) {
                //Do logic

                // Repeat next frame
                _this.requestUpdateOnNextTick(myUpdaterComponentID);
            }
        });
        this.requestUpdate(myUpdaterComponentID);

        this.currentSection;
        this.currNode = this.addChild();
        this.nextNode = this.addChild();
        this.nextNodeOpacity = new _famousSrcComponentsOpacity2['default'](this.nextNode);
        this.nextNodeOpacity.set(0);
        this.currNodeOpacity = new _famousSrcComponentsOpacity2['default'](this.currNode);

        this.sections = {
            about: _about.About,
            sandbox: _sandbox.Sandbox
        };

        this.show('sandbox');
    }

    _createClass(MainController, [{
        key: 'show',
        value: function show(section, options) {
            var _this = this;

            if (section !== this.currentSection) {
                this.currentSection = section;

                this.nextNode.addChild(new this.sections[section]());

                this.nextNodeOpacity.set(1, { curve: 'easeInOut', duration: 1000 }, function () {
                    // var temp = _this.currNode;
                    // _this.currNode = _this.nextNode;
                    // _this.nextNode = temp;
                    // _this.nextNode.removeAllChildren();
                });

                this.currNodeOpacity.set(0, { curve: 'easeInOut', duration: 1000 });
            }
        }
    }]);

    return MainController;
})(_famousSrcCoreNode2['default']);

exports.MainController = MainController;

},{"../about/":7,"../helpers/colors":12,"../sandbox/":21,"famous/src/components/Opacity":27,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46,"famous/src/transitions/Transitionable":68}],18:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _famousSrcTransitionsTransitionable = require('famous/src/transitions/Transitionable');

var _famousSrcTransitionsTransitionable2 = _interopRequireDefault(_famousSrcTransitionsTransitionable);

var _helpersColors = require('../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var _layers = require('../layers/');

var Modal = (function (_Node) {
    _inherits(Modal, _Node);

    function Modal(options) {
        _classCallCheck(this, Modal);

        _get(Object.getPrototypeOf(Modal.prototype), 'constructor', this).call(this, options);

        this.root = this.addChild();
        this.root.setOpacity(0);

        this.background = this.root.addChild(new _layers.Layer({
            id: 'modalBackground',
            zIndex: 1
        }));

        this.background.setOpacity(.8);
        this.backgroundEl = new _famousSrcDomRenderablesDOMElement2['default'](this.background, {
            properties: {
                'pointer-events': 'none',
                backgroundColor: '#212121'
            }
        });

        this.foreground = this.root.addChild(new _layers.Layer({
            zIndex: 2,
            perspective: '2000px'
        }));

        this.square = this.foreground.addChild();
        this.square.setSizeMode(1, 1, 0);
        this.square.setAbsoluteSize(500, 500);
        this.square.setAlign(.5, .5);
        this.square.setMountPoint(.5, .5);
        new _famousSrcDomRenderablesDOMElement2['default'](this.square, {
            properties: {
                'pointer-events': 'none',
                backgroundColor: _helpersColors2['default'].lightBlue[500],
                borderRadius: '20px'
            }
        });

        this.exit = this.square.addChild();
        this.exit.setAlign(1, 0);
        this.exit.setMountPoint(.5, .5);
        this.exit.setSizeMode(1, 1, 0);
        this.exit.setAbsoluteSize(50, 50);
        new _famousSrcDomRenderablesDOMElement2['default'](this.exit, {
            content: 'X',
            properties: {
                'pointer-events': 'none',
                color: 'white',
                backgroundColor: _helpersColors2['default'].deepOrange[500],
                lineHeight: '50px',
                borderRadius: '25px',
                textAlign: 'center',
                fontFamily: 'futura',
                fontSize: '24px'
            }
        });
    }

    _createClass(Modal, [{
        key: 'show',
        value: function show() {
            this.root.setOpacity(1);
        }
    }, {
        key: 'hide',
        value: function hide() {
            this.root.setOpacity(0);
        }
    }]);

    return Modal;
})(_famousSrcCoreNode2['default']);

exports.Modal = Modal;

},{"../helpers/colors":12,"../layers/":14,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46,"famous/src/transitions/Transitionable":68}],19:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _helpersBoxBox = require('../../helpers/box/Box');

var _helpersBoxMiddleBox = require('../../helpers/box/MiddleBox');

var Tentacles = (function (_Node) {
    _inherits(Tentacles, _Node);

    function Tentacles() {
        _classCallCheck(this, Tentacles);

        _get(Object.getPrototypeOf(Tentacles.prototype), 'constructor', this).call(this);

        this.setAbsoluteSize(120, 120, 120);
        this.setOrigin(.5, .5, .5);
        this.setMountPoint(.5, .5, .5);
        this.setAlign(.5, .5, .5);
        this.setSizeMode(1, 1, 1);

        var self = this;
        var id = this.addComponent({
            onUpdate: function onUpdate(time) {
                self.setRotation(time / 1000, time / 600, 0);
                self.requestUpdateOnNextTick(id);
            }
        });
        self.requestUpdate(id);

        this.addChild(new _helpersBoxBox.Box({
            colors: [],
            type: 'dom'
        }));

        this._createMiddleBoxes();
    }

    _createClass(Tentacles, [{
        key: '_createMiddleBoxes',
        value: function _createMiddleBoxes() {
            var directions = ['+z', '-z', '-x', '+x', '-y', '+y'];
            var i = 0;
            var numDirections = directions.length;

            this.middleRotationNode = this.addChild();
            this.middleRotationNode.setAbsoluteSize(60, 60, 60);
            this.middleRotationNode.setOrigin(.5, .5, .5);
            this.middleRotationNode.setMountPoint(.5, .5, .5);
            this.middleRotationNode.setAlign(.5, .5, .5);
            this.middleRotationNode.setSizeMode(1, 1, 1);

            for (; i < numDirections; i++) {
                this.middleRotationNode.addChild(new _helpersBoxMiddleBox.MiddleBox({ direction: directions[i] }));
            }
        }
    }]);

    return Tentacles;
})(_famousSrcCoreNode2['default']);

exports.Tentacles = Tentacles;

},{"../../helpers/box/Box":8,"../../helpers/box/MiddleBox":10,"famous/src/core/Node":36}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _famousSrcTransitionsTransitionable = require('famous/src/transitions/Transitionable');

var _famousSrcTransitionsTransitionable2 = _interopRequireDefault(_famousSrcTransitionsTransitionable);

var _helpersColors = require('../../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var Tunnels = (function (_Node) {
    _inherits(Tunnels, _Node);

    function Tunnels(options) {
        _classCallCheck(this, Tunnels);

        _get(Object.getPrototypeOf(Tunnels.prototype), 'constructor', this).call(this, options);

        this.perspectiveWindow = this.addChild();
        new _famousSrcDomRenderablesDOMElement2['default'](this.perspectiveWindow, {
            properties: {
                perspective: '5000px'
            }
        });

        this.root = this.perspectiveWindow.addChild();
        this.root.setAbsoluteSize(400, 400, 0);
        this.root.setOrigin(.5, .5, .5);
        this.root.setMountPoint(.5, .5, .5);
        this.root.setAlign(.5, .5, .5);
        this.root.setSizeMode(1, 1, 1);

        this.minSpacing = 20;
        this.maxSpacing = 40;
        this.borderRadius = 50;
        this.spacing = new _famousSrcTransitionsTransitionable2['default'](0);
        this.torque = new _famousSrcTransitionsTransitionable2['default'](0);

        this.slices = [];

        var _this = this;
        var id = this.root.addComponent({
            onUpdate: function onUpdate(time) {
                var len = _this.slices.length;
                var torque = _this.torque.get();
                var spacing = _this.spacing.get();
                for (var i = 0; i < len; i++) {
                    _this.slices[i].setPosition(0, 0, i * spacing - len / 2 * spacing);
                    // _this.slices[i].setRotation(0, 0, torque * 2 * Math.PI * -(i - len/2 ) / len);
                    _this.slices[i].setRotation(0, 0, (i - len / 2) / (len / 2) * torque * 2 * Math.PI);
                }

                _this.root.setRotation(time / 2000, time / 2000, 0);
                _this.root.requestUpdateOnNextTick(id);
            }
        });
        this.root.requestUpdate(id);

        this._createTree();
        this.startBreath();
        this.startTorqueAnimation();
    }

    _createClass(Tunnels, [{
        key: '_createTree',
        value: function _createTree() {
            var node;
            var myColors = ['green', 'yellow', 'purple'];

            for (var i = 0; i < 30; i++) {
                node = this.root.addChild();
                node.setPosition(0, 0, -10 * i + 250);
                node.setOrigin(.5, .5, .5);
                new _famousSrcDomRenderablesDOMElement2['default'](node, {
                    properties: {
                        border: '10px solid ' + _helpersColors2['default'][myColors[i % 3]]['500'],
                        borderRadius: this.borderRadius + 'px'
                    }
                });

                // node.setOpacity(.5)
                this.slices.push(node);
            }
        }
    }, {
        key: 'startTorqueAnimation',
        value: function startTorqueAnimation() {
            this.torque.set(1, {
                curve: 'easeInOut',
                duration: 5000
            }, (function () {
                this.torque.set(0, {
                    curve: 'easeInOut',
                    duration: 5000
                }, (function () {
                    this.startTorqueAnimation();
                }).bind(this));
            }).bind(this));
        }
    }, {
        key: 'startBreath',
        value: function startBreath() {
            this.spacing.set(this.maxSpacing, {
                curve: 'easeInOut',
                duration: 7000
            }, (function () {
                this.spacing.set(this.minSpacing, {
                    curve: 'easeInOut',
                    duration: 7000
                }, (function () {
                    this.startBreath();
                }).bind(this));
            }).bind(this));
        }
    }, {
        key: 'getSidebar',
        value: function getSidebar() {}
    }]);

    return Tunnels;
})(_famousSrcCoreNode2['default']);

exports.Tunnels = Tunnels;

},{"../../helpers/colors":12,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46,"famous/src/transitions/Transitionable":68}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcComponentsMountPoint = require('famous/src/components/MountPoint');

var _famousSrcComponentsMountPoint2 = _interopRequireDefault(_famousSrcComponentsMountPoint);

var _famousSrcComponentsAlign = require('famous/src/components/Align');

var _famousSrcComponentsAlign2 = _interopRequireDefault(_famousSrcComponentsAlign);

var _famousSrcComponentsSize = require('famous/src/components/Size');

var _famousSrcComponentsSize2 = _interopRequireDefault(_famousSrcComponentsSize);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _famousSrcTransitionsTransitionable = require('famous/src/transitions/Transitionable');

var _famousSrcTransitionsTransitionable2 = _interopRequireDefault(_famousSrcTransitionsTransitionable);

var _helpersColors = require('../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var _sandboxTentacles = require('../sandbox/Tentacles');

var _sandboxTunnels = require('../sandbox/Tunnels');

var _sandboxSlidingGrid = require('../sandbox/slidingGrid');

var Sandbox = (function (_Node) {
    _inherits(Sandbox, _Node);

    function Sandbox(options) {
        _classCallCheck(this, Sandbox);

        _get(Object.getPrototypeOf(Sandbox.prototype), 'constructor', this).call(this, options);

        this.addChild(new _sandboxTunnels.Tunnels());
        // this.addChild(new Tentacles());
        // this.addChild(new SlidingGrid());
    }

    return Sandbox;
})(_famousSrcCoreNode2['default']);

exports.Sandbox = Sandbox;

},{"../helpers/colors":12,"../sandbox/Tentacles":19,"../sandbox/Tunnels":20,"../sandbox/slidingGrid":22,"famous/src/components/Align":24,"famous/src/components/MountPoint":26,"famous/src/components/Size":29,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46,"famous/src/transitions/Transitionable":68}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _famousSrcTransitionsTransitionable = require('famous/src/transitions/Transitionable');

var _famousSrcTransitionsTransitionable2 = _interopRequireDefault(_famousSrcTransitionsTransitionable);

var _helpersColors = require('../../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var SlidingGrid = (function (_Node) {
    _inherits(SlidingGrid, _Node);

    function SlidingGrid(options) {
        _classCallCheck(this, SlidingGrid);

        _get(Object.getPrototypeOf(SlidingGrid.prototype), 'constructor', this).call(this, options);

        this.perspectiveWindow = this.addChild();
        this.perspectiveWindow.setProportionalSize(1, 1, 0);
        new _famousSrcDomRenderablesDOMElement2['default'](this.perspectiveWindow, {
            properties: {
                perspective: '1000px'
                // background: 'rgba(255, 0, 0, .5)'
            }
        });

        this.root = this.perspectiveWindow.addChild();
        this.root.setAbsoluteSize(4000, 10000, 0);
        this.root.setSizeMode(1, 1, 1);
        this.root.setOrigin(.5, 1, 0);
        this.root.setAlign(.5, 1, 0);
        this.root.setMountPoint(.5, 1, 0);
        this.root.setRotation(Math.PI / 2, 0, 0);
        new _famousSrcDomRenderablesDOMElement2['default'](this.root, {
            properties: {
                background: 'green'
            }
        });

        setTimeout((function () {
            console.log(this.root.getSize());
        }).bind(this), 100);
    }

    _createClass(SlidingGrid, [{
        key: '_createTree',
        value: function _createTree() {}
    }, {
        key: 'getSidebar',
        value: function getSidebar() {}
    }]);

    return SlidingGrid;
})(_famousSrcCoreNode2['default']);

exports.SlidingGrid = SlidingGrid;

},{"../../helpers/colors":12,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46,"famous/src/transitions/Transitionable":68}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, '__esModule', {
    value: true
});

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ('value' in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

function _inherits(subClass, superClass) { if (typeof superClass !== 'function' && superClass !== null) { throw new TypeError('Super expression must either be null or a function, not ' + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _famousSrcCoreNode = require('famous/src/core/Node');

var _famousSrcCoreNode2 = _interopRequireDefault(_famousSrcCoreNode);

var _famousSrcComponentsMountPoint = require('famous/src/components/MountPoint');

var _famousSrcComponentsMountPoint2 = _interopRequireDefault(_famousSrcComponentsMountPoint);

var _famousSrcComponentsPosition = require('famous/src/components/Position');

var _famousSrcComponentsPosition2 = _interopRequireDefault(_famousSrcComponentsPosition);

var _famousSrcComponentsAlign = require('famous/src/components/Align');

var _famousSrcComponentsAlign2 = _interopRequireDefault(_famousSrcComponentsAlign);

var _famousSrcComponentsSize = require('famous/src/components/Size');

var _famousSrcComponentsSize2 = _interopRequireDefault(_famousSrcComponentsSize);

var _famousSrcDomRenderablesDOMElement = require('famous/src/dom-renderables/DOMElement');

var _famousSrcDomRenderablesDOMElement2 = _interopRequireDefault(_famousSrcDomRenderablesDOMElement);

var _famousSrcTransitionsTransitionable = require('famous/src/transitions/Transitionable');

var _famousSrcTransitionsTransitionable2 = _interopRequireDefault(_famousSrcTransitionsTransitionable);

var _helpersColors = require('../helpers/colors');

var _helpersColors2 = _interopRequireDefault(_helpersColors);

var Sidebar = (function (_Node) {
    _inherits(Sidebar, _Node);

    function Sidebar(options) {
        _classCallCheck(this, Sidebar);

        _get(Object.getPrototypeOf(Sidebar.prototype), 'constructor', this).call(this, options);

        this.root = this.addChild();
        this.root.setAlign(1, 0, 0);
        this.root.setPosition(-40, 0, 0);
        this.root.setAbsoluteSize(300, null, null);
        this.root.setSizeMode(1, 0, 0);

        this.containerEl = new _famousSrcDomRenderablesDOMElement2['default'](this.root, {
            properties: {
                boxShadow: '5px 0px 8px rgba(0,0,0,0.26)'
            }
        });

        this.root.addUIEvent('mouseenter');
        this.root.addUIEvent('mouseleave');
        this.root.addUIEvent('touchstart');
        this.root.addUIEvent('click');
        this.root.addComponent({
            onReceive: function onReceive(e) {
                if (e === 'mouseenter') pos.set(-260, 0, 0, { curve: 'linear', duration: 300 });else if (e === 'mouseleave') pos.set(40, 0, 0, { curve: 'linear', duration: 300 });
            }
        });

        this.panelNode = this.root.addChild();
        this.panelNode.setPosition(40, 0, 0);
        var pos = new _famousSrcComponentsPosition2['default'](this.panelNode);
        pos.set(40);
        new _famousSrcDomRenderablesDOMElement2['default'](this.panelNode, {
            properties: {
                backgroundColor: '#303030'
            }
        });

        this.panelHeader = this.panelNode.addChild();
        this.panelHeader.setAbsoluteSize(null, 200, null);
        this.panelHeader.setSizeMode(0, 1, 0);
        new _famousSrcDomRenderablesDOMElement2['default'](this.panelHeader, {
            content: 'Tentacles',
            properties: {
                paddingLeft: '20px',
                fontFamily: 'futura',
                fontSize: '40px',
                color: 'black',
                backgroundColor: _helpersColors2['default'].yellow[500],
                lineHeight: '200px',
                boxShadow: '0px 2px 5px rgba(0,0,0,0.26)'
            }
        });

        this.panelBody = this.panelNode.addChild();
        this.panelBody.setOpacity(.5);
        this.panelBody.setDifferentialSize(0, -300, 0);
        this.panelBody.setPosition(0, 300, 0);
        new _famousSrcDomRenderablesDOMElement2['default'](this.panelNode, {
            properties: {
                backgroundColor: '#303030'
            }
        });
    }

    return Sidebar;
})(_famousSrcCoreNode2['default']);

exports.Sidebar = Sidebar;

},{"../helpers/colors":12,"famous/src/components/Align":24,"famous/src/components/MountPoint":26,"famous/src/components/Position":28,"famous/src/components/Size":29,"famous/src/core/Node":36,"famous/src/dom-renderables/DOMElement":46,"famous/src/transitions/Transitionable":68}],24:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Position = require('./Position');

/**
 * Align is a component designed to allow for smooth tweening
 * of the alignment of a node relative to its parent.
 *
 * @class Align
 * @augments Position
 *
 * @param {Node} node Node that the Align component will be attached to
 */
function Align(node) {
    Position.call(this, node);

    var initial = node.getAlign();

    this._x.set(initial[0]);
    this._y.set(initial[1]);
    this._z.set(initial[2]);
}

/**
 * Return the name of the Align component
 *
 * @method
 *
 * @return {String} Name of the component
 */
Align.prototype.toString = function toString() {
    return 'Align';
};

Align.prototype = Object.create(Position.prototype);
Align.prototype.constructor = Align;

/**
 * When the node this component is attached to updates, update the value
 * of the Node's align.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Align.prototype.update = function update() {
    this._node.setAlign(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

Align.prototype.onUpdate = Align.prototype.update;

module.exports = Align;

},{"./Position":28}],25:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Commands = require('../core/Commands');

/**
 * Camera is a component that is responsible for sending information to the renderer about where
 * the camera is in the scene.  This allows the user to set the type of projection, the focal depth,
 * and other properties to adjust the way the scenes are rendered.
 *
 * @class Camera
 *
 * @param {Node} node to which the instance of Camera will be a component of
 */
function Camera(node) {
    this._node = node;
    this._projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    this._focalDepth = 0;
    this._near = 0;
    this._far = 0;
    this._requestingUpdate = false;
    this._id = node.addComponent(this);
    this._viewTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this._viewDirty = false;
    this._perspectiveDirty = false;
    this.setFlat();
}

Camera.FRUSTUM_PROJECTION = 0;
Camera.PINHOLE_PROJECTION = 1;
Camera.ORTHOGRAPHIC_PROJECTION = 2;

/**
 * @method
 *
 * @return {String} Name of the component
 */
Camera.prototype.toString = function toString() {
    return 'Camera';
};

/**
 * Gets object containing serialized data for the component
 *
 * @method
 *
 * @return {Object} the state of the component
 */
Camera.prototype.getValue = function getValue() {
    return {
        component: this.toString(),
        projectionType: this._projectionType,
        focalDepth: this._focalDepth,
        near: this._near,
        far: this._far
    };
};

/**
 * Set the components state based on some serialized data
 *
 * @method
 *
 * @param {Object} state an object defining what the state of the component should be
 *
 * @return {Boolean} status of the set
 */
Camera.prototype.setValue = function setValue(state) {
    if (this.toString() === state.component) {
        this.set(state.projectionType, state.focalDepth, state.near, state.far);
        return true;
    }
    return false;
};

/**
 * Set the internals of the component
 *
 * @method
 *
 * @param {Number} type an id corresponding to the type of projection to use
 * @param {Number} depth the depth for the pinhole projection model
 * @param {Number} near the distance of the near clipping plane for a frustum projection
 * @param {Number} far the distance of the far clipping plane for a frustum projection
 *
 * @return {Boolean} status of the set
 */
Camera.prototype.set = function set(type, depth, near, far) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._projectionType = type;
    this._focalDepth = depth;
    this._near = near;
    this._far = far;
};

/**
 * Set the camera depth for a pinhole projection model
 *
 * @method
 *
 * @param {Number} depth the distance between the Camera and the origin
 *
 * @return {Camera} this
 */
Camera.prototype.setDepth = function setDepth(depth) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
    this._perspectiveDirty = true;
    this._projectionType = Camera.PINHOLE_PROJECTION;
    this._focalDepth = depth;
    this._near = 0;
    this._far = 0;

    return this;
};

/**
 * Gets object containing serialized data for the component
 *
 * @method
 *
 * @param {Number} near distance from the near clipping plane to the camera
 * @param {Number} far distance from the far clipping plane to the camera
 *
 * @return {Camera} this
 */
Camera.prototype.setFrustum = function setFrustum(near, far) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._perspectiveDirty = true;
    this._projectionType = Camera.FRUSTUM_PROJECTION;
    this._focalDepth = 0;
    this._near = near;
    this._far = far;

    return this;
};

/**
 * Set the Camera to have orthographic projection
 *
 * @method
 *
 * @return {Camera} this
 */
Camera.prototype.setFlat = function setFlat() {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._perspectiveDirty = true;
    this._projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    this._focalDepth = 0;
    this._near = 0;
    this._far = 0;

    return this;
};

/**
 * When the node this component is attached to updates, the Camera will
 * send new camera information to the Compositor to update the rendering
 * of the scene.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Camera.prototype.onUpdate = function onUpdate() {
    this._requestingUpdate = false;

    var path = this._node.getLocation();

    this._node
        .sendDrawCommand(Commands.WITH)
        .sendDrawCommand(path);

    if (this._perspectiveDirty) {
        this._perspectiveDirty = false;

        switch (this._projectionType) {
            case Camera.FRUSTUM_PROJECTION:
                this._node.sendDrawCommand(Commands.FRUSTRUM_PROJECTION);
                this._node.sendDrawCommand(this._near);
                this._node.sendDrawCommand(this._far);
                break;
            case Camera.PINHOLE_PROJECTION:
                this._node.sendDrawCommand(Commands.PINHOLE_PROJECTION);
                this._node.sendDrawCommand(this._focalDepth);
                break;
            case Camera.ORTHOGRAPHIC_PROJECTION:
                this._node.sendDrawCommand(Commands.ORTHOGRAPHIC_PROJECTION);
                break;
        }
    }

    if (this._viewDirty) {
        this._viewDirty = false;

        this._node.sendDrawCommand(Commands.CHANGE_VIEW_TRANSFORM);
        this._node.sendDrawCommand(this._viewTransform[0]);
        this._node.sendDrawCommand(this._viewTransform[1]);
        this._node.sendDrawCommand(this._viewTransform[2]);
        this._node.sendDrawCommand(this._viewTransform[3]);

        this._node.sendDrawCommand(this._viewTransform[4]);
        this._node.sendDrawCommand(this._viewTransform[5]);
        this._node.sendDrawCommand(this._viewTransform[6]);
        this._node.sendDrawCommand(this._viewTransform[7]);

        this._node.sendDrawCommand(this._viewTransform[8]);
        this._node.sendDrawCommand(this._viewTransform[9]);
        this._node.sendDrawCommand(this._viewTransform[10]);
        this._node.sendDrawCommand(this._viewTransform[11]);

        this._node.sendDrawCommand(this._viewTransform[12]);
        this._node.sendDrawCommand(this._viewTransform[13]);
        this._node.sendDrawCommand(this._viewTransform[14]);
        this._node.sendDrawCommand(this._viewTransform[15]);
    }
};

/**
 * When the transform of the node this component is attached to
 * changes, have the Camera update its projection matrix and
 * if needed, flag to node to update.
 *
 * @method
 *
 * @param {Array} transform an array denoting the transform matrix of the node
 *
 * @return {Camera} this
 */
Camera.prototype.onTransformChange = function onTransformChange(transform) {
    var a = transform;
    this._viewDirty = true;

    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
    a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
    a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
    a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

    b00 = a00 * a11 - a01 * a10,
    b01 = a00 * a12 - a02 * a10,
    b02 = a00 * a13 - a03 * a10,
    b03 = a01 * a12 - a02 * a11,
    b04 = a01 * a13 - a03 * a11,
    b05 = a02 * a13 - a03 * a12,
    b06 = a20 * a31 - a21 * a30,
    b07 = a20 * a32 - a22 * a30,
    b08 = a20 * a33 - a23 * a30,
    b09 = a21 * a32 - a22 * a31,
    b10 = a21 * a33 - a23 * a31,
    b11 = a22 * a33 - a23 * a32,

    det = 1/(b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06);

    this._viewTransform[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    this._viewTransform[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    this._viewTransform[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    this._viewTransform[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    this._viewTransform[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    this._viewTransform[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    this._viewTransform[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    this._viewTransform[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    this._viewTransform[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    this._viewTransform[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    this._viewTransform[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    this._viewTransform[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    this._viewTransform[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    this._viewTransform[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    this._viewTransform[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    this._viewTransform[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
};

module.exports = Camera;

},{"../core/Commands":32}],26:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Position = require('./Position');

/**
 * MountPoint is a component designed to allow for smooth tweening
 * of where on the Node it is attached to the parent.
 *
 * @class MountPoint
 * @augments Position
 *
* @param {Node} node Node that the MountPoint component will be attached to
 */
function MountPoint(node) {
    Position.call(this, node);

    var initial = node.getMountPoint();

    this._x.set(initial[0]);
    this._y.set(initial[1]);
    this._z.set(initial[2]);
}

/**
 * Return the name of the MountPoint component
 *
 * @method
 *
 * @return {String} Name of the component
 */
MountPoint.prototype.toString = function toString() {
    return 'MountPoint';
};

MountPoint.prototype = Object.create(Position.prototype);
MountPoint.prototype.constructor = MountPoint;

/**
 * When the node this component is attached to updates, update the value
 * of the Node's mount point.
 *
 * @method
 *
 * @return {undefined} undefined
 */
MountPoint.prototype.update = function update() {
    this._node.setMountPoint(this._x.get(), this._y.get(), this._z.get());
    this._checkUpdate();
};

MountPoint.prototype.onUpdate = MountPoint.prototype.update;

module.exports = MountPoint;

},{"./Position":28}],27:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Transitionable = require('../transitions/Transitionable');


/**
 * Opacity is a component designed to allow for smooth tweening
 * of the Node's opacity
 *
 * @class Opacity
 *
 * @param {Node} node Node that the Opacity component is attached to
 */
function Opacity(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._value = new Transitionable(1);

    this._requestingUpdate = false;
}

/**
 * Return the name of the Opacity component
 *
 * @method
 *
 * @return {String} Name of the component
 */
Opacity.prototype.toString = function toString() {
    return 'Opacity';
};

/**
 * Retrieves internal state of Opacity component
 *
 * @method
 *
 * @return {Object} contains component key which holds the stringified constructor 
 * and value key which contains the numeric value
 */
Opacity.prototype.getValue = function getValue() {
    return {
        component: this.toString(),
        value: this._value.get()
    };
};

/**
 * Set the internal state of the Opacity component
 *
 * @method
 *
 * @param {Object} value Object containing the component key, which holds stringified constructor, and a value key, which contains a numeric value used to set opacity if the constructor value matches
 *
 * @return {Boolean} true if set is successful, false otherwise
 */
Opacity.prototype.setValue = function setValue(value) {
    if (this.toString() === value.component) {
        this.set(value.value);
        return true;
    }
    return false;
};

/**
 * Set the opacity of the Node
 *
 * @method
 *
 * @param {Number} value value used to set Opacity
 * @param {Object} transition options for the transition
 * @param {Function} callback to be called following Opacity set completion
 *
 * @return {Opacity} this
 */
Opacity.prototype.set = function set(value, transition, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._value.set(value, transition, callback);
    return this;
};

/**
 * Get the current opacity for the component
 *
 * @method
 *
 * @return {Number} opacity as known by the component
 */
Opacity.prototype.get = function get() {
    return this._value.get();
};

/**
 * Stops Opacity transition
 *
 * @method
 *
 * @return {Opacity} this
 */
Opacity.prototype.halt = function halt() {
    this._value.halt();
    return this;
};

/**
 * Tells whether or not the opacity is in a transition
 *
 * @method
 *
 * @return {Boolean} whether or not the opacity is transitioning
 */
Opacity.prototype.isActive = function isActive(){
    return this._value.isActive();
};

/**
 * When the node this component is attached to updates, update the value
 * of the Node's opacity.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Opacity.prototype.update = function update () {
    this._node.setOpacity(this._value.get());
    
    if (this._value.isActive()) {
      this._node.requestUpdateOnNextTick(this._id);
    }
    else {
      this._requestingUpdate = false;
    }
};

Opacity.prototype.onUpdate = Opacity.prototype.update;

module.exports = Opacity;

},{"../transitions/Transitionable":68}],28:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Transitionable = require('../transitions/Transitionable');

/**
 * The Position component serves as a way to tween to translation of a Node.
 *  It is also the base class for the other core components that interact
 * with the Vec3 properties on the Node
 *
 * @class Position
 *
 * @param {Node} node Node that the Position component will be attached to
 */
function Position(node) {
    this._node = node;
    this._id = node.addComponent(this);
  
    this._requestingUpdate = false;
    
    var initialPosition = node.getPosition();

    this._x = new Transitionable(initialPosition[0]);
    this._y = new Transitionable(initialPosition[1]);
    this._z = new Transitionable(initialPosition[2]);
}

/**
 * Return the name of the Position component
 *
 * @method
 *
 * @return {String} Name of the component
 */
Position.prototype.toString = function toString() {
    return 'Position';
};

/**
 * Gets object containing stringified constructor, and corresponding dimensional values
 *
 * @method
 *
 * @return {Object} the internal state of the component
 */
Position.prototype.getValue = function getValue() {
    return {
        component: this.toString(),
        x: this._x.get(),
        y: this._y.get(),
        z: this._z.get()
    };
};

/**
 * Set the translation of the Node
 *
 * @method
 *
 * @param {Object} state Object -- component: stringified constructor, x: number, y: number, z: number
 *
 * @return {Boolean} status of the set
 */
Position.prototype.setValue = function setValue(state) {
    if (this.toString() === state.component) {
        this.set(state.x, state.y, state.z);
        return true;
    }
    return false;
};

/**
 * Getter for X translation
 *
 * @method
 *
 * @return {Number} the Node's translation along its x-axis
 */
Position.prototype.getX = function getX() {
    return this._x.get();
};

/**
 * Getter for Y translation
 *
 * @method
 *
 * @return {Number} the Node's translation along its Y-axis
 */
Position.prototype.getY = function getY() {
    return this._y.get();
};

/**
 * Getter for z translation
 *
 * @method
 *
 * @return {Number} the Node's translation along its z-axis
 */
Position.prototype.getZ = function getZ() {
    return this._z.get();
};

/**
 * Whether or not the Position is currently changing
 *
 * @method
 *
 * @return {Boolean} whether or not the Position is changing the Node's position
 */
Position.prototype.isActive = function isActive() {
    return this._x.isActive() || this._y.isActive() || this._z.isActive();
};

/**
 * Decide whether the component needs to be updated on the next tick.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
Position.prototype._checkUpdate = function _checkUpdate() {
    if (this.isActive()) this._node.requestUpdateOnNextTick(this._id);
    else this._requestingUpdate = false;
};

/**
 * When the node this component is attached to updates, update the value
 * of the Node's position
 *
 * @method
 *
 * @return {undefined} undefined
 */
Position.prototype.update = function update () {
    this._checkUpdate();
    this._node.setPosition(this._x.get(), this._y.get(), this._z.get());
};

Position.prototype.onUpdate = Position.prototype.update;

/** 
 * Setter for X position
 *
 * @method
 * 
 * @param {Number} val used to set x coordinate
 * @param {Object} transition options for the transition
 * @param {Function} callback function to execute after setting X 
 *
 * @return {Position} this
 */
Position.prototype.setX = function setX(val, transition, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._x.set(val, transition, callback);
    return this;
};

/** 
 * Setter for Y position
 *
 * @method
 * 
 * @param {Number} val used to set y coordinate
 * @param {Object} transition options for the transition
 * @param {Function} callback function to execute after setting Y 
 *
 * @return {Position} this
 */
Position.prototype.setY = function setY(val, transition, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._y.set(val, transition, callback);
    return this;
};

/** 
 * Setter for Z position
 *
 * @method
 * 
 * @param {Number} val used to set z coordinate
 * @param {Object} transition options for the transition
 * @param {Function} callback function to execute after setting Z 
 *
 * @return {Position} this
 */
Position.prototype.setZ = function setZ(val, transition, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    this._z.set(val, transition, callback);
    return this;
};


/** 
 * Setter for X, Y, and Z positions
 *
 * @method
 * 
 * @param {Number} x used to set x coordinate
 * @param {Number} y used to set y coordinate
 * @param {Number} z used to set z coordinate
 * @param {Object} transition options for the transition
 * @param {Function} callback function to execute after setting X 
 *
 * @return {Position} this
 */
Position.prototype.set = function set(x, y, z, transition, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    if (x != null) this._x.set(x, transition, xCallback);
    if (y != null) this._y.set(y, transition, yCallback);
    if (z != null) this._z.set(z, transition, zCallback);

    return this;
};

/**
 * Stops transition of Position component
 *
 * @method
 *
 * @return {Position} this
 */
Position.prototype.halt = function halt() {
    this._x.halt();
    this._y.halt();
    this._z.halt();
    return this;
};

module.exports = Position;

},{"../transitions/Transitionable":68}],29:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Transitionable = require('../transitions/Transitionable');
var SizeSystem = require('../core/SizeSystem');

/**
 * Size component used for managing the size of the Node it is attached to.
 * Supports absolute and relative (proportional and differential) sizing.
 *
 * @class Size
 *
 * @param {Node} node Node that the Size component is attached to
 */
function Size(node) {
    this._node = node;
    this._id = node.addComponent(this);
    this._requestingUpdate = false;

    var initialProportionalSize = node.getProportionalSize();
    var initialDifferentialSize = node.getDifferentialSize();
    var initialAbsoluteSize = node.getAbsoluteSize();

    this._proportional = {
        x: new Transitionable(initialProportionalSize[0]),
        y: new Transitionable(initialProportionalSize[1]),
        z: new Transitionable(initialProportionalSize[2])
    };
    this._differential = {
        x: new Transitionable(initialDifferentialSize[0]),
        y: new Transitionable(initialDifferentialSize[1]),
        z: new Transitionable(initialDifferentialSize[2])
    };
    this._absolute = {
        x: new Transitionable(initialAbsoluteSize[0]),
        y: new Transitionable(initialAbsoluteSize[1]),
        z: new Transitionable(initialAbsoluteSize[2])
    };
}

Size.RELATIVE = 0;
Size.ABSOLUTE = 1;
Size.RENDER = 2;
Size.DEFAULT = Size.RELATIVE;

/**
 * Set which mode each axis of Size will have its dimensions
 * calculated by.  Size can be calculated by absolute pixel definitions,
 * relative to its parent, or by the size of its renderables
 *
 * @method
 *
 * @param {Number} x the mode of size for the width
 * @param {Number} y the mode of size for the height
 * @param {Number} z the mode of size for the depth
 *
 * @return {Size} this
 */
Size.prototype.setMode = function setMode(x, y, z) {
    this._node.setSizeMode(x, y, z);
    return this;
};

/**
 * Return the name of the Size component
 *
 * @method
 *
 * @return {String} Name of the component
 */
Size.prototype.toString = function toString() {
    return 'Size';
};

/**
 * @typedef absoluteSizeValue
 * @type {Object}
 * @property {String} type current type of sizing being applied ('absolute')
 * @property {String} component component name ('Size')
 * @property {number} x
 * @property {number} y
 * @property {number} z
 */

/**
 * @typedef relativeSizeValue
 * @type {Object}
 * @property {String} type current type of sizing being applied ('relative')
 * @property {String} component component name ('Size')
 * @property {Object} differential
 * @property {number} differential.x
 * @property {number} differential.y
 * @property {number} differential.z
 * @property {Object} proportional
 * @property {number} proportional.x
 * @property {number} proportional.y
 * @property {number} proportional.z
 */

/**
 * Returns serialized state of the component.
 *
 * @method
 *
 * @return {Object} the internal state of the component
 */
Size.prototype.getValue = function getValue() {
    return {
        sizeMode: SizeSystem.get(this._node.getLocation()).getSizeMode(),
        absolute: {
            x: this._absolute.x.get(),
            y: this._absolute.y.get(),
            z: this._absolute.z.get()
        },
        differential: {
            x: this._differential.x.get(),
            y: this._differential.y.get(),
            z: this._differential.z.get()
        },
        proportional: {
            x: this._proportional.x.get(),
            y: this._proportional.y.get(),
            z: this._proportional.z.get()
        }
    };
};

/**
 * Updates state of component.
 *
 * @method
 *
 * @param {Object} state state encoded in same format as state retrieved through `getValue`
 *
 * @return {Boolean} boolean indicating whether the new state has been applied
 */
Size.prototype.setValue = function setValue(state) {
    if (this.toString() === state.component) {
        this.setMode.apply(this, state.sizeMode);
        if (state.absolute) {
            this.setAbsolute(state.absolute.x, state.absolute.y, state.absolute.z);
        }
        if (state.differential) {
            this.setAbsolute(state.differential.x, state.differential.y, state.differential.z);
        }
        if (state.proportional) {
            this.setAbsolute(state.proportional.x, state.proportional.y, state.proportional.z);
        }
    }
    return false;
};

/**
 * Helper function that grabs the activity of a certain type of size.
 *
 * @method
 * @private
 *
 * @param {Object} type Representation of a type of the sizing model
 *
 * @return {Boolean} boolean indicating whether the new state has been applied
 */
Size.prototype._isActive = function _isActive(type) {
    return type.x.isActive() || type.y.isActive() || type.z.isActive();
};

/**
 * Helper function that grabs the activity of a certain type of size.
 *
 * @method
 *
 * @param {String} type Type of size
 *
 * @return {Boolean} boolean indicating whether the new state has been applied
 */

Size.prototype.isActive = function isActive(){
    return (
        this._isActive(this._absolute) ||
        this._isActive(this._proportional) ||
        this._isActive(this._differential)
    );
};

/**
 * When the node this component is attached to updates, update the value
 * of the Node's size.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Size.prototype.onUpdate = function onUpdate() {
    var abs = this._absolute;
    this._node.setAbsoluteSize(
        abs.x.get(),
        abs.y.get(),
        abs.z.get()
    );
    var prop = this._proportional;
    var diff = this._differential;
    this._node.setProportionalSize(
        prop.x.get(),
        prop.y.get(),
        prop.z.get()
    );
    this._node.setDifferentialSize(
        diff.x.get(),
        diff.y.get(),
        diff.z.get()
    );

    if (this.isActive()) this._node.requestUpdateOnNextTick(this._id);
    else this._requestingUpdate = false;
};


/**
* Applies absolute size.
*
* @method
*
* @param {Number} x used to set absolute size in x-direction (width)
* @param {Number} y used to set absolute size in y-direction (height)
* @param {Number} z used to set absolute size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
* @return {Size} this
*/
Size.prototype.setAbsolute = function setAbsolute(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    var abs = this._absolute;
    if (x != null) {
        abs.x.set(x, options, xCallback);
    }
    if (y != null) {
        abs.y.set(y, options, yCallback);
    }
    if (z != null) {
        abs.z.set(z, options, zCallback);
    }
};

/**
* Applies proportional size.
*
* @method
*
* @param {Number} x used to set proportional size in x-direction (width)
* @param {Number} y used to set proportional size in y-direction (height)
* @param {Number} z used to set proportional size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
* @return {Size} this
*/
Size.prototype.setProportional = function setProportional(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    var prop = this._proportional;
    if (x != null) {
        prop.x.set(x, options, xCallback);
    }
    if (y != null) {
        prop.y.set(y, options, yCallback);
    }
    if (z != null) {
        prop.z.set(z, options, zCallback);
    }
    return this;
};

/**
* Applies differential size to Size component.
*
* @method
*
* @param {Number} x used to set differential size in x-direction (width)
* @param {Number} y used to set differential size in y-direction (height)
* @param {Number} z used to set differential size in z-direction (depth)
* @param {Object} options options hash
* @param {Function} callback callback function to be executed after the
*                            transitions have been completed
* @return {Size} this
*/
Size.prototype.setDifferential = function setDifferential(x, y, z, options, callback) {
    if (!this._requestingUpdate) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }

    var xCallback;
    var yCallback;
    var zCallback;

    if (z != null) {
        zCallback = callback;
    }
    else if (y != null) {
        yCallback = callback;
    }
    else if (x != null) {
        xCallback = callback;
    }

    var diff = this._differential;
    if (x != null) {
        diff.x.set(x, options, xCallback);
    }
    if (y != null) {
        diff.y.set(y, options, yCallback);
    }
    if (z != null) {
        diff.z.set(z, options, zCallback);
    }
    return this;
};

/**
 * Retrieves the computed size applied to the underlying Node.
 *
 * @method
 *
 * @return {Array} size three dimensional computed size
 */
Size.prototype.get = function get () {
    return this._node.getSize();
};

/**
 * Halts all currently active size transitions.
 *
 * @method
 *
 * @return {Size} this
 */
Size.prototype.halt = function halt () {
    this._proportional.x.halt();
    this._proportional.y.halt();
    this._proportional.z.halt();
    this._differential.x.halt();
    this._differential.y.halt();
    this._differential.z.halt();
    this._absolute.x.halt();
    this._absolute.y.halt();
    this._absolute.z.halt();
    return this;
};

module.exports = Size;

},{"../core/SizeSystem":42,"../transitions/Transitionable":68}],30:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Channels are being used for interacting with the UI Thread when running in
 * a Web Worker or with the UIManager/ Compositor when running in single
 * threaded mode (no Web Worker).
 *
 * @class Channel
 * @constructor
 */
function Channel() {
    if (typeof self !== 'undefined' && self.window !== self) {
        this._enterWorkerMode();
    }
}


/**
 * Called during construction. Subscribes for `message` event and routes all
 * future `sendMessage` messages to the Main Thread ("UI Thread").
 *
 * Primarily used for testing.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Channel.prototype._enterWorkerMode = function _enterWorkerMode() {
    this._workerMode = true;
    var _this = this;
    self.addEventListener('message', function onmessage(ev) {
        _this.onMessage(ev.data);
    });
};

/**
 * Meant to be overridden by `Famous`.
 * Assigned method will be invoked for every received message.
 *
 * @type {Function}
 * @override
 *
 * @return {undefined} undefined
 */
Channel.prototype.onMessage = null;

/**
 * Sends a message to the UIManager.
 *
 * @param  {Any}    message Arbitrary message object.
 *
 * @return {undefined} undefined
 */
Channel.prototype.sendMessage = function sendMessage (message) {
    if (this._workerMode) {
        self.postMessage(message);
    }
    else {
        this.onmessage(message);
    }
};

/**
 * Meant to be overriden by the UIManager when running in the UI Thread.
 * Used for preserving API compatibility with Web Workers.
 * When running in Web Worker mode, this property won't be mutated.
 *
 * Assigned method will be invoked for every message posted by `famous-core`.
 *
 * @type {Function}
 * @override
 */
Channel.prototype.onmessage = null;

/**
 * Sends a message to the manager of this channel (the `Famous` singleton) by
 * invoking `onMessage`.
 * Used for preserving API compatibility with Web Workers.
 *
 * @private
 * @alias onMessage
 *
 * @param {Any} message a message to send over the channel
 *
 * @return {undefined} undefined
 */
Channel.prototype.postMessage = function postMessage(message) {
    return this.onMessage(message);
};

module.exports = Channel;

},{}],31:[function(require,module,exports){
(function (process){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var assert = require('../utilities/assert');

/**
 * Equivalent of an Engine in the Worker Thread. Used to synchronize and manage
 * time across different Threads.
 *
 * @class  Clock
 * @constructor
 * @private
 */
function Clock () {
    this._time = 0;
    this._frame = 0;
    this._timerQueue = [];
    this._updatingIndex = 0;

    this._scale = 1;
    this._scaledTime = this._time;
}

/**
 * Sets the scale at which the clock time is passing.
 * Useful for slow-motion or fast-forward effects.
 *
 * `1` means no time scaling ("realtime"),
 * `2` means the clock time is passing twice as fast,
 * `0.5` means the clock time is passing two times slower than the "actual"
 * time at which the Clock is being updated via `.step`.
 *
 * Initally the clock time is not being scaled (factor `1`).
 *
 * @method  setScale
 * @chainable
 *
 * @param {Number} scale    The scale at which the clock time is passing.
 *
 * @return {Clock} this
 */
Clock.prototype.setScale = function setScale (scale) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof scale === 'number', 'scale needs to be a number');

    this._scale = scale;
    return this;
};

/**
 * @method  getScale
 *
 * @return {Number} scale    The scale at which the clock time is passing.
 */
Clock.prototype.getScale = function getScale () {
    return this._scale;
};

/**
 * Updates the internal clock time.
 *
 * @method  step
 * @chainable
 *
 * @param  {Number} time high resolution timestamp used for invoking the
 *                       `update` method on all registered objects
 * @return {Clock}       this
 */
Clock.prototype.step = function step (time) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof time === 'number', 'time needs to be a number');

    this._frame++;

    this._scaledTime = this._scaledTime + (time - this._time)*this._scale;
    this._time = time;

    for (var i = 0; i < this._timerQueue.length; i++) {
        if (this._timerQueue[i](this._scaledTime)) {
            this._timerQueue.splice(i, 1);
        }
    }
    return this;
};

/**
 * Returns the internal clock time.
 *
 * @method  now
 *
 * @return  {Number} time high resolution timestamp used for invoking the
 *                       `update` method on all registered objects
 */
Clock.prototype.now = function now () {
    return this._scaledTime;
};

/**
 * Returns the internal clock time.
 *
 * @method  getTime
 * @deprecated Use #now instead
 *
 * @return  {Number} time high resolution timestamp used for invoking the
 *                       `update` method on all registered objects
 */
Clock.prototype.getTime = Clock.prototype.now;

/**
 * Returns the number of frames elapsed so far.
 *
 * @method getFrame
 *
 * @return {Number} frames
 */
Clock.prototype.getFrame = function getFrame () {
    return this._frame;
};

/**
 * Wraps a function to be invoked after a certain amount of time.
 * After a set duration has passed, it executes the function and
 * removes it as a listener to 'prerender'.
 *
 * @method setTimeout
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} delay milliseconds from now to execute the function
 *
 * @return {Function} timer function used for Clock#clearTimer
 */
Clock.prototype.setTimeout = function (callback, delay) {
    if (process.env.NODE_ENV === 'development') {
        assert(typeof callback === 'function', 'callback needs to be a function');
        assert(typeof delay === 'number', 'delay needs to be a number');
    }

    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;
    var timer = function(time) {
        if (time - startedAt >= delay) {
            callback.apply(null, params);
            return true;
        }
        return false;
    };
    this._timerQueue.push(timer);
    return timer;
};


/**
 * Wraps a function to be invoked after a certain amount of time.
 *  After a set duration has passed, it executes the function and
 *  resets the execution time.
 *
 * @method setInterval
 *
 * @param {Function} callback function to be run after a specified duration
 * @param {Number} delay interval to execute function in milliseconds
 *
 * @return {Function} timer function used for Clock#clearTimer
 */
Clock.prototype.setInterval = function setInterval(callback, delay) {
    if (process.env.NODE_ENV === 'development') {
        assert(typeof callback === 'function', 'callback needs to be a function');
        assert(typeof delay === 'number', 'delay needs to be a number');
    }

    var params = Array.prototype.slice.call(arguments, 2);
    var startedAt = this._time;
    var timer = function(time) {
        if (time - startedAt >= delay) {
            callback.apply(null, params);
            startedAt = time;
        }
        return false;
    };
    this._timerQueue.push(timer);
    return timer;
};

/**
 * Removes previously via `Clock#setTimeout` or `Clock#setInterval`
 * registered callback function
 *
 * @method clearTimer
 * @chainable
 *
 * @param  {Function} timer  previously by `Clock#setTimeout` or
 *                              `Clock#setInterval` returned callback function
 * @return {Clock}              this
 */
Clock.prototype.clearTimer = function (timer) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof timer === 'function', 'timer needs to be a function');

    var index = this._timerQueue.indexOf(timer);
    if (index !== -1) {
        this._timerQueue.splice(index, 1);
    }
    return this;
};

module.exports = Clock;

}).call(this,require('_process'))

},{"../utilities/assert":70,"_process":1}],32:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * An enumeration of the commands in our command queue.
 */
var Commands = {
    INIT_DOM: 0,
    DOM_RENDER_SIZE: 1,
    CHANGE_TRANSFORM: 2,
    CHANGE_SIZE: 3,
    CHANGE_STYLE: 4,
    CHANGE_CONTENT: 5,
    CHANGE_ATTRIBUTE: 6,
    ADD_CLASS: 7,
    REMOVE_CLASS: 8,
    SUBSCRIBE: 9,
    GL_SET_DRAW_OPTIONS: 10,
    GL_AMBIENT_LIGHT: 11,
    GL_LIGHT_POSITION: 12,
    GL_LIGHT_COLOR: 13,
    MATERIAL_INPUT: 14,
    GL_SET_GEOMETRY: 15,
    GL_UNIFORMS: 16,
    GL_BUFFER_DATA: 17,
    GL_CUTOUT_STATE: 18,
    GL_MESH_VISIBILITY: 19,
    GL_REMOVE_MESH: 20,
    PINHOLE_PROJECTION: 21,
    ORTHOGRAPHIC_PROJECTION: 22,
    CHANGE_VIEW_TRANSFORM: 23,
    WITH: 24,
    FRAME: 25,
    ENGINE: 26,
    START: 27,
    STOP: 28,
    TIME: 29,
    TRIGGER: 30,
    NEED_SIZE_FOR: 31,
    DOM: 32,
    READY: 33,
    ALLOW_DEFAULT: 34,
    PREVENT_DEFAULT: 35,
    UNSUBSCRIBE: 36,
    REMOVE_SCENE: 37,
    prettyPrint: function (buffer, start, count) {
        var callback;
        start = start ? start : 0;
        var data = {
            i: start,
            result: ''
        };
        for (var len = count ? count + start : buffer.length ; data.i < len ; data.i++) {
            callback = commandPrinters[buffer[data.i]];
            if (!callback) throw new Error('PARSE ERROR: no command registered for: ' + buffer[data.i]);
            callback(buffer, data);
        }
        return data.result;
    }
};

var commandPrinters = [];

commandPrinters[Commands.INIT_DOM] = function init_dom (buffer, data) {
    data.result += data.i + '. INIT_DOM\n    tagName: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.DOM_RENDER_SIZE] = function dom_render_size (buffer, data) {
    data.result += data.i + '. DOM_RENDER_SIZE\n    selector: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.CHANGE_TRANSFORM] = function change_transform (buffer, data) {
    data.result += data.i + '. CHANGE_TRANSFORM\n    val: [';
    for (var j = 0 ; j < 16 ; j++) data.result += buffer[++data.i] + (j < 15 ? ', ' : '');
    data.result += ']\n\n';
};

commandPrinters[Commands.CHANGE_SIZE] = function change_size (buffer, data) {
    data.result += data.i + '. CHANGE_SIZE\n    x: ' + buffer[++data.i] + ', y: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.CHANGE_STYLE] = function CHANGE_STYLE (buffer, data) {
    data.result += data.i + '. CHANGE_STYLE\n    key: ' + buffer[++data.i] + ', value: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.CHANGE_CONTENT] = function change_content (buffer, data) {
    data.result += data.i + '. CHANGE_CONTENT\n    content: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.CHANGE_ATTRIBUTE] = function change_attribute (buffer, data) {
    data.result += data.i + '. CHANGE_ATTRIBUTE\n    key: ' + buffer[++data.i] + ', value: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.ADD_CLASS] = function add_class (buffer, data) {
    data.result += data.i + '. ADD_CLASS\n    className: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.REMOVE_CLASS] = function remove_class (buffer, data) {
    data.result += data.i + '. REMOVE_CLASS\n    className: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.SUBSCRIBE] = function subscribe (buffer, data) {
    data.result += data.i + '. SUBSCRIBE\n    event: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.GL_SET_DRAW_OPTIONS] = function gl_set_draw_options (buffer, data) {
    data.result += data.i + '. GL_SET_DRAW_OPTIONS\n    options: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.GL_AMBIENT_LIGHT] = function gl_ambient_light (buffer, data) {
    data.result += data.i + '. GL_AMBIENT_LIGHT\n    r: ' + buffer[++data.i] + 'g: ' + buffer[++data.i] + 'b: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.GL_LIGHT_POSITION] = function gl_light_position (buffer, data) {
    data.result += data.i + '. GL_LIGHT_POSITION\n    x: ' + buffer[++data.i] + 'y: ' + buffer[++data.i] + 'z: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.GL_LIGHT_COLOR] = function gl_light_color (buffer, data) {
    data.result += data.i + '. GL_LIGHT_COLOR\n    r: ' + buffer[++data.i] + 'g: ' + buffer[++data.i] + 'b: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.MATERIAL_INPUT] = function material_input (buffer, data) {
    data.result += data.i + '. MATERIAL_INPUT\n    key: ' + buffer[++data.i] + ', value: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.GL_SET_GEOMETRY] = function gl_set_geometry (buffer, data) {
    data.result += data.i + '. GL_SET_GEOMETRY\n   x: ' + buffer[++data.i] + ', y: ' + buffer[++data.i] + ', z: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.GL_UNIFORMS] = function gl_uniforms (buffer, data) {
    data.result += data.i + '. GL_UNIFORMS\n    key: ' + buffer[++data.i] + ', value: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.GL_BUFFER_DATA] = function gl_buffer_data (buffer, data) {
    data.result += data.i + '. GL_BUFFER_DATA\n    data: ';
    for (var i = 0; i < 5 ; i++) data.result += buffer[++data.i] + ', ';
    data.result += '\n\n';
};

commandPrinters[Commands.GL_CUTOUT_STATE] = function gl_cutout_state (buffer, data) {
    data.result += data.i + '. GL_CUTOUT_STATE\n    state: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.GL_MESH_VISIBILITY] = function gl_mesh_visibility (buffer, data) {
    data.result += data.i + '. GL_MESH_VISIBILITY\n    visibility: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.GL_REMOVE_MESH] = function gl_remove_mesh (buffer, data) {
    data.result += data.i + '. GL_REMOVE_MESH\n\n';
};

commandPrinters[Commands.PINHOLE_PROJECTION] = function pinhole_projection (buffer, data) {
    data.result += data.i + '. PINHOLE_PROJECTION\n    depth: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.ORTHOGRAPHIC_PROJECTION] = function orthographic_projection (buffer, data) {
    data.result += data.i + '. ORTHOGRAPHIC_PROJECTION\n';
};

commandPrinters[Commands.CHANGE_VIEW_TRANSFORM] = function change_view_transform (buffer, data) {
    data.result += data.i + '. CHANGE_VIEW_TRANSFORM\n   value: [';
    for (var i = 0; i < 16 ; i++) data.result += buffer[++data.i] + (i < 15 ? ', ' : '');
    data.result += ']\n\n';
};

commandPrinters[Commands.PREVENT_DEFAULT] = function prevent_default (buffer, data) {
    data.result += data.i + '. PREVENT_DEFAULT\n    value: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.ALLOW_DEFAULT] = function allow_default (buffer, data) {
    data.result += data.i + '. ALLOW_DEFAULT\n    value: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.READY] = function ready (buffer, data) {
    data.result += data.i + '. READY\n\n';
};

commandPrinters[Commands.WITH] = function w (buffer, data) {
    data.result += data.i + '. **WITH**\n     path: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.TIME] = function time (buffer, data) {
    data.result += data.i + '. TIME\n     ms: ' + buffer[++data.i] + '\n\n';
};

commandPrinters[Commands.NEED_SIZE_FOR] = function need_size_for (buffer, data) {
    data.result += data.i + '. NEED_SIZE_FOR\n    selector: ' + buffer[++data.i] + '\n\n';
};

module.exports = Commands;

},{}],33:[function(require,module,exports){
(function (process){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Event = require('./Event');
var PathUtils = require('./Path');
var assert = require('../utilities/assert');

/**
 * The Dispatch class is used to propogate events down the
 * scene graph.
 *
 * @class Dispatch
 * @param {Scene} context The context on which it operates
 */
function Dispatch () {
    this._nodes = {}; // a container for constant time lookup of nodes
}

/**
 * Protected method that sets the updater for the dispatch. The updater will
 * almost certainly be the FamousEngine class.
 *
 * @method
 * @protected
 *
 * @param {FamousEngine} updater The updater which will be passed through the scene graph
 *
 * @return {undefined} undefined
 */
Dispatch.prototype._setUpdater = function _setUpdater (updater) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof updater === 'object', 'updater needs to be an object');

    this._updater = updater;

    for (var key in this._nodes) this._nodes[key]._setUpdater(updater);
};

/**
 * Calls the onMount method for the node at a given path and
 * properly registers all of that nodes children to their proper
 * paths. Throws if that path doesn't have a node registered as
 * a parent or if there is no node registered at that path.
 *
 * @method mount
 *
 * @param {String} path at which to begin mounting
 * @param {Node} node the node that was mounted
 *
 * @return {Node} the node that has been mounted
 */
Dispatch.prototype.mount = function mount (path, node) {
    if (process.env.NODE_ENV === 'development') {
        assert(typeof path === 'string', 'path needs to be a string');
        assert(typeof node === 'object', 'node needs to be an object');
        assert(!this._nodes[path], 'node already registered at path ' + path);
    }

    node._setUpdater(this._updater);
    this._nodes[path] = node;
    var parentPath = PathUtils.parent(path);

    // scenes are their own parents
    var parent = parentPath ? this._nodes[parentPath] : node;

    if (process.env.NODE_ENV === 'development')
        assert(parent, 'no parent registered at path ' + parentPath);

    var children = node.getChildren();
    var components = node.getComponents();
    var i;
    var len;

    if (parent.isMounted()) node._setMounted(true, path);
    if (parent.isShown()) node._setShown(true);

    if (parent.isMounted()) {
        node._setParent(parent);
        if (node.onMount) node.onMount(path);

        for (i = 0, len = components.length ; i < len ; i++)
            if (components[i] && components[i].onMount)
                components[i].onMount(node, i);

        for (i = 0, len = children.length ; i < len ; i++)
            if (children[i] && children[i].mount) children[i].mount(path + '/' + i);
            else if (children[i]) this.mount(path + '/' + i, children[i]);
    }

    if (parent.isShown()) {
        if (node.onShow) node.onShow();
        for (i = 0, len = components.length ; i < len ; i++)
            if (components[i] && components[i].onShow)
                components[i].onShow();
    }

    return node;
};

/**
 * Calls the onDismount method for the node at a given path
 * and deregisters all of that nodes children. Throws if there
 * is no node registered at that path.
 *
 * @method dismount
 * @return {void}
 *
 * @param {String} path at which to begin dismounting
 * @return {Node} the node that has been dismounted
 */
Dispatch.prototype.dismount = function dismount (path) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof path === 'string', 'path needs to be a string');

    var node = this._nodes[path];

    if (process.env.NODE_ENV === 'development')
        assert(node, 'No node registered at path ' + path);

    var children = node.getChildren();
    var components = node.getComponents();
    var i;
    var len;

    if (node.isShown()) {
        node._setShown(false);
        if (node.onHide) node.onHide();
        for (i = 0, len = components.length ; i < len ; i++)
            if (components[i] && components[i].onHide)
                components[i].onHide();
    }

    if (node.isMounted()) {
        if (node.onDismount) node.onDismount(path);

        for (i = 0, len = children.length ; i < len ; i++)
            if (children[i] && children[i].dismount) children[i].dismount();
            else if (children[i]) this.dismount(path + '/' + i);

        for (i = 0, len = components.length ; i < len ; i++)
            if (components[i] && components[i].onDismount)
                components[i].onDismount();

        node._setMounted(false);
        node._setParent(null);
    }

    this._nodes[path] = null;

    return node;
};

/**
 * Returns a the node registered to the given path, or none
 * if no node exists at that path.
 *
 * @method getNode
 *
 * @param {String} path at which to look up the node
 * @return {Node | void} node at the given path
 */
Dispatch.prototype.getNode = function getNode (path) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof path === 'string', 'path needs to be a string');

    return this._nodes[path];
};

/**
 * Issues the onShow method to the node registered at the given path,
 * and shows the entire subtree below that node. Throws if no node
 * is registered to this path.
 *
 * @method show
 * @return {void}
 *
 * @param {String} path the path of the node to show
 * @return {Node} The node that has been shown
 */
Dispatch.prototype.show = function show (path) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof path === 'string', 'path needs to be a string');

    var node = this._nodes[path];

    if (process.env.NODE_ENV === 'development')
        assert(node, 'No node registered at path ' + path);

    if (node.onShow) node.onShow();

    var components = node.getComponents();
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onShow)
            components[i].onShow();

    var queue = allocQueue();

    addChildrenToQueue(node, queue);
    var child;

    while ((child = breadthFirstNext(queue)))
        this.show(child.getLocation());

    node._setShown(true);

    deallocQueue(queue);

    return node;
};

/**
 * Issues the onHide method to the node registered at the given path,
 * and hides the entire subtree below that node. Throws if no node
 * is registered to this path.
 *
 * @method hide
 * @return {void}
 *
 * @param {String} path the path of the node to hide
 * @return {Node} The node that has been hidden
 */
Dispatch.prototype.hide = function hide (path) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof path === 'string', 'path needs to be a string');

    var node = this._nodes[path];

    if (process.env.NODE_ENV === 'development')
        assert(node, 'No node registered at path ' + path);

    if (node.onHide) node.onHide();

    var components = node.getComponents();
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onHide)
            components[i].onHide();

    var queue = allocQueue();

    addChildrenToQueue(node, queue);
    var child;

    while ((child = breadthFirstNext(queue)))
        this.hide(child.getLocation());

    node._setShown(false);
    deallocQueue(queue);

    return node;
};

/**
 * lookupNode takes a path and returns the node at the location specified
 * by the path, if one exists. If not, it returns undefined.
 *
 * @param {String} location The location of the node specified by its path
 *
 * @return {Node | undefined} The node at the requested path
 */
Dispatch.prototype.lookupNode = function lookupNode (location) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof location === 'string', 'location needs to be a string');

    var path = allocQueue();

    _splitTo(location, path);

    for (var i = 0, len = path.length ; i < len ; i++)
        path[i] = this._nodes[path[i]];

    path.length = 0;
    deallocQueue(path);

    return path[path.length - 1];
};

/**
 * dispatch takes an event name and a payload and dispatches it to the
 * entire scene graph below the node that the dispatcher is on. The nodes
 * receive the events in a breadth first traversal, meaning that parents
 * have the opportunity to react to the event before children.
 *
 * @param {String} path path of the node to send the event to
 * @param {String} event name of the event
 * @param {Any} payload data associated with the event
 *
 * @return {undefined} undefined
 */
Dispatch.prototype.dispatch = function dispatch (path, event, payload) {
    if (process.env.NODE_ENV === 'development') {
        assert(typeof path === 'string', 'path needs to be a string');
        assert(typeof event === 'string', 'event needs to be a string');
        assert(typeof payload === 'object', 'payload needs to be a object');
    }

    var node = this._nodes[path];

    if (!node) return;

    payload.node = node;

    var queue = allocQueue();
    queue.push(node);

    var child;
    var components;
    var i;
    var len;

    while ((child = breadthFirstNext(queue))) {
        if (child && child.onReceive)
            child.onReceive(event, payload);

        components = child.getComponents();

        for (i = 0, len = components.length ; i < len ; i++)
            if (components[i] && components[i].onReceive)
                components[i].onReceive(event, payload);
    }

    deallocQueue(queue);
};

/**
 * dispatchUIevent takes a path, an event name, and a payload and dispatches them in
 * a manner anologous to DOM bubbling. It first traverses down to the node specified at
 * the path. That node receives the event first, and then every ancestor receives the event
 * until the context.
 *
 * @param {String} path the path of the node
 * @param {String} event the event name
 * @param {Object} payload the payload
 *
 * @return {undefined} undefined
 */
Dispatch.prototype.dispatchUIEvent = function dispatchUIEvent (path, event, payload) {
    if (process.env.NODE_ENV === 'development') {
        assert(typeof path === 'string', 'path needs to be a string');
        assert(typeof event === 'string', 'event needs to be a string');
        assert(typeof payload === 'object', 'payload needs to be a object');
    }

    var node = this._nodes[path];
    Event.call(payload);

    if (process.env.NODE_ENV === 'development')
        assert(node, 'No node registered at path ' + path);

    var parent;
    var components;
    var i;
    var len;

    payload.node = node;

    while (node) {
        if (node.onReceive) node.onReceive(event, payload);
        components = node.getComponents();

        for (i = 0, len = components.length ; i < len ; i++)
            if (components[i] && components[i].onReceive)
                components[i].onReceive(event, payload);

        if (payload.propagationStopped) break;
        parent = node.getParent();
        if (parent === node) break;
        node = parent;
    }
};

var queues = [];

/**
 * Helper method used for allocating a new queue or reusing a previously freed
 * one if possible.
 *
 * @private
 *
 * @return {Array} allocated queue.
 */
function allocQueue () {
    return queues.pop() || [];
}

/**
 * Helper method used for freeing a previously allocated queue.
 *
 * @private
 *
 * @param  {Array} queue    the queue to be relased to the pool.
 * @return {undefined}      undefined
 */
function deallocQueue(queue) {
    queues.push(queue);
}

/**
 * _splitTo is a private method which takes a path and splits it at every '/'
 * pushing the result into the supplied array. This is a destructive change.
 *
 * @private
 * @param {String} string the specified path
 * @param {Array} target the array to which the result should be written
 *
 * @return {Array} the target after having been written to
 */
function _splitTo (string, target) {
    target.length = 0; // clears the array first.
    var last = 0;
    var i;
    var len = string.length;

    for (i = 0 ; i < len ; i++) {
        if (string[i] === '/') {
            target.push(string.substring(last, i));
            last = i + 1;
        }
    }

    if (i - last > 0) target.push(string.substring(last, i));

    return target;
}

/**
 * Enque the children of a node within the dispatcher. Does not clear
 * the dispatchers queue first.
 *
 * @method addChildrenToQueue
 *
 * @param {Node} node from which to add children to the queue
 * @param {Array} queue the queue used for retrieving the new child from
 *
 * @return {void}
 */
function addChildrenToQueue (node, queue) {
    var children = node.getChildren();
    var child;
    for (var i = 0, len = children.length ; i < len ; i++) {
        child = children[i];
        if (child) queue.push(child);
    }
}

/**
 * Returns the next node in the queue, but also adds its children to
 * the end of the queue. Continually calling this method will result
 * in a breadth first traversal of the render tree.
 *
 * @method breadthFirstNext
 * @param {Array} queue the queue used for retrieving the new child from
 * @return {Node | undefined} the next node in the traversal if one exists
 */
function breadthFirstNext (queue) {
    var child = queue.shift();
    if (!child) return void 0;
    addChildrenToQueue(child, queue);
    return child;
}


module.exports = new Dispatch();

}).call(this,require('_process'))

},{"../utilities/assert":70,"./Event":34,"./Path":39,"_process":1}],34:[function(require,module,exports){
/**
 * The MIT License (MIT)
 * 
 * Copyright (c) 2015 Famous Industries Inc.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * The Event class adds the stopPropagation functionality
 * to the UIEvents within the scene graph.
 *
 * @constructor Event
 */
function Event () {
    this.propagationStopped = false;
    this.stopPropagation = stopPropagation;
}

/**
 * stopPropagation ends the bubbling of the event in the
 * scene graph.
 *
 * @method stopPropagation
 *
 * @return {undefined} undefined
 */
function stopPropagation () {
    this.propagationStopped = true;
}

module.exports = Event;


},{}],35:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Clock = require('./Clock');
var Scene = require('./Scene');
var Node = require('./Node');
var Channel = require('./Channel');
var Dispatch = require('./Dispatch');
var UIManager = require('../renderers/UIManager');
var Compositor = require('../renderers/Compositor');
var RequestAnimationFrameLoop = require('../render-loops/RequestAnimationFrameLoop');
var TransformSystem = require('./TransformSystem');
var OpacitySystem = require('./OpacitySystem');
var SizeSystem = require('./SizeSystem');
var Commands = require('./Commands');

var ENGINE_START = [Commands.ENGINE, Commands.START];
var ENGINE_STOP = [Commands.ENGINE, Commands.STOP];
var TIME_UPDATE = [Commands.TIME, null];

/**
 * Famous has two responsibilities, one to act as the highest level
 * updater and another to send messages over to the renderers. It is
 * a singleton.
 *
 * @class FamousEngine
 * @constructor
 */
function FamousEngine() {
    var _this = this;

    Dispatch._setUpdater(this);

    this._updateQueue = []; // The updateQueue is a place where nodes
                            // can place themselves in order to be
                            // updated on the frame.

    this._nextUpdateQueue = []; // the nextUpdateQueue is used to queue
                                // updates for the next tick.
                                // this prevents infinite loops where during
                                // an update a node continuously puts itself
                                // back in the update queue.

    this._scenes = {}; // a hash of all of the scenes's that the FamousEngine
                         // is responsible for.

    this._messages = TIME_UPDATE;   // a queue of all of the draw commands to
                                    // send to the the renderers this frame.

    this._inUpdate = false; // when the famous is updating this is true.
                            // all requests for updates will get put in the
                            // nextUpdateQueue

    this._clock = new Clock(); // a clock to keep track of time for the scene
                               // graph.


    this._channel = new Channel();
    this._channel.onMessage = function (message) {
        _this.handleMessage(message);
    };
}


/**
 * An init script that initializes the FamousEngine with options
 * or default parameters.
 *
 * @method
 *
 * @param {Object} options a set of options containing a compositor and a render loop
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.init = function init(options) {
    if (typeof window === 'undefined') {
        throw new Error(
            'FamousEngine#init needs to have access to the global window object. ' +
            'Instantiate Compositor and UIManager manually in the UI thread.'
        );
    }
    this.compositor = options && options.compositor || new Compositor();
    this.renderLoop = options && options.renderLoop || new RequestAnimationFrameLoop();
    this.uiManager = new UIManager(this.getChannel(), this.compositor, this.renderLoop);
    return this;
};

/**
 * Sets the channel that the engine will use to communicate to
 * the renderers.
 *
 * @method
 *
 * @param {Channel} channel     The channel to be used for communicating with
 *                              the `UIManager`/ `Compositor`.
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.setChannel = function setChannel(channel) {
    this._channel = channel;
    return this;
};

/**
 * Returns the channel that the engine is currently using
 * to communicate with the renderers.
 *
 * @method
 *
 * @return {Channel} channel    The channel to be used for communicating with
 *                              the `UIManager`/ `Compositor`.
 */
FamousEngine.prototype.getChannel = function getChannel () {
    return this._channel;
};

/**
 * _update is the body of the update loop. The frame consists of
 * pulling in appending the nextUpdateQueue to the currentUpdate queue
 * then moving through the updateQueue and calling onUpdate with the current
 * time on all nodes. While _update is called _inUpdate is set to true and
 * all requests to be placed in the update queue will be forwarded to the
 * nextUpdateQueue.
 *
 * @method
 *
 * @return {undefined} undefined
 */
FamousEngine.prototype._update = function _update () {
    this._inUpdate = true;
    var time = this._clock.now();
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    this._messages[1] = time;

    SizeSystem.update();
    TransformSystem.update();
    OpacitySystem.update();

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = queue.shift();
        if (item && item.update) item.update(time);
        if (item && item.onUpdate) item.onUpdate(time);
    }

    this._inUpdate = false;
};

/**
 * requestUpdates takes a class that has an onUpdate method and puts it
 * into the updateQueue to be updated at the next frame.
 * If FamousEngine is currently in an update, requestUpdate
 * passes its argument to requestUpdateOnNextTick.
 *
 * @method
 *
 * @param {Object} requester an object with an onUpdate method
 *
 * @return {undefined} undefined
 */
FamousEngine.prototype.requestUpdate = function requestUpdate (requester) {
    if (!requester)
        throw new Error(
            'requestUpdate must be called with a class to be updated'
        );

    if (this._inUpdate) this.requestUpdateOnNextTick(requester);
    else this._updateQueue.push(requester);
};

/**
 * requestUpdateOnNextTick is requests an update on the next frame.
 * If FamousEngine is not currently in an update than it is functionally equivalent
 * to requestUpdate. This method should be used to prevent infinite loops where
 * a class is updated on the frame but needs to be updated again next frame.
 *
 * @method
 *
 * @param {Object} requester an object with an onUpdate method
 *
 * @return {undefined} undefined
 */
FamousEngine.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (requester) {
    this._nextUpdateQueue.push(requester);
};

/**
 * postMessage sends a message queue into FamousEngine to be processed.
 * These messages will be interpreted and sent into the scene graph
 * as events if necessary.
 *
 * @method
 *
 * @param {Array} messages an array of commands.
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.handleMessage = function handleMessage (messages) {
    if (!messages)
        throw new Error(
            'onMessage must be called with an array of messages'
        );

    var command;

    while (messages.length > 0) {
        command = messages.shift();
        switch (command) {
            case Commands.WITH:
                this.handleWith(messages);
                break;
            case Commands.FRAME:
                this.handleFrame(messages);
                break;
            default:
                throw new Error('received unknown command: ' + command);
        }
    }
    return this;
};

/**
 * handleWith is a method that takes an array of messages following the
 * WITH command. It'll then issue the next commands to the path specified
 * by the WITH command.
 *
 * @method
 *
 * @param {Array} messages array of messages.
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.handleWith = function handleWith (messages) {
    var path = messages.shift();
    var command = messages.shift();
    switch (command) {
        case Commands.TRIGGER: // the TRIGGER command sends a UIEvent to the specified path
            var type = messages.shift();
            var ev = messages.shift();
            Dispatch.dispatchUIEvent(path, type, ev);
            break;
        default:
            throw new Error('received unknown command: ' + command);
    }
    return this;
};

/**
 * handleFrame is called when the renderers issue a FRAME command to
 * FamousEngine. FamousEngine will then step updating the scene graph to the current time.
 *
 * @method
 *
 * @param {Array} messages array of messages.
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.handleFrame = function handleFrame (messages) {
    if (!messages) throw new Error('handleFrame must be called with an array of messages');
    if (!messages.length) throw new Error('FRAME must be sent with a time');

    this.step(messages.shift());
    return this;
};

/**
 * step updates the clock and the scene graph and then sends the draw commands
 * that accumulated in the update to the renderers.
 *
 * @method
 *
 * @param {Number} time current engine time
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.step = function step (time) {
    if (time == null) throw new Error('step must be called with a time');

    this._clock.step(time);
    this._update();

    if (this._messages.length) {
        this._channel.sendMessage(this._messages);
        while (this._messages.length > 2) this._messages.pop();
    }

    return this;
};

/**
 * returns the context of a particular path. The context is looked up by the selector
 * portion of the path and is listed from the start of the string to the first
 * '/'.
 *
 * @method
 *
 * @param {String} selector the path to look up the context for.
 *
 * @return {Context | Undefined} the context if found, else undefined.
 */
FamousEngine.prototype.getContext = function getContext (selector) {
    if (!selector) throw new Error('getContext must be called with a selector');

    var index = selector.indexOf('/');
    selector = index === -1 ? selector : selector.substring(0, index);

    return this._scenes[selector];
};

/**
 * Returns the instance of clock used by the FamousEngine.
 *
 * @method
 *
 * @return {Clock} FamousEngine's clock
 */
FamousEngine.prototype.getClock = function getClock () {
    return this._clock;
};

/**
 * Enqueues a message to be transfered to the renderers.
 *
 * @method
 *
 * @param {Any} command Draw Command
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.message = function message (command) {
    this._messages.push(command);
    return this;
};

/**
 * Creates a new detached Node that can be added to the scene graph.
 *
 * @return {Node}               A new instance of Node.
 */
FamousEngine.prototype.createNode = function createNode () {
    return new Node();
};

/**
 * Creates a scene under which a scene graph could be built.
 *
 * @method
 *
 * @param {String} selector a dom selector for where the scene should be placed
 *
 * @return {Scene} a new instance of Scene.
 */
FamousEngine.prototype.createScene = function createScene (selector) {
    selector = selector || 'body';
    if (this._scenes[selector]) this.removeScene(this._scenes[selector]);

    var scene = new Scene();
    this.addScene(selector, scene);
    return scene;
};

/**
 * Introduce an already instantiated scene to the engine.
 *
 * @method
 *
 * @param {String} selector a dom selector for where the scene should be placed
 * @param {Scene} scene the scene to reintroduce to the engine
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.addScene = function addScene (selector, scene) {
    selector = selector || 'body';
    this.removeScene(scene);
    if (this._scenes[selector]) this.removeScene(this._scenes[selector]);

    this._scenes[selector] = scene;
    scene.mount(selector);

    return this;
};

/**
 * Remove a scene.
 *
 * @method
 *
 * @param {Scene} scene the scene to remove from the engine
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.removeScene = function removeScene (scene) {
    var selector = scene._id;

    var current = this._scenes[selector];
    if (current && current === scene) {
        scene.dismount();
        delete this._scenes[selector];
        this._messages.push(Commands.WITH, selector, Commands.REMOVE_SCENE);
    }
    return this;
};

/**
 * Starts the engine running in the Main-Thread.
 * This effects **every** updateable managed by the Engine.
 *
 * @method
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.startRenderLoop = function startRenderLoop() {
    this._channel.sendMessage(ENGINE_START);
    return this;
};

/**
 * Stops the engine running in the Main-Thread.
 * This effects **every** updateable managed by the Engine.
 *
 * @method
 *
 * @return {FamousEngine} this
 */
FamousEngine.prototype.stopRenderLoop = function stopRenderLoop() {
    this._channel.sendMessage(ENGINE_STOP);
    return this;
};

module.exports = new FamousEngine();

},{"../render-loops/RequestAnimationFrameLoop":62,"../renderers/Compositor":63,"../renderers/UIManager":65,"./Channel":30,"./Clock":31,"./Commands":32,"./Dispatch":33,"./Node":36,"./OpacitySystem":38,"./Scene":40,"./SizeSystem":42,"./TransformSystem":45}],36:[function(require,module,exports){
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W079 */

'use strict';

var SizeSystem = require('./SizeSystem');
var Dispatch = require('./Dispatch');
var TransformSystem = require('./TransformSystem');
var OpacitySystem = require('./OpacitySystem');
var Size = require('./Size');
var Opacity = require('./Opacity');
var Transform = require('./Transform');

/**
 * Nodes define hierarchy and geometrical transformations. They can be moved
 * (translated), scaled and rotated.
 *
 * A Node is either mounted or unmounted. Unmounted nodes are detached from the
 * scene graph. Unmounted nodes have no parent node, while each mounted node has
 * exactly one parent. Nodes have an arbitrary number of children, which can be
 * dynamically added using {@link Node#addChild}.
 *
 * Each Node has an arbitrary number of `components`. Those components can
 * send `draw` commands to the renderer or mutate the node itself, in which case
 * they define behavior in the most explicit way. Components that send `draw`
 * commands are considered `renderables`. From the node's perspective, there is
 * no distinction between nodes that send draw commands and nodes that define
 * behavior.
 *
 * Because of the fact that Nodes themself are very unopinioted (they don't
 * "render" to anything), they are often being subclassed in order to add e.g.
 * components at initialization to them. Because of this flexibility, they might
 * as well have been called `Entities`.
 *
 * @example
 * // create three detached (unmounted) nodes
 * var parent = new Node();
 * var child1 = new Node();
 * var child2 = new Node();
 *
 * // build an unmounted subtree (parent is still detached)
 * parent.addChild(child1);
 * parent.addChild(child2);
 *
 * // mount parent by adding it to the context
 * var context = Famous.createContext("body");
 * context.addChild(parent);
 *
 * @class Node
 * @constructor
 */
function Node (options) {
    this._requestingUpdate = false;
    this._inUpdate = false;
    this._mounted = false;
    this._shown = true;
    this._updater = null;
    this._UIEvents = [];

    this._updateQueue = [];
    this._nextUpdateQueue = [];

    this._freedComponentIndicies = [];
    this._components = [];

    this._freedChildIndicies = [];
    this._children = [];

    this._fullChildren = [];

    this._parent = null;

    this._id = null;

    this._transformID = null;
    this._sizeID = null;
    this._opacityID = null;

    if (!this.constructor.NO_DEFAULT_COMPONENTS) this._init();

    if (options) this._handleOptions(options);
}

Node.RELATIVE_SIZE = 0;
Node.ABSOLUTE_SIZE = 1;
Node.RENDER_SIZE = 2;
Node.DEFAULT_SIZE = 0;
Node.NO_DEFAULT_COMPONENTS = false;

/**
 * Protected method. Initializes a node with a default Transform and Size component
 *
 * @method
 * @protected
 *
 * @return {undefined} undefined
 */
Node.prototype._init = function _init () {
    this._transformID = this.addComponent(new Transform());
    this._sizeID = this.addComponent(new Size());
    this._opacityID = this.addComponent(new Opacity());
};

Node.prototype._handleOptions = function _handleOptions (options) {
    if (options.position) this.setPosition.apply(this, options.position);
    if (options.rotation) this.setRotation.apply(this, options.rotation);
    if (options.scale) this.setScale.apply(this, options.scale);

    if (options.origin) this.setOrigin.apply(this, options.origin);
    if (options.mountPoint) this.setMountPoint.apply(this, options.mountPoint);
    if (options.align) this.setAlign.apply(this, options.align);

    if (options.opacity != null) this.setOpacity(options.opacity);

    if (options.sizeMode) this.setSizeMode.apply(this, options.sizeMode);
    if (options.absoluteSize) this.setAbsoluteSize.apply(this, options.absoluteSize);
    if (options.differentialSize) this.setDifferentialSize.apply(this, options.differentialSize);
    if (options.proportionalSize) this.setProportionalSize.apply(this, options.proportionalSize);
};

/**
 * Returns the used udpater.
 *
 * @return {Famous} the updater for this Node.
 */
Node.prototype.getUpdater = function getUpdater () {
    return this._updater;
};

/**
 * Protected method. Sets the parent of this node such that it can be looked up.
 *
 * @method
 *
 * @param {Node} parent The node to set as the parent of this
 *
 * @return {undefined} undefined;
 */
Node.prototype._setParent = function _setParent (parent) {
    if (this._parent && this._parent.getChildren().indexOf(this) !== -1) {
        this._parent.removeChild(this);
    }
    this._parent = parent;
};

/**
 * Protected method. Sets the mount state of the node. Should only be called
 * by the dispatch
 *
 * @method
 *
 * @param {Boolean} mounted whether or not the Node is mounted.
 * @param {String} path The path that the node will be mounted to
 *
 * @return {undefined} undefined
 */
Node.prototype._setMounted = function _setMounted (mounted, path) {
    this._mounted = mounted;
    this._id = path ? path : null;
};

/**
 * Protected method, sets whether or not the Node is shown. Should only
 * be called by the dispatch
 *
 * @method
 *
 * @param {Boolean} shown whether or not the node is shown
 *
 * @return {undefined} undefined
 */
Node.prototype._setShown = function _setShown (shown) {
    this._shown = shown;
};

/**
 * Protected method. Sets the updater of the node.
 *
 * @method
 *
 * @param {FamousEngine} updater the Updater of the node.
 *
 * @return {undefined} undefined
 */
Node.prototype._setUpdater = function _setUpdater (updater) {
    this._updater = updater;
    if (this._requestingUpdate) this._updater.requestUpdate(this);
};

/**
 * Determine the node's location in the scene graph hierarchy.
 * A location of `body/0/1` can be interpreted as the following scene graph
 * hierarchy (ignoring siblings of ancestors and additional child nodes):
 *
 * `Context:body` -> `Node:0` -> `Node:1`, where `Node:1` is the node the
 * `getLocation` method has been invoked on.
 *
 * @method getLocation
 *
 * @return {String} location (path), e.g. `body/0/1`
 */
Node.prototype.getLocation = function getLocation () {
    return this._id;
};

/**
 * @alias getId
 *
 * @return {String} the path of the Node
 */
Node.prototype.getId = Node.prototype.getLocation;

/**
 * Dispatches the event using the Dispatch. All descendent nodes will
 * receive the dispatched event.
 *
 * @method emit
 *
 * @param  {String} event   Event type.
 * @param  {Object} payload Event object to be dispatched.
 *
 * @return {Node} this
 */
Node.prototype.emit = function emit (event, payload) {
    Dispatch.dispatch(this.getLocation(), event, payload);
    return this;
};

// THIS WILL BE DEPRECATED
Node.prototype.sendDrawCommand = function sendDrawCommand (message) {
    this._updater.message(message);
    return this;
};

/**
 * Recursively serializes the Node, including all previously added components.
 *
 * @method getValue
 *
 * @return {Object}     Serialized representation of the node, including
 *                      components.
 */
Node.prototype.getValue = function getValue () {
    var numberOfChildren = this._children.length;
    var numberOfComponents = this._components.length;
    var i = 0;

    var value = {
        location: this.getId(),
        spec: {
            location: this.getId(),
            showState: {
                mounted: this.isMounted(),
                shown: this.isShown(),
                opacity: 1
            },
            offsets: {
                mountPoint: [0, 0, 0],
                align: [0, 0, 0],
                origin: [0, 0, 0]
            },
            vectors: {
                position: [0, 0, 0],
                rotation: [0, 0, 0, 1],
                scale: [1, 1, 1]
            },
            size: {
                sizeMode: [0, 0, 0],
                proportional: [1, 1, 1],
                differential: [0, 0, 0],
                absolute: [0, 0, 0],
                render: [0, 0, 0]
            }
        },
        UIEvents: this._UIEvents,
        components: [],
        children: []
    };

    if (value.location) {
        var transform = TransformSystem.get(this.getId());
        var size = SizeSystem.get(this.getId());
        var opacity = OpacitySystem.get(this.getId());

        value.spec.showState.opacity = opacity.getOpacity();

        for (i = 0 ; i < 3 ; i++) {
            value.spec.offsets.mountPoint[i] = transform.offsets.mountPoint[i];
            value.spec.offsets.align[i] = transform.offsets.align[i];
            value.spec.offsets.origin[i] = transform.offsets.origin[i];
            value.spec.vectors.position[i] = transform.vectors.position[i];
            value.spec.vectors.rotation[i] = transform.vectors.rotation[i];
            value.spec.vectors.scale[i] = transform.vectors.scale[i];
            value.spec.size.sizeMode[i] = size.sizeMode[i];
            value.spec.size.proportional[i] = size.proportionalSize[i];
            value.spec.size.differential[i] = size.differentialSize[i];
            value.spec.size.absolute[i] = size.absoluteSize[i];
            value.spec.size.render[i] = size.renderSize[i];
        }

        value.spec.vectors.rotation[3] = transform.vectors.rotation[3];
    }

    for (i = 0; i < numberOfChildren ; i++)
        if (this._children[i] && this._children[i].getValue)
            value.children.push(this._children[i].getValue());

    for (i = 0 ; i < numberOfComponents ; i++)
        if (this._components[i] && this._components[i].getValue)
            value.components.push(this._components[i].getValue());

    return value;
};

/**
 * Similar to {@link Node#getValue}, but returns the actual "computed" value. E.g.
 * a proportional size of 0.5 might resolve into a "computed" size of 200px
 * (assuming the parent has a width of 400px).
 *
 * @method getComputedValue
 *
 * @return {Object}     Serialized representation of the node, including
 *                      children, excluding components.
 */
Node.prototype.getComputedValue = function getComputedValue () {
    console.warn('Node.getComputedValue is depricated. Use Node.getValue instead');
    var numberOfChildren = this._children.length;

    var value = {
        location: this.getId(),
        computedValues: {
            transform: this.isMounted() ? TransformSystem.get(this.getLocation()).getLocalTransform() : null,
            size: this.isMounted() ? SizeSystem.get(this.getLocation()).get() : null,
            opacity: this.isMounted() ? OpacitySystem.get(this.getLocation()).get() : null
        },
        children: []
    };

    for (var i = 0 ; i < numberOfChildren ; i++)
        if (this._children[i] && this._children[i].getComputedValue)
            value.children.push(this._children[i].getComputedValue());

    return value;
};

/**
 * Retrieves all children of the current node.
 *
 * @method getChildren
 *
 * @return {Array.<Node>}   An array of children.
 */
Node.prototype.getChildren = function getChildren () {
    return this._fullChildren;
};

/**
 * Method used internally to retrieve the children of a node. Each index in the
 * returned array represents a path fragment.
 *
 * @method getRawChildren
 * @private
 *
 * @return {Array}  An array of children. Might contain `null` elements.
 */
Node.prototype.getRawChildren = function getRawChildren() {
    return this._children;
};

/**
 * Retrieves the parent of the current node. Unmounted nodes do not have a
 * parent node.
 *
 * @method getParent
 *
 * @return {Node}       Parent node.
 */
Node.prototype.getParent = function getParent () {
    return this._parent;
};

/**
 * Schedules the {@link Node#update} function of the node to be invoked on the
 * next frame (if no update during this frame has been scheduled already).
 * If the node is currently being updated (which means one of the requesters
 * invoked requestsUpdate while being updated itself), an update will be
 * scheduled on the next frame by falling back to the `requestUpdateOnNextTick`
 * function.
 *
 * Components request their `onUpdate` method to be called during the next
 * frame using this method.
 *
 * @method requestUpdate
 *
 * @param  {Number} requester   Id of the component (as returned by
 *                              {@link Node#addComponent}) to be updated. The
 *                              component's `onUpdate` method will be invoked
 *                              during the next update cycle.
 *
 * @return {Node} this
 */
Node.prototype.requestUpdate = function requestUpdate (requester) {
    if (this._inUpdate || !this.isMounted())
        return this.requestUpdateOnNextTick(requester);
    if (this._updateQueue.indexOf(requester) === -1) {
        this._updateQueue.push(requester);
        if (!this._requestingUpdate) this._requestUpdate();
    }
    return this;
};

/**
 * Schedules an update on the next tick.
 *
 * This method is similar to {@link Node#requestUpdate}, but schedules an
 * update on the **next** frame. It schedules the node's `onUpdate` function
 * to be invoked on the frame after the next invocation on
 * the node's onUpdate function.
 *
 * The primary use-case for this method is to request an update while being in
 * an update phase (e.g. because an animation is still active). Most of the
 * time, {@link Node#requestUpdate} is sufficient, since it automatically
 * falls back to {@link Node#requestUpdateOnNextTick} when being invoked during
 * the update phase.
 *
 * @method requestUpdateOnNextTick
 *
 * @param  {Number} requester   Id of the component (as returned by
 *                              {@link Node#addComponent}) to be updated. The
 *                              component's `onUpdate` method will be invoked
 *                              during the next update cycle.
 *
 * @return {Node} this
 */
Node.prototype.requestUpdateOnNextTick = function requestUpdateOnNextTick (requester) {
    if (this._nextUpdateQueue.indexOf(requester) === -1)
        this._nextUpdateQueue.push(requester);
    return this;
};

/**
 * Checks if the node is mounted. Unmounted nodes are detached from the scene
 * graph.
 *
 * @method isMounted
 *
 * @return {Boolean}    Boolean indicating whether the node is mounted or not.
 */
Node.prototype.isMounted = function isMounted () {
    return this._mounted;
};

/**
 * Checks if the node is being rendered. A node is being rendererd when it is
 * mounted to a parent node **and** shown.
 *
 * @method isRendered
 *
 * @return {Boolean}    Boolean indicating whether the node is rendered or not.
 */
Node.prototype.isRendered = function isRendered () {
    return this._mounted && this._shown;
};

/**
 * Checks if the node is visible ("shown").
 *
 * @method isShown
 *
 * @return {Boolean}    Boolean indicating whether the node is visible
 *                      ("shown") or not.
 */
Node.prototype.isShown = function isShown () {
    return this._shown;
};

/**
 * Determines the node's relative opacity.
 * The opacity needs to be within [0, 1], where 0 indicates a completely
 * transparent, therefore invisible node, whereas an opacity of 1 means the
 * node is completely solid.
 *
 * @method getOpacity
 *
 * @return {Number}         Relative opacity of the node.
 */
Node.prototype.getOpacity = function getOpacity () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._opacityID).getOpacity();
    else if (this.isMounted())
        return OpacitySystem.get(this.getLocation()).getOpacity();
    else throw new Error('This node does not have access to an opacity component');
};

/**
 * Determines the node's previously set mount point.
 *
 * @method getMountPoint
 *
 * @return {Float32Array}   An array representing the mount point.
 */
Node.prototype.getMountPoint = function getMountPoint () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getMountPoint();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getMountPoint();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Determines the node's previously set align.
 *
 * @method getAlign
 *
 * @return {Float32Array}   An array representing the align.
 */
Node.prototype.getAlign = function getAlign () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getAlign();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getAlign();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Determines the node's previously set origin.
 *
 * @method getOrigin
 *
 * @return {Float32Array}   An array representing the origin.
 */
Node.prototype.getOrigin = function getOrigin () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getOrigin();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getOrigin();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Determines the node's previously set position.
 *
 * @method getPosition
 *
 * @return {Float32Array}   An array representing the position.
 */
Node.prototype.getPosition = function getPosition () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getPosition();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getPosition();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Returns the node's current rotation
 *
 * @method getRotation
 *
 * @return {Float32Array} an array of four values, showing the rotation as a quaternion
 */
Node.prototype.getRotation = function getRotation () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getRotation();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getRotation();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Returns the scale of the node
 *
 * @method
 *
 * @return {Float32Array} an array showing the current scale vector
 */
Node.prototype.getScale = function getScale () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._transformID).getScale();
    else if (this.isMounted())
        return TransformSystem.get(this.getLocation()).getScale();
    else throw new Error('This node does not have access to a transform component');
};

/**
 * Returns the current size mode of the node
 *
 * @method
 *
 * @return {Float32Array} an array of numbers showing the current size mode
 */
Node.prototype.getSizeMode = function getSizeMode () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).getSizeMode();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).getSizeMode();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the current proportional size
 *
 * @method
 *
 * @return {Float32Array} a vector 3 showing the current proportional size
 */
Node.prototype.getProportionalSize = function getProportionalSize () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).getProportional();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).getProportional();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the differential size of the node
 *
 * @method
 *
 * @return {Float32Array} a vector 3 showing the current differential size
 */
Node.prototype.getDifferentialSize = function getDifferentialSize () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).getDifferential();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).getDifferential();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the absolute size of the node
 *
 * @method
 *
 * @return {Float32Array} a vector 3 showing the current absolute size of the node
 */
Node.prototype.getAbsoluteSize = function getAbsoluteSize () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).getAbsolute();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).getAbsolute();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the current Render Size of the node. Note that the render size
 * is asynchronous (will always be one frame behind) and needs to be explicitely
 * calculated by setting the proper size mode.
 *
 * @method
 *
 * @return {Float32Array} a vector 3 showing the current render size
 */
Node.prototype.getRenderSize = function getRenderSize () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).getRender();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).getRender();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the external size of the node
 *
 * @method
 *
 * @return {Float32Array} a vector 3 of the final calculated side of the node
 */
Node.prototype.getSize = function getSize () {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        return this.getComponent(this._sizeID).get();
    else if (this.isMounted())
        return SizeSystem.get(this.getLocation()).get();
    else throw new Error('This node does not have access to a size component');
};

/**
 * Returns the current world transform of the node
 *
 * @method
 *
 * @return {Float32Array} a 16 value transform
 */
Node.prototype.getTransform = function getTransform () {
    return TransformSystem.get(this.getLocation());
};

/**
 * Get the list of the UI Events that are currently associated with this node
 *
 * @method
 *
 * @return {Array} an array of strings representing the current subscribed UI event of this node
 */
Node.prototype.getUIEvents = function getUIEvents () {
    return this._UIEvents;
};

/**
 * Adds a new child to this node. If this method is called with no argument it will
 * create a new node, however it can also be called with an existing node which it will
 * append to the node that this method is being called on. Returns the new or passed in node.
 *
 * @method
 *
 * @param {Node | void} child the node to appended or no node to create a new node.
 *
 * @return {Node} the appended node.
 */
Node.prototype.addChild = function addChild (child) {
    var index = child ? this._children.indexOf(child) : -1;
    child = child ? child : new Node();

    if (index === -1) {
        index = this._freedChildIndicies.length ?
                this._freedChildIndicies.pop() : this._children.length;

        this._children[index] = child;
        this._fullChildren.push(child);
    }

    if (this.isMounted())
        child.mount(this.getLocation() + '/' + index);

    return child;
};

/**
 * Removes a child node from another node. The passed in node must be
 * a child of the node that this method is called upon.
 *
 * @method
 *
 * @param {Node} child node to be removed
 *
 * @return {Boolean} whether or not the node was successfully removed
 */
Node.prototype.removeChild = function removeChild (child) {
    var index = this._children.indexOf(child);

    if (index > - 1) {
        this._freedChildIndicies.push(index);

        this._children[index] = null;

        if (child.isMounted()) child.dismount();

        var fullChildrenIndex = this._fullChildren.indexOf(child);
        var len = this._fullChildren.length;
        var i = 0;

        for (i = fullChildrenIndex; i < len-1; i++)
            this._fullChildren[i] = this._fullChildren[i + 1];

        this._fullChildren.pop();

        return true;
    }
    else {
        return false;
    }
};

/**
 * Removes all children nodes.
 *
 * @method
 *
 * @return {Boolean} whether or not the nodes were successfully removed
 */
Node.prototype.removeAllChildren = function removeAllChildren () {
    var check = true;
    var children = this.getChildren();
    var len = children.length;

    for (var i = 0; i < len; i++) {
        check = check && this.removeChild(children[0]);
    }

    return check;
};

/**
 * Each component can only be added once per node.
 *
 * @method addComponent
 *
 * @param {Object} component    A component to be added.
 * @return {Number} index       The index at which the component has been
 *                              registered. Indices aren't necessarily
 *                              consecutive.
 */
Node.prototype.addComponent = function addComponent (component) {
    var index = this._components.indexOf(component);
    if (index === -1) {
        index = this._freedComponentIndicies.length ? this._freedComponentIndicies.pop() : this._components.length;
        this._components[index] = component;

        if (this.isMounted() && component.onMount)
            component.onMount(this, index);

        if (this.isShown() && component.onShow)
            component.onShow();
    }

    return index;
};

/**
 * @method  getComponent
 *
 * @param  {Number} index   Index at which the component has been registered
 *                          (using `Node#addComponent`).
 * @return {*}              The component registered at the passed in index (if
 *                          any).
 */
Node.prototype.getComponent = function getComponent (index) {
    return this._components[index];
};

/**
 * Removes a previously via {@link Node#addComponent} added component.
 *
 * @method removeComponent
 *
 * @param  {Object} component   An component that has previously been added
 *                              using {@link Node#addComponent}.
 *
 * @return {Node} this
 */
Node.prototype.removeComponent = function removeComponent (component) {
    var index = this._components.indexOf(component);
    if (index !== -1) {
        this._freedComponentIndicies.push(index);
        if (this.isShown() && component.onHide)
            component.onHide();

        if (this.isMounted() && component.onDismount)
            component.onDismount();

        this._components[index] = null;
    }
    return component;
};

/**
 * Removes a node's subscription to a particular UIEvent. All components
 * on the node will have the opportunity to remove all listeners depending
 * on this event.
 *
 * @method
 *
 * @param {String} eventName the name of the event
 *
 * @return {undefined} undefined
 */
Node.prototype.removeUIEvent = function removeUIEvent (eventName) {
    var UIEvents = this.getUIEvents();
    var components = this._components;
    var component;

    var index = UIEvents.indexOf(eventName);
    if (index !== -1) {
        UIEvents.splice(index, 1);
        for (var i = 0, len = components.length ; i < len ; i++) {
            component = components[i];
            if (component && component.onRemoveUIEvent) component.onRemoveUIEvent(eventName);
        }
    }
};

/**
 * Subscribes a node to a UI Event. All components on the node
 * will have the opportunity to begin listening to that event
 * and alerting the scene graph.
 *
 * @method
 *
 * @param {String} eventName the name of the event
 *
 * @return {Node} this
 */
Node.prototype.addUIEvent = function addUIEvent (eventName) {
    var UIEvents = this.getUIEvents();
    var components = this._components;
    var component;

    var added = UIEvents.indexOf(eventName) !== -1;
    if (!added) {
        UIEvents.push(eventName);
        for (var i = 0, len = components.length ; i < len ; i++) {
            component = components[i];
            if (component && component.onAddUIEvent) component.onAddUIEvent(eventName);
        }
    }

    return this;
};

/**
 * Private method for the Node to request an update for itself.
 *
 * @method
 * @private
 *
 * @param {Boolean} force whether or not to force the update
 *
 * @return {undefined} undefined
 */
Node.prototype._requestUpdate = function _requestUpdate (force) {
    if (force || !this._requestingUpdate) {
        if (this._updater)
            this._updater.requestUpdate(this);
        this._requestingUpdate = true;
    }
};

/**
 * Private method to set an optional value in an array, and
 * request an update if this changes the value of the array.
 *
 * @method
 *
 * @param {Array} vec the array to insert the value into
 * @param {Number} index the index at which to insert the value
 * @param {Any} val the value to potentially insert (if not null or undefined)
 *
 * @return {Boolean} whether or not a new value was inserted.
 */
Node.prototype._vecOptionalSet = function _vecOptionalSet (vec, index, val) {
    if (val != null && vec[index] !== val) {
        vec[index] = val;
        if (!this._requestingUpdate) this._requestUpdate();
        return true;
    }
    return false;
};

/**
 * Shows the node, which is to say, calls onShow on all of the
 * node's components. Renderable components can then issue the
 * draw commands necessary to be shown.
 *
 * @method
 *
 * @return {Node} this
 */
Node.prototype.show = function show () {
    return Dispatch.show(this._id);
};

/**
 * Hides the node, which is to say, calls onHide on all of the
 * node's components. Renderable components can then issue
 * the draw commands necessary to be hidden
 *
 * @method
 *
 * @return {Node} this
 */
Node.prototype.hide = function hide () {
    return Dispatch.hide(this._id);
};

/**
 * Sets the align value of the node. Will call onAlignChange
 * on all of the Node's components.
 *
 * @method
 *
 * @param {Number} x Align value in the x dimension.
 * @param {Number} y Align value in the y dimension.
 * @param {Number} z Align value in the z dimension.
 *
 * @return {Node} this
 */
Node.prototype.setAlign = function setAlign (x, y, z) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setAlign(x, y, z);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setAlign(x, y, z);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the mount point value of the node. Will call onMountPointChange
 * on all of the node's components.
 *
 * @method
 *
 * @param {Number} x MountPoint value in x dimension
 * @param {Number} y MountPoint value in y dimension
 * @param {Number} z MountPoint value in z dimension
 *
 * @return {Node} this
 */
Node.prototype.setMountPoint = function setMountPoint (x, y, z) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setMountPoint(x, y, z);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setMountPoint(x, y, z);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the origin value of the node. Will call onOriginChange
 * on all of the node's components.
 *
 * @method
 *
 * @param {Number} x Origin value in x dimension
 * @param {Number} y Origin value in y dimension
 * @param {Number} z Origin value in z dimension
 *
 * @return {Node} this
 */
Node.prototype.setOrigin = function setOrigin (x, y, z) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setOrigin(x, y, z);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setOrigin(x, y, z);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the position of the node. Will call onPositionChange
 * on all of the node's components.
 *
 * @method
 *
 * @param {Number} x Position in x
 * @param {Number} y Position in y
 * @param {Number} z Position in z
 *
 * @return {Node} this
 */
Node.prototype.setPosition = function setPosition (x, y, z) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setPosition(x, y, z);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setPosition(x, y, z);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the rotation of the node. Will call onRotationChange
 * on all of the node's components. This method takes either
 * Euler angles or a quaternion. If the fourth argument is undefined
 * Euler angles are assumed.
 *
 * @method
 *
 * @param {Number} x Either the rotation around the x axis or the magnitude in x of the axis of rotation.
 * @param {Number} y Either the rotation around the y axis or the magnitude in y of the axis of rotation.
 * @param {Number} z Either the rotation around the z axis or the magnitude in z of the axis of rotation.
 * @param {Number|undefined} w the amount of rotation around the axis of rotation, if a quaternion is specified.
 *
 * @return {Node} this
 */
Node.prototype.setRotation = function setRotation (x, y, z, w) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setRotation(x, y, z, w);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setRotation(x, y, z, w);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the scale of the node. The default value is 1 in all dimensions.
 * The node's components will have onScaleChanged called on them.
 *
 * @method
 *
 * @param {Number} x Scale value in x
 * @param {Number} y Scale value in y
 * @param {Number} z Scale value in z
 *
 * @return {Node} this
 */
Node.prototype.setScale = function setScale (x, y, z) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._transformID).setScale(x, y, z);
    else if (this.isMounted())
        TransformSystem.get(this.getLocation()).setScale(x, y, z);
    else throw new Error('This node does not have access to a transform component');
    return this;
};

/**
 * Sets the value of the opacity of this node. All of the node's
 * components will have onOpacityChange called on them.
 *
 * @method
 *
 * @param {Number} val=1 Value of the opacity. 1 is the default.
 *
 * @return {Node} this
 */
Node.prototype.setOpacity = function setOpacity (val) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._opacityID).setOpacity(val);
    else if (this.isMounted())
        OpacitySystem.get(this.getLocation()).setOpacity(val);
    else throw new Error('This node does not have access to an opacity component');
    return this;
};

/**
 * Sets the size mode being used for determining the node's final width, height
 * and depth.
 * Size modes are a way to define the way the node's size is being calculated.
 * Size modes are enums set on the {@link Size} constructor (and aliased on
 * the Node).
 *
 * @example
 * node.setSizeMode(Node.RELATIVE_SIZE, Node.ABSOLUTE_SIZE, Node.ABSOLUTE_SIZE);
 * // Instead of null, any proportional height or depth can be passed in, since
 * // it would be ignored in any case.
 * node.setProportionalSize(0.5, null, null);
 * node.setAbsoluteSize(null, 100, 200);
 *
 * @method setSizeMode
 *
 * @param {SizeMode} x    The size mode being used for determining the size in
 *                        x direction ("width").
 * @param {SizeMode} y    The size mode being used for determining the size in
 *                        y direction ("height").
 * @param {SizeMode} z    The size mode being used for determining the size in
 *                        z direction ("depth").
 *
 * @return {Node} this
 */
Node.prototype.setSizeMode = function setSizeMode (x, y, z) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._sizeID).setSizeMode(x, y, z);
    else if (this.isMounted())
        SizeSystem.get(this.getLocation()).setSizeMode(x, y, z);
    else throw new Error('This node does not have access to a size component');
    return this;
};

/**
 * A proportional size defines the node's dimensions relative to its parents
 * final size.
 * Proportional sizes need to be within the range of [0, 1].
 *
 * @method setProportionalSize
 *
 * @param {Number} x    x-Size in pixels ("width").
 * @param {Number} y    y-Size in pixels ("height").
 * @param {Number} z    z-Size in pixels ("depth").
 *
 * @return {Node} this
 */
Node.prototype.setProportionalSize = function setProportionalSize (x, y, z) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._sizeID).setProportional(x, y, z);
    else if (this.isMounted())
        SizeSystem.get(this.getLocation()).setProportional(x, y, z);
    else throw new Error('This node does not have access to a size component');
    return this;
};

/**
 * Differential sizing can be used to add or subtract an absolute size from an
 * otherwise proportionally sized node.
 * E.g. a differential width of `-10` and a proportional width of `0.5` is
 * being interpreted as setting the node's size to 50% of its parent's width
 * *minus* 10 pixels.
 *
 * @method setDifferentialSize
 *
 * @param {Number} x    x-Size to be added to the relatively sized node in
 *                      pixels ("width").
 * @param {Number} y    y-Size to be added to the relatively sized node in
 *                      pixels ("height").
 * @param {Number} z    z-Size to be added to the relatively sized node in
 *                      pixels ("depth").
 *
 * @return {Node} this
 */
Node.prototype.setDifferentialSize = function setDifferentialSize (x, y, z) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._sizeID).setDifferential(x, y, z);
    else if (this.isMounted())
        SizeSystem.get(this.getLocation()).setDifferential(x, y, z);
    else throw new Error('This node does not have access to a size component');
    return this;
};

/**
 * Sets the node's size in pixels, independent of its parent.
 *
 * @method setAbsoluteSize
 *
 * @param {Number} x x-Size in pixels ("width").
 * @param {Number} y y-Size in pixels ("height").
 * @param {Number} z z-Size in pixels ("depth").
 *
 * @return {Node} this
 */
Node.prototype.setAbsoluteSize = function setAbsoluteSize (x, y, z) {
    if (!this.constructor.NO_DEFAULT_COMPONENTS)
        this.getComponent(this._sizeID).setAbsolute(x, y, z);
    else if (this.isMounted())
        SizeSystem.get(this.getLocation()).setAbsolute(x, y, z);
    else throw new Error('This node does not have access to a size component');
    return this;
};

/**
 * Method for getting the current frame. Will be deprecated.
 *
 * @method
 *
 * @return {Number} current frame
 */
Node.prototype.getFrame = function getFrame () {
    return this._updater.getFrame();
};

/**
 * returns an array of the components currently attached to this
 * node.
 *
 * @method getComponents
 *
 * @return {Array} list of components.
 */
Node.prototype.getComponents = function getComponents () {
    return this._components;
};

/**
 * Enters the node's update phase while updating its own spec and updating its components.
 *
 * @method update
 *
 * @param  {Number} time    high-resolution timestamp, usually retrieved using
 *                          requestAnimationFrame
 *
 * @return {Node} this
 */
Node.prototype.update = function update (time){
    this._inUpdate = true;
    var nextQueue = this._nextUpdateQueue;
    var queue = this._updateQueue;
    var item;

    while (nextQueue.length) queue.unshift(nextQueue.pop());

    while (queue.length) {
        item = this._components[queue.shift()];
        if (item && item.onUpdate) item.onUpdate(time);
    }

    this._inUpdate = false;
    this._requestingUpdate = false;

    if (!this.isMounted()) {
        // last update
        this._parent = null;
        this._id = null;
    }
    else if (this._nextUpdateQueue.length) {
        this._updater.requestUpdateOnNextTick(this);
        this._requestingUpdate = true;
    }
    return this;
};

/**
 * Mounts the node and therefore its subtree by setting it as a child of the
 * passed in parent.
 *
 * @method mount
 *
 * @param  {String} path unique path of node (e.g. `body/0/1`)
 *
 * @return {Node} this
 */
Node.prototype.mount = function mount (path) {
    if (this.isMounted())
        throw new Error('Node is already mounted at: ' + this.getLocation());

    if (!this.constructor.NO_DEFAULT_COMPONENTS){
        TransformSystem.registerTransformAtPath(path, this.getComponent(this._transformID));
        OpacitySystem.registerOpacityAtPath(path, this.getComponent(this._opacityID));
        SizeSystem.registerSizeAtPath(path, this.getComponent(this._sizeID));
    }
    else {
        TransformSystem.registerTransformAtPath(path);
        OpacitySystem.registerOpacityAtPath(path);
        SizeSystem.registerSizeAtPath(path);
    }
    Dispatch.mount(path, this);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;

};

/**
 * Dismounts (detaches) the node from the scene graph by removing it as a
 * child of its parent.
 *
 * @method
 *
 * @return {Node} this
 */
Node.prototype.dismount = function dismount () {
    if (!this.isMounted())
        throw new Error('Node is not mounted');

    var path = this.getLocation();

    TransformSystem.deregisterTransformAtPath(path);
    SizeSystem.deregisterSizeAtPath(path);
    OpacitySystem.deregisterOpacityAtPath(path);
    Dispatch.dismount(path);

    if (!this._requestingUpdate) this._requestUpdate();
};

module.exports = Node;

},{"./Dispatch":33,"./Opacity":37,"./OpacitySystem":38,"./Size":41,"./SizeSystem":42,"./Transform":44,"./TransformSystem":45}],37:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

function Opacity (parent) {
    this.local = 1;
    this.global = 1;
    this.opacity = 1;
    this.parent = parent ? parent : null;
    this.breakPoint = false;
    this.calculatingWorldOpacity = false;
}

Opacity.WORLD_CHANGED = 1;
Opacity.LOCAL_CHANGED = 2;

Opacity.prototype.reset = function reset () {
    this.parent = null;
    this.breakPoint = false;
};

Opacity.prototype.setParent = function setParent (parent) {
    this.parent = parent;
};

Opacity.prototype.getParent = function getParent () {
    return this.parent;
};

Opacity.prototype.setBreakPoint = function setBreakPoint () {
    this.breakPoint = true;
    this.calculatingWorldOpacity = true;
};

/**
 * Set this node to calculate the world opacity.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Opacity.prototype.setCalculateWorldOpacity = function setCalculateWorldOpacity () {
    this.calculatingWorldOpacity = true;
};

Opacity.prototype.isBreakPoint = function isBreakPoint () {
    return this.breakPoint;
};

Opacity.prototype.getLocalOpacity = function getLocalOpacity () {
    return this.local;
};

Opacity.prototype.getWorldOpacity = function getWorldOpacity () {
    if (!this.isBreakPoint() && !this.calculatingWorldOpacity)
        throw new Error('This opacity is not calculating world transforms');
    return this.global;
};

Opacity.prototype.calculate = function calculate (node) {
    if (!this.parent || this.parent.isBreakPoint())
        return this.fromNode(node);
    else return this.fromNodeWithParent(node);
};

Opacity.prototype.getOpacity = function getOpacity () {
    return this.opacity;
};

Opacity.prototype.setOpacity = function setOpacity (opacity) {
    this.opacity = opacity;
};

Opacity.prototype.calculateWorldOpacity = function calculateWorldOpacity () {
    var nearestBreakPoint = this.parent;

    var previousGlobal = this.global;

    while (nearestBreakPoint && !nearestBreakPoint.isBreakPoint())
        nearestBreakPoint = nearestBreakPoint.parent;

    if (nearestBreakPoint) {
        this.global = nearestBreakPoint.getWorldOpacity() * this.local;
    }
    else {
        this.global = this.local;
    }

    return previousGlobal !== this.global;
};

Opacity.prototype.fromNode = function fromNode () {
    var changed = 0;

    if (this.opacity !== this.local)
        changed |= Opacity.LOCAL_CHANGED;

    this.local = this.opacity;

    if (this.calculatingWorldOpacity && this.calculateWorldOpacity())
        changed |= Opacity.WORLD_CHANGED;

    return changed;
};

Opacity.prototype.fromNodeWithParent = function fromNodeWithParent () {
    var changed = 0;

    var previousLocal = this.local;

    this.local = this.parent.getLocalOpacity() * this.opacity;

    if (this.calculatingWorldOpacity && this.calculateWorldOpacity())
        changed |= Opacity.WORLD_CHANGED;

    if (previousLocal !== this.local)
        changed |= Opacity.LOCAL_CHANGED;

    return changed;
};

module.exports = Opacity;

},{}],38:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var PathUtils = require('./Path');
var Opacity = require('./Opacity');
var Dispatch = require('./Dispatch');
var System = require('./System');

/**
 * The opacity class is responsible for calculating the opacity of a particular
 * node from the data on the node and its parent
 *
 * @constructor {OpacitySystem}
 */
function OpacitySystem () {
    System.call(this);
}

OpacitySystem.prototype = Object.create(System.prototype);
OpacitySystem.prototype.constructor = OpacitySystem;

/**
 * registers a new Opacity for the given path. This opacity will be updated
 * when the OpacitySystem updates.
 *
 * @method registerOpacityAtPath
 *
 * @param {String} path path for the opacity to be registered to.
 * @param {Opacity} [opacity] opacity to register.
 * @return {undefined} undefined
 */
OpacitySystem.prototype.registerOpacityAtPath = function registerOpacityAtPath (path, opacity) {
    if (!PathUtils.depth(path)) return this.insert(path, opacity ? opacity : new Opacity());

    var parent = this.get(PathUtils.parent(path));

    if (!parent) throw new Error(
            'No parent opacity registered at expected path: ' + PathUtils.parent(path)
    );

    if (opacity) opacity.setParent(parent);

    this.insert(path, opacity ? opacity : new Opacity(parent));
};

/**
 * Deregisters a opacity registered at the given path.
 *
 * @method deregisterOpacityAtPath
 * @return {void}
 *
 * @param {String} path at which to register the opacity
 */
OpacitySystem.prototype.deregisterOpacityAtPath = OpacitySystem.prototype.remove;

/**
 * Method which will make the opacity currently stored at the given path a breakpoint.
 * A opacity being a breakpoint means that both a local and world opacity will be calculated
 * for that point. The local opacity being the concatinated opacity of all ancestor opacities up
 * until the nearest breakpoint, and the world being the concatinated opacity of all ancestor opacities.
 * This method throws if no opacity is at the provided path.
 *
 * @method
 *
 * @param {String} path The path at which to turn the opacity into a breakpoint
 *
 * @return {undefined} undefined
 */
OpacitySystem.prototype.makeBreakPointAt = function makeBreakPointAt (path) {
    var opacity = this.get(path);
    if (!opacity) throw new Error('No opacity Registered at path: ' + path);
    opacity.setBreakPoint();
};

/**
 * Method that will make the opacity at this location calculate a world opacity.
 *
 * @method
 *
 * @param {String} path The path at which to make the opacity calculate a world matrix
 *
 * @return {undefined} undefined
 */
OpacitySystem.prototype.makeCalculateWorldOpacityAt = function makeCalculateWorldOpacityAt (path) {
    var opacity = this.get(path);
    if (!opacity) throw new Error('No opacity opacity at path: ' + path);
    opacity.setCalculateWorldOpacity();
};

/**
 * update is called when the opacity system requires an update.
 * It traverses the opacity array and evaluates the necessary opacities
 * in the scene graph with the information from the corresponding node
 * in the scene graph
 *
 * @method update
 * @return {undefined} undefined
 */
OpacitySystem.prototype.update = function update () {
    var opacities = this.getItems();
    var paths = this.getPaths();
    var opacity;
    var changed;
    var node;
    var components;

    for (var i = 0, len = opacities.length ; i < len ; i++) {
        node = Dispatch.getNode(paths[i]);
        if (!node) continue;
        components = node.getComponents();
        opacity = opacities[i];

        if ((changed = opacity.calculate())) {
            opacityChanged(node, components, opacity);
            if (changed & Opacity.LOCAL_CHANGED) localOpacityChanged(node, components, opacity.getLocalOpacity());
            if (changed & Opacity.WORLD_CHANGED) worldOpacityChanged(node, components, opacity.getWorldOpacity());
        }
    }
};

/**
 * Private method to call when either the Local or World Opacity changes.
 * Triggers 'onOpacityChange' methods on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Opacity} opacity the opacity class that changed
 *
 * @return {undefined} undefined
 */
function opacityChanged (node, components, opacity) {
    if (node.onOpacityChange) node.onOpacityChange(opacity);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onOpacityChange)
            components[i].onOpacityChange(opacity);
}

/**
 * Private method to call when the local opacity changes. Triggers 'onLocalOpacityChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Array} opacity the local opacity
 *
 * @return {undefined} undefined
 */
function localOpacityChanged (node, components, opacity) {
    if (node.onLocalOpacityChange) node.onLocalOpacityChange(opacity);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onLocalOpacityChange)
            components[i].onLocalOpacityChange(opacity);
}

/**
 * Private method to call when the world opacity changes. Triggers 'onWorldOpacityChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Array} opacity the world opacity
 *
 * @return {undefined} undefined
 */
function worldOpacityChanged (node, components, opacity) {
    if (node.onWorldOpacityChange) node.onWorldOpacityChange(opacity);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onWorldOpacityChange)
            components[i].onWorldOpacityChange(opacity);
}

module.exports = new OpacitySystem();

},{"./Dispatch":33,"./Opacity":37,"./Path":39,"./System":43}],39:[function(require,module,exports){
(function (process){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var assert = require('../utilities/assert');

/**
 * A collection of utilities for handling paths.
 *
 * @namespace
 */
var Path = {

    /**
     * determines if the passed in path has a trailing slash. Paths of the form
     * 'body/0/1/' return true, while paths of the form 'body/0/1' return false.
     *
     * @method
     *
     * @param {String} path the path
     *
     * @return {Boolean} whether or not the path has a trailing slash
     */
    hasTrailingSlash: function hasTrailingSlash (path) {
        if (process.env.NODE_ENV === 'development')
            assert(typeof path === 'string', 'path needs to be a string');

        return path[path.length - 1] === '/';
    },

    /**
     * Returns the depth in the tree this path represents. Essentially counts
     * the slashes ignoring a trailing slash.
     *
     * @method
     *
     * @param {String} path the path
     *
     * @return {Number} the depth in the tree that this path represents
     */
    depth: function depth (path) {
        if (process.env.NODE_ENV === 'development')
            assert(typeof path === 'string', 'path needs to be a string');

        var count = 0;
        var length = path.length;
        var len = this.hasTrailingSlash(path) ? length - 1 : length;
        var i = 0;
        for (; i < len ; i++) count += path[i] === '/' ? 1 : 0;
        return count;
    },

    /**
     * Gets the position of this path in relation to its siblings.
     *
     * @method
     *
     * @param {String} path the path
     *
     * @return {Number} the index of this path in relation to its siblings.
     */
    index: function index (path) {
        if (process.env.NODE_ENV === 'development')
            assert(typeof path === 'string', 'path needs to be a string');

        var length = path.length;
        var len = this.hasTrailingSlash(path) ? length - 1 : length;
        while (len--) if (path[len] === '/') break;
        var result = parseInt(path.substring(len + 1));
        return isNaN(result) ? 0 : result;
    },

    /**
     * Gets the position of the path at a particular breadth in relationship
     * to its siblings
     *
     * @method
     *
     * @param {String} path the path
     * @param {Number} depth the breadth at which to find the index
     *
     * @return {Number} index at the particular depth
     */
    indexAtDepth: function indexAtDepth (path, depth) {
        if (process.env.NODE_ENV === 'development') {
            assert(typeof path === 'string', 'path needs to be a string');
            assert(typeof depth === 'number', 'depth needs to be a number');
        }

        var i = 0;
        var len = path.length;
        var index = 0;
        for (; i < len ; i++) {
            if (path[i] === '/') index++;
            if (index === depth) {
                path = path.substring(i ? i + 1 : i);
                index = path.indexOf('/');
                path = index === -1 ? path : path.substring(0, index);
                index = parseInt(path);
                return isNaN(index) ? path : index;
            }
        }
    },

    /**
     * returns the path of the passed in path's parent.
     *
     * @method
     *
     * @param {String} path the path
     *
     * @return {String} the path of the passed in path's parent
     */
    parent: function parent (path) {
        if (process.env.NODE_ENV === 'development')
            assert(typeof path === 'string', 'path needs to be a string');

        return path.substring(0, path.lastIndexOf('/', path.length - 2));
    },

    /**
     * Determines whether or not the first argument path is the direct child
     * of the second argument path.
     *
     * @method
     *
     * @param {String} child the path that may be a child
     * @param {String} parent the path that may be a parent
     *
     * @return {Boolean} whether or not the first argument path is a child of the second argument path
     */
    isChildOf: function isChildOf (child, parent) {
        if (process.env.NODE_ENV === 'development') {
            assert(typeof child === 'string', 'child needs to be a string');
            assert(typeof parent === 'string', 'parent needs to be a string');
        }

        return this.isDescendentOf(child, parent) && this.depth(child) === this.depth(parent) + 1;
    },

    /**
     * Returns true if the first argument path is a descendent of the second argument path.
     *
     * @method
     *
     * @param {String} child potential descendent path
     * @param {String} parent potential ancestor path
     *
     * @return {Boolean} whether or not the path is a descendent
     */
    isDescendentOf: function isDescendentOf(child, parent) {
        if (process.env.NODE_ENV === 'development') {
            assert(typeof child === 'string', 'child needs to be a string');
            assert(typeof parent === 'string', 'parent needs to be a string');
        }

        if (child === parent) return false;
        child = this.hasTrailingSlash(child) ? child : child + '/';
        parent = this.hasTrailingSlash(parent) ? parent : parent + '/';
        return this.depth(parent) < this.depth(child) && child.indexOf(parent) === 0;
    },

    /**
     * returns the selector portion of the path.
     *
     * @method
     *
     * @param {String} path the path
     *
     * @return {String} the selector portion of the path.
     */
    getSelector: function getSelector(path) {
        if (process.env.NODE_ENV === 'development')
            assert(typeof path === 'string', 'path needs to be a string');

        var index = path.indexOf('/');
        return index === -1 ? path : path.substring(0, index);
    }

};

module.exports = Path;

}).call(this,require('_process'))

},{"../utilities/assert":70,"_process":1}],40:[function(require,module,exports){
(function (process){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Node = require('./Node');
var Dispatch = require('./Dispatch');
var Commands = require('./Commands');
var TransformSystem = require('./TransformSystem');
var OpacitySystem = require('./OpacitySystem');
var SizeSystem = require('./SizeSystem');
var assert = require('../utilities/assert');

/**
 * Scene is the bottom of the scene graph. It is its own
 * parent and provides the global updater to the scene graph.
 *
 * @class Scene
 * @constructor
 * @extends Node
 */
function Scene () {
    Node.call(this);
}

Scene.prototype = Object.create(Node.prototype);
Scene.prototype.constructor = Scene;

Scene.NO_DEFAULT_COMPONENTS = true;

/**
 * Returns the selector that the context was instantiated with
 *
 * @alias {Node#getLocation}
 *
 * @return {String} dom selector
 */
Scene.prototype.getSelector = Node.prototype.getLocation;

/**
 * Receives an event. If the event is 'CONTEXT_RESIZE' it sets the size of the scene
 * graph to the payload, which must be an array of numbers of at least
 * length three representing the pixel size in 3 dimensions.
 *
 * @param {String} event the name of the event being received
 * @param {*} payload the object being sent
 *
 * @return {undefined} undefined
 */
Scene.prototype.onReceive = function onReceive (event, payload) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof event === 'string', 'event needs to be a string');

    // TODO: In the future the dom element that the context is attached to
    // should have a representation as a component. It would be render sized
    // and the context would receive its size the same way that any render size
    // component receives its size.
    if (event === 'CONTEXT_RESIZE') {
        if (payload.length < 2)
            throw new Error(
                'CONTEXT_RESIZE\'s payload needs to be at least a pair' +
                ' of pixel sizes'
            );

        this.setSizeMode('absolute', 'absolute', 'absolute');
        this.setAbsoluteSize(payload[0],
                             payload[1],
                             payload[2] ? payload[2] : 0);

        this._updater.message(Commands.WITH).message(this._id).message(Commands.READY);
    }
};

Scene.prototype.mount = function mount (path) {
    if (process.env.NODE_ENV === 'development') {
        assert(typeof path === 'string', 'path needs to be a string');
        assert(!this.isMounted(), 'scene needs to be dismounted');
    }

    Dispatch.mount(path, this);

    this._updater                   // message a request for the dom
        .message(Commands.NEED_SIZE_FOR)  // size of the context so that
        .message(path);         // the scene graph has a total size

    this._id = path;
    this._mounted = true;
    this._parent = this;
    TransformSystem.registerTransformAtPath(path);
    OpacitySystem.registerOpacityAtPath(path);
    SizeSystem.registerSizeAtPath(path);

    // the context begins shown (it's already present in the dom)
    this.show();
};

module.exports = Scene;

}).call(this,require('_process'))

},{"../utilities/assert":70,"./Commands":32,"./Dispatch":33,"./Node":36,"./OpacitySystem":38,"./SizeSystem":42,"./TransformSystem":45,"_process":1}],41:[function(require,module,exports){
(function (process){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var assert = require('../utilities/assert');

var ONES = [1, 1, 1];
var ZEROS = [0, 0, 0];

/**
 * The Size class is responsible for processing Size from a node
 * @constructor Size
 *
 * @param {Size} parent the parent size
 */
function Size (parent) {
    if (process.env.NODE_ENV === 'development')
        assert(parent === undefined || parent.constructor === Size, 'parent needs to be a Size instance or undefined');

    this.finalSize = new Float32Array(3);
    this.sizeChanged = false;

    this.sizeMode = new Uint8Array(3);
    this.sizeModeChanged = false;

    this.absoluteSize = new Float32Array(3);
    this.absoluteSizeChanged = false;

    this.proportionalSize = new Float32Array(ONES);
    this.proportionalSizeChanged = false;

    this.differentialSize = new Float32Array(3);
    this.differentialSizeChanged = false;

    this.renderSize = new Float32Array(3);
    this.renderSizeChanged = false;

    this.parent = parent != null ? parent : null;
}

// an enumeration of the different types of size modes
Size.RELATIVE = 0;
Size.ABSOLUTE = 1;
Size.RENDER = 2;
Size.DEFAULT = Size.RELATIVE;

/**
 * Private method which sets a value within an array
 * and report if the value has changed.
 *
 * @method
 *
 * @param {Array} vec The array to set the value in
 * @param {Number} index The index at which to set the value
 * @param {Any} val If the val is undefined or null, or if the value
 *                  is the same as what is already there, then nothing
 *                  is set.
 *
 * @return {Boolean} returns true if anything changed
 */
function _vecOptionalSet (vec, index, val) {
    if (val != null && vec[index] !== val) {
        vec[index] = val;
        return true;
    } else return false;
}

/**
 * Private method which sets three values within an array of three
 * using _vecOptionalSet. Returns whether anything has changed.
 *
 * @method
 *
 * @param {Array} vec The array to set the values of
 * @param {Any} x The first value to set within the array
 * @param {Any} y The second value to set within the array
 * @param {Any} z The third value to set within the array
 *
 * @return {Boolean} whether anything has changed
 */
function setVec (vec, x, y, z) {
    var propagate = false;

    propagate = _vecOptionalSet(vec, 0, x) || propagate;
    propagate = _vecOptionalSet(vec, 1, y) || propagate;
    propagate = _vecOptionalSet(vec, 2, z) || propagate;

    return propagate;
}

/**
 * Private method to allow for polymorphism in the size mode such that strings
 * or the numbers from the enumeration can be used.
 *
 * @method
 *
 * @param {String|Number} val The Size mode to resolve.
 *
 * @return {Number} the resolved size mode from the enumeration.
 */
function resolveSizeMode (val) {
    if (val.constructor === String) {
        switch (val.toLowerCase()) {
            case 'relative':
            case 'default': return Size.RELATIVE;
            case 'absolute': return Size.ABSOLUTE;
            case 'render': return Size.RENDER;
            default: throw new Error('unknown size mode: ' + val);
        }
    }
    else if (val < 0 || val > Size.RENDER) throw new Error('unknown size mode: ' + val);
    return val;
}

/**
 * Sets the parent of this size.
 *
 * @method
 *
 * @param {Size} parent The parent size component
 *
 * @return {Size} this
 */
Size.prototype.setParent = function setParent (parent) {
    this.parent = parent;
    return this;
};

/**
 * Gets the parent of this size.
 *
 * @method
 *
 * @returns {Size|undefined} the parent if one exists
 */
Size.prototype.getParent = function getParent () {
    return this.parent;
};

/**
 * Gets the size mode of this size representation
 *
 * @method
 *
 * @param {Number} x the size mode to use for the width
 * @param {Number} y the size mode to use for the height
 * @param {Number} z the size mode to use for the depth
 *
 * @return {array} array of size modes
 */
Size.prototype.setSizeMode = function setSizeMode (x, y, z) {
    if (x != null) x = resolveSizeMode(x);
    if (y != null) y = resolveSizeMode(y);
    if (z != null) z = resolveSizeMode(z);
    this.sizeModeChanged = setVec(this.sizeMode, x, y, z);
    return this;
};

/**
 * Returns the size mode of this component.
 *
 * @method
 *
 * @return {Array} the current size mode of the this.
 */
Size.prototype.getSizeMode = function getSizeMode () {
    return this.sizeMode;
};

/**
 * Sets the absolute size of this size representation.
 *
 * @method
 *
 * @param {Number} x The x dimension of the absolute size
 * @param {Number} y The y dimension of the absolute size
 * @param {Number} z The z dimension of the absolute size
 *
 * @return {Size} this
 */
Size.prototype.setAbsolute = function setAbsolute (x, y, z) {
    this.absoluteSizeChanged = setVec(this.absoluteSize, x, y, z);
    return this;
};

/**
 * Gets the absolute size of this size representation
 *
 * @method
 *
 * @return {array} array of absolute size
 */
Size.prototype.getAbsolute = function getAbsolute () {
    return this.absoluteSize;
};

/**
 * Sets the proportional size of this size representation.
 *
 * @method
 *
 * @param {Number} x The x dimension of the proportional size
 * @param {Number} y The y dimension of the proportional size
 * @param {Number} z The z dimension of the proportional size
 *
 * @return {Size} this
 */
Size.prototype.setProportional = function setProportional (x, y, z) {
    this.proportionalSizeChanged = setVec(this.proportionalSize, x, y, z);
    return this;
};

/**
 * Gets the propotional size of this size representation
 *
 * @method
 *
 * @return {array} array of proportional size
 */
Size.prototype.getProportional = function getProportional () {
    return this.proportionalSize;
};

/**
 * Sets the differential size of this size representation.
 *
 * @method
 *
 * @param {Number} x The x dimension of the differential size
 * @param {Number} y The y dimension of the differential size
 * @param {Number} z The z dimension of the differential size
 *
 * @return {Size} this
 */
Size.prototype.setDifferential = function setDifferential (x, y, z) {
    this.differentialSizeChanged = setVec(this.differentialSize, x, y, z);
    return this;
};

/**
 * Gets the differential size of this size representation
 *
 * @method
 *
 * @return {array} array of differential size
 */
Size.prototype.getDifferential = function getDifferential () {
    return this.differentialSize;
};

/**
 * Sets the size of this size representation.
 *
 * @method
 *
 * @param {Number} x The x dimension of the size
 * @param {Number} y The y dimension of the size
 * @param {Number} z The z dimension of the size
 *
 * @return {Size} this
 */
Size.prototype.get = function get () {
    return this.finalSize;
};

/**
 * fromSpecWithParent takes the parent node's size, the target node's spec,
 * and a target array to write to. Using the node's size mode it calculates
 * a final size for the node from the node's spec. Returns whether or not
 * the final size has changed from its last value.
 *
 * @method
 *
 * @param {Array} components the node's components
 *
 * @return {Boolean} true if the size of the node has changed.
 */
Size.prototype.fromComponents = function fromComponents (components) {
    if (process.env.NODE_ENV === 'development')
        assert(Array.isArray(components), 'components needs to be an array');

    var mode = this.sizeMode;
    var target = this.finalSize;
    var parentSize = this.parent ? this.parent.get() : ZEROS;
    var prev;
    var changed = false;
    var len = components.length;
    var j;
    for (var i = 0 ; i < 3 ; i++) {
        prev = target[i];
        switch (mode[i]) {
            case Size.RELATIVE:
                target[i] = parentSize[i] * this.proportionalSize[i] + this.differentialSize[i];
                break;
            case Size.ABSOLUTE:
                target[i] = this.absoluteSize[i];
                break;
            case Size.RENDER:
                var candidate;
                var component;
                for (j = 0; j < len ; j++) {
                    component = components[j];
                    if (component && component.getRenderSize) {
                        candidate = component.getRenderSize()[i];
                        target[i] = target[i] < candidate || target[i] === 0 ? candidate : target[i];
                    }
                }
                break;
        }
        changed = changed || prev !== target[i];
    }
    this.sizeChanged = changed;
    return changed;
};

module.exports = Size;

}).call(this,require('_process'))

},{"../utilities/assert":70,"_process":1}],42:[function(require,module,exports){
(function (process){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var System = require('./System');
var Size = require('./Size');
var Dispatch = require('./Dispatch');
var PathUtils = require('./Path');
var TransformSystem = require('./TransformSystem');
var assert = require('../utilities/assert');

/**
 * The size system is used to calculate size throughout the scene graph.
 * It holds size components and operates upon them.
 *
 * @constructor
 */
function SizeSystem () {
    System.call(this);
}

SizeSystem.prototype = Object.create(System.prototype);
SizeSystem.prototype.constructor = SizeSystem;

/**
 * Registers a size component to a give path. A size component can be passed as the second argument
 * or a default one will be created. Throws if no size component has been added at the parent path.
 *
 * @method
 *
 * @param {String} path The path at which to register the size component
 * @param {Size | undefined} size The size component to be registered or undefined.
 *
 * @return {undefined} undefined
 */
SizeSystem.prototype.registerSizeAtPath = function registerSizeAtPath (path, size) {
    if (process.env.NODE_ENV === 'development') {
        assert(typeof path === 'string', 'path needs to be a string');
        assert(size === undefined || size.constructor === Size, 'size needs to be a Size instance or undefined');
    }

    if (!PathUtils.depth(path)) return this.insert(path, size ? size : new Size());

    var parent = this.get(PathUtils.parent(path));

    if (!parent) throw new Error(
        'No parent size registered at expected path: ' + PathUtils.parent(path)
    );

    if (size) size.setParent(parent);

    this.insert(path, size ? size : new Size(parent));
};

/**
 * Removes the size component from the given path. Will throw if no component is at that
 * path
 *
 * @method
 *
 * @param {String} path The path at which to remove the size.
 *
 * @return {undefined} undefined
 */
SizeSystem.prototype.deregisterSizeAtPath = SizeSystem.prototype.remove;

/**
 * Updates the sizes in the scene graph. Called internally by the famous engine.
 *
 * @method
 *
 * @return {undefined} undefined
 */
SizeSystem.prototype.update = function update () {
    var sizes = this.getItems();
    var paths = this.getPaths();
    var node;
    var size;
    var i;
    var len;
    var components;

    for (i = 0, len = sizes.length ; i < len ; i++) {
        node = Dispatch.getNode(paths[i]);
        components = node.getComponents();
        if (!node) continue;
        size = sizes[i];
        if (size.sizeModeChanged) sizeModeChanged(node, components, size);
        if (size.absoluteSizeChanged) absoluteSizeChanged(node, components, size);
        if (size.proportionalSizeChanged) proportionalSizeChanged(node, components, size);
        if (size.differentialSizeChanged) differentialSizeChanged(node, components, size);
        if (size.renderSizeChanged) renderSizeChanged(node, components, size);
        if (size.fromComponents(components)) sizeChanged(node, components, size, paths[i], i === len -1);
    }
};

// private methods

/**
 * Private method to alert the node and components that size mode changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call sizeModeChanged on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function sizeModeChanged (node, components, size) {
    var sizeMode = size.getSizeMode();
    var x = sizeMode[0];
    var y = sizeMode[1];
    var z = sizeMode[2];
    if (node.onSizeModeChange) node.onSizeModeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onSizeModeChange)
            components[i].onSizeModeChange(x, y, z);
    size.sizeModeChanged = false;
}

/**
 * Private method to alert the node and components that absoluteSize changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call onAbsoluteSizeChange on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function absoluteSizeChanged (node, components, size) {
    var absoluteSize = size.getAbsolute();
    var x = absoluteSize[0];
    var y = absoluteSize[1];
    var z = absoluteSize[2];
    if (node.onAbsoluteSizeChange) node.onAbsoluteSizeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onAbsoluteSizeChange)
            components[i].onAbsoluteSizeChange(x, y, z);
    size.absoluteSizeChanged = false;
}

/**
 * Private method to alert the node and components that the proportional size changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call onProportionalSizeChange on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function proportionalSizeChanged (node, components, size) {
    var proportionalSize = size.getProportional();
    var x = proportionalSize[0];
    var y = proportionalSize[1];
    var z = proportionalSize[2];
    if (node.onProportionalSizeChange) node.onProportionalSizeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onProportionalSizeChange)
            components[i].onProportionalSizeChange(x, y, z);
    size.proportionalSizeChanged = false;
}

/**
 * Private method to alert the node and components that differential size changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call onDifferentialSize on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function differentialSizeChanged (node, components, size) {
    var differentialSize = size.getDifferential();
    var x = differentialSize[0];
    var y = differentialSize[1];
    var z = differentialSize[2];
    if (node.onDifferentialSizeChange) node.onDifferentialSizeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onDifferentialSizeChange)
            components[i].onDifferentialSizeChange(x, y, z);
    size.differentialSizeChanged = false;
}

/**
 * Private method to alert the node and components that render size changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call onRenderSizeChange on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function renderSizeChanged (node, components, size) {
    var renderSize = size.getRenderSize();
    var x = renderSize[0];
    var y = renderSize[1];
    var z = renderSize[2];
    if (node.onRenderSizeChange) node.onRenderSizeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onRenderSizeChange)
            components[i].onRenderSizeChange(x, y, z);
    size.renderSizeChanged = false;
}

/**
 * Private method to alert the node and components that the size changed.
 *
 * @method
 * @private
 *
 * @param {Node} node Node to potentially call onSizeChange on
 * @param {Array} components a list of the nodes' components
 * @param {Size} size the size class for the Node
 *
 * @return {undefined} undefined
 */
function sizeChanged (node, components, size, path, doIt) {
    var finalSize = size.get();
    var x = finalSize[0];
    var y = finalSize[1];
    var z = finalSize[2];
    if (node.onSizeChange) node.onSizeChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onSizeChange)
            components[i].onSizeChange(x, y, z);
    size.sizeChanged = false;

    var transform = TransformSystem.get(path);
    transform._dirtyFromSizeChange = true;
}

module.exports = new SizeSystem();

}).call(this,require('_process'))

},{"../utilities/assert":70,"./Dispatch":33,"./Path":39,"./Size":41,"./System":43,"./TransformSystem":45,"_process":1}],43:[function(require,module,exports){
(function (process){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var PathUtils = require('./Path');
var assert = require('../utilities/assert');

/**
 * A class that can be used to associate any item with a path.
 * Items and paths are kept in flat arrays for easy iteration
 * and a memo is used to provide constant time lookup.
 *
 * @class
 *
 */
function System () {
    this.items = [];
    this.paths = [];
    this.memo = {};
}

/**
 * Associates an item with the given path. Errors if an item
 * already exists at the given path.
 *
 * @method
 *
 * @param {String} path The path at which to insert the item
 * @param {Any} item The item to associate with the given path.
 *
 * @return {undefined} undefined
 */
System.prototype.insert = function insert (path, item) {
    if (process.env.NODE_ENV === 'development') {
        assert(typeof path === 'string', 'path needs to be a string');
        assert(typeof item !== 'string', 'item needs to be given');
    }

    var paths = this.paths;
    var index = paths.indexOf(path);
    if (index !== -1)
        throw new Error('item already exists at path: ' + path);

    var i = 0;
    var targetDepth = PathUtils.depth(path);
    var targetIndex = PathUtils.index(path);

    // The item will be inserted at a point in the array
    // such that it is within its own breadth in the tree
    // that the paths represent
    while (
        paths[i] &&
        targetDepth >= PathUtils.depth(paths[i])
    ) i++;

    // The item will be sorted within its breadth by index
    // in regard to its siblings.
    while (
        paths[i] &&
        targetDepth === PathUtils.depth(paths[i]) &&
        targetIndex < PathUtils.index(paths[i])
    ) i++;

    // insert the items in the path
    paths.splice(i, 0, path);
    this.items.splice(i, 0, item);

    // store the relationship between path and index in the memo
    this.memo[path] = i;

    // all items behind the inserted item are now no longer
    // accurately stored in the memo. Thus the memo must be cleared for
    // these items.
    for (var len = this.paths.length ; i < len ; i++)
        this.memo[this.paths[i]] = null;
};

/**
 * Removes the the item from the store at the given path.
 * Errors if no item exists at the given path.
 *
 * @method
 *
 * @param {String} path The path at which to remove the item.
 *
 * @return {undefined} undefined
 */
System.prototype.remove = function remove (path) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof path === 'string', 'path needs to be a string');

    var paths = this.paths;
    var index = this.memo[path] ? this.memo[path] : paths.indexOf(path);
    if (index === -1)
        throw new Error('Cannot remove. No item exists at path: ' + path);

    paths.splice(index, 1);
    this.items.splice(index, 1);

    this.memo[path] = null;

    for (var len = this.paths.length ; index < len ; index++)
        this.memo[this.paths[index]] = null;
};

/**
 * Returns the item stored at the current path. Returns undefined
 * if no item is stored at that path.
 *
 * @method
 *
 * @param {String} path The path to lookup the item for
 *
 * @return {Any | undefined} the item stored or undefined
 */
System.prototype.get = function get (path) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof path === 'string', 'path needs to be a string');

    if (this.memo[path]) return this.items[this.memo[path]];

    var index = this.paths.indexOf(path);

    if (index === -1) return void 0;

    this.memo[path] = index;

    return this.items[index];
};

/**
 * Returns an array of the items currently stored in this
 * System.
 *
 * @method
 *
 * @return {Array} items currently stored
 */
System.prototype.getItems = function getItems () {
    return this.items;
};

/**
 * Returns an array of the paths currently stored in this
 * System.
 *
 * @method
 *
 * @return {Array} paths currently stored
 */
System.prototype.getPaths = function getPaths () {
    return this.paths;
};

module.exports = System;

}).call(this,require('_process'))

},{"../utilities/assert":70,"./Path":39,"_process":1}],44:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var QUAT = [0, 0, 0, 1];
var ONES = [1, 1, 1];

/**
 * The transform class is responsible for calculating the transform of a particular
 * node from the data on the node and its parent
 *
 * @constructor Transform
 *
 * @param {Transform} parent the parent Transform
 */
function Transform (parent) {
    this.local = new Float32Array(Transform.IDENT);
    this.global = new Float32Array(Transform.IDENT);
    this.offsets = {
        align: new Float32Array(3),
        alignChanged: false,
        mountPoint: new Float32Array(3),
        mountPointChanged: false,
        origin: new Float32Array(3),
        originChanged: false
    };
    this.vectors = {
        position: new Float32Array(3),
        positionChanged: false,
        rotation: new Float32Array(QUAT),
        rotationChanged: false,
        scale: new Float32Array(ONES),
        scaleChanged: false
    };
    this._lastEulerVals = [0, 0, 0];
    this._lastEuler = false;
    this.parent = parent ? parent : null;
    this.breakPoint = false;
    this.calculatingWorldMatrix = false;
    this._dirty = false;
}

Transform.IDENT = [ 1, 0, 0, 0,
                    0, 1, 0, 0,
                    0, 0, 1, 0,
                    0, 0, 0, 1 ];

Transform.WORLD_CHANGED = 1;
Transform.LOCAL_CHANGED = 2;

/**
 * resets the transform state such that it no longer has a parent
 * and is not a breakpoint.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Transform.prototype.reset = function reset () {
    this.parent = null;
    this.breakPoint = false;
    this.calculatingWorldMatrix = false;
};

/**
 * sets the parent of this transform.
 *
 * @method
 *
 * @param {Transform} parent The transform class that parents this class
 *
 * @return {undefined} undefined
 */
Transform.prototype.setParent = function setParent (parent) {
    this.parent = parent;
};

/**
 * returns the parent of this transform
 *
 * @method
 *
 * @return {Transform | null} the parent of this transform if one exists
 */
Transform.prototype.getParent = function getParent () {
    return this.parent;
};

/**
 * Makes this transform a breakpoint. This will cause it to calculate
 * both a local (relative to the nearest ancestor breakpoint) and a world
 * matrix (relative to the scene).
 *
 * @method
 *
 * @return {undefined} undefined
 */
Transform.prototype.setBreakPoint = function setBreakPoint () {
    this.breakPoint = true;
    this.calculatingWorldMatrix = true;
};

/**
 * Set this node to calculate the world matrix.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Transform.prototype.setCalculateWorldMatrix = function setCalculateWorldMatrix () {
    this.calculatingWorldMatrix = true;
};

/**
 * returns whether or not this transform is a breakpoint.
 *
 * @method
 *
 * @return {Boolean} true if this transform is a breakpoint
 */
Transform.prototype.isBreakPoint = function isBreakPoint () {
    return this.breakPoint;
};

/**
 * returns the local transform
 *
 * @method
 *
 * @return {Float32Array} local transform
 */
Transform.prototype.getLocalTransform = function getLocalTransform () {
    return this.local;
};

/**
 * returns the world transform. Requires that this transform is a breakpoint.
 *
 * @method
 *
 * @return {Float32Array} world transform.
 */
Transform.prototype.getWorldTransform = function getWorldTransform () {
    if (!this.isBreakPoint() && !this.calculatingWorldMatrix)
        throw new Error('This transform is not calculating world transforms');
    return this.global;
};

/**
 * Takes a node and calculates the proper transform from it.
 *
 * @method
 *
 * @param {Node} node the node to calculate the transform from
 *
 * @return {undefined} undefined
 */
Transform.prototype.calculate = function calculate (node) {
    if (!this.parent || this.parent.isBreakPoint())
        return fromNode(node, this);
    else return fromNodeWithParent(node, this);
};

/**
 * A private method to potentially set a value within an
 * array. Will set the value if a value was given
 * for the third argument and if that value is different
 * than the value that is currently in the array at the given index.
 * Returns true if a value was set and false if not.
 *
 * @method
 *
 * @param {Array} vec The array to set the value within
 * @param {Number} index The index at which to set the value
 * @param {Any} val The value to potentially set in the array
 *
 * @return {Boolean} whether or not a value was set
 */
function _vecOptionalSet (vec, index, val) {
    if (val != null && vec[index] !== val) {
        vec[index] = val;
        return true;
    } else return false;
}

/**
 * private method to set values within an array.
 * Returns whether or not the array has been changed.
 *
 * @method
 *
 * @param {Array} vec The vector to be operated upon
 * @param {Number | null | undefined} x The x value of the vector
 * @param {Number | null | undefined} y The y value of the vector
 * @param {Number | null | undefined} z The z value of the vector
 * @param {Number | null | undefined} w the w value of the vector
 *
 * @return {Boolean} whether or not the array was changed
 */
function setVec (vec, x, y, z, w) {
    var propagate = false;

    propagate = _vecOptionalSet(vec, 0, x) || propagate;
    propagate = _vecOptionalSet(vec, 1, y) || propagate;
    propagate = _vecOptionalSet(vec, 2, z) || propagate;
    if (w != null)
        propagate = _vecOptionalSet(vec, 3, w) || propagate;

    return propagate;
}

/**
 * Gets the position component of the transform
 *
 * @method
 *
 * @return {Float32Array} the position component of the transform
 */
Transform.prototype.getPosition = function getPosition () {
    return this.vectors.position;
};

/**
 * Sets the position component of the transform.
 *
 * @method
 *
 * @param {Number} x The x dimension of the position
 * @param {Number} y The y dimension of the position
 * @param {Number} z The z dimension of the position
 *
 * @return {undefined} undefined
 */
Transform.prototype.setPosition = function setPosition (x, y, z) {
    this.vectors.positionChanged = setVec(this.vectors.position, x, y, z);
};

/**
 * Gets the rotation component of the transform. Will return a quaternion.
 *
 * @method
 *
 * @return {Float32Array} the quaternion representation of the transform's rotation
 */
Transform.prototype.getRotation = function getRotation () {
    return this.vectors.rotation;
};

/**
 * Sets the rotation component of the transform. Can take either Euler
 * angles or a quaternion.
 *
 * @method
 *
 * @param {Number} x The rotation about the x axis or the extent in the x dimension
 * @param {Number} y The rotation about the y axis or the extent in the y dimension
 * @param {Number} z The rotation about the z axis or the extent in the z dimension
 * @param {Number} w The rotation about the proceeding vector
 *
 * @return {undefined} undefined
 */
Transform.prototype.setRotation = function setRotation (x, y, z, w) {
    var quat = this.vectors.rotation;
    var qx, qy, qz, qw;

    if (w != null) {
        qx = x;
        qy = y;
        qz = z;
        qw = w;
        this._lastEulerVals[0] = null;
        this._lastEulerVals[1] = null;
        this._lastEulerVals[2] = null;
        this._lastEuler = false;
    }
    else {
        if (x == null || y == null || z == null) {
            if (this._lastEuler) {
                x = x == null ? this._lastEulerVals[0] : x;
                y = y == null ? this._lastEulerVals[1] : y;
                z = z == null ? this._lastEulerVals[2] : z;
            }
            else {
                var sp = -2 * (quat[1] * quat[2] - quat[3] * quat[0]);

                if (Math.abs(sp) > 0.99999) {
                    y = y == null ? Math.PI * 0.5 * sp : y;
                    x = x == null ? Math.atan2(-quat[0] * quat[2] + quat[3] * quat[1], 0.5 - quat[1] * quat[1] - quat[2] * quat[2]) : x;
                    z = z == null ? 0 : z;
                }
                else {
                    y = y == null ? Math.asin(sp) : y;
                    x = x == null ? Math.atan2(quat[0] * quat[2] + quat[3] * quat[1], 0.5 - quat[0] * quat[0] - quat[1] * quat[1]) : x;
                    z = z == null ? Math.atan2(quat[0] * quat[1] + quat[3] * quat[2], 0.5 - quat[0] * quat[0] - quat[2] * quat[2]) : z;
                }
            }
        }

        var hx = x * 0.5;
        var hy = y * 0.5;
        var hz = z * 0.5;

        var sx = Math.sin(hx);
        var sy = Math.sin(hy);
        var sz = Math.sin(hz);
        var cx = Math.cos(hx);
        var cy = Math.cos(hy);
        var cz = Math.cos(hz);

        var sysz = sy * sz;
        var cysz = cy * sz;
        var sycz = sy * cz;
        var cycz = cy * cz;

        qx = sx * cycz + cx * sysz;
        qy = cx * sycz - sx * cysz;
        qz = cx * cysz + sx * sycz;
        qw = cx * cycz - sx * sysz;

        this._lastEuler = true;
        this._lastEulerVals[0] = x;
        this._lastEulerVals[1] = y;
        this._lastEulerVals[2] = z;
    }

    this.vectors.rotationChanged = setVec(quat, qx, qy, qz, qw);
};

/**
 * Gets the scale component of the transform
 *
 * @method
 *
 * @return {Float32Array} the scale component of the transform
 */
Transform.prototype.getScale = function getScale () {
    return this.vectors.scale;
};

/**
 * Sets the scale component of the transform.
 *
 * @method
 *
 * @param {Number | null | undefined} x The x dimension of the scale
 * @param {Number | null | undefined} y The y dimension of the scale
 * @param {Number | null | undefined} z The z dimension of the scale
 *
 * @return {undefined} undefined
 */
Transform.prototype.setScale = function setScale (x, y, z) {
    this.vectors.scaleChanged = setVec(this.vectors.scale, x, y, z);
};

/**
 * Gets the align value of the transform
 *
 * @method
 *
 * @return {Float32Array} the align value of the transform
 */
Transform.prototype.getAlign = function getAlign () {
    return this.offsets.align;
};

/**
 * Sets the align value of the transform.
 *
 * @method
 *
 * @param {Number | null | undefined} x The x dimension of the align
 * @param {Number | null | undefined} y The y dimension of the align
 * @param {Number | null | undefined} z The z dimension of the align
 *
 * @return {undefined} undefined
 */
Transform.prototype.setAlign = function setAlign (x, y, z) {
    this.offsets.alignChanged = setVec(this.offsets.align, x, y, z != null ? z - 0.5 : z);
};

/**
 * Gets the mount point value of the transform.
 *
 * @method
 *
 * @return {Float32Array} the mount point of the transform
 */
Transform.prototype.getMountPoint = function getMountPoint () {
    return this.offsets.mountPoint;
};

/**
 * Sets the mount point value of the transform.
 *
 * @method
 *
 * @param {Number | null | undefined} x the x dimension of the mount point
 * @param {Number | null | undefined} y the y dimension of the mount point
 * @param {Number | null | undefined} z the z dimension of the mount point
 *
 * @return {undefined} undefined
 */
Transform.prototype.setMountPoint = function setMountPoint (x, y, z) {
    this.offsets.mountPointChanged = setVec(this.offsets.mountPoint, x, y, z != null ? z - 0.5 : z);
};

/**
 * Gets the origin of the transform.
 *
 * @method
 *
 * @return {Float32Array} the origin
 */
Transform.prototype.getOrigin = function getOrigin () {
    return this.offsets.origin;
};

/**
 * Sets the origin of the transform.
 *
 * @method
 *
 * @param {Number | null | undefined} x the x dimension of the origin
 * @param {Number | null | undefined} y the y dimension of the origin
 * @param {Number | null | undefined} z the z dimension of the origin
 *
 * @return {undefined} undefined
 */
Transform.prototype.setOrigin = function setOrigin (x, y, z) {
    this.offsets.originChanged = setVec(this.offsets.origin, x, y, z != null ? z - 0.5 : z);
};

/**
 * Calculates the world for this particular transform.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Transform.prototype.calculateWorldMatrix = function calculateWorldMatrix () {
    var nearestBreakPoint = this.parent;

    while (nearestBreakPoint && !nearestBreakPoint.isBreakPoint())
        nearestBreakPoint = nearestBreakPoint.parent;

    if (nearestBreakPoint) return multiply(this.global, nearestBreakPoint.getWorldTransform(), this.local);
    else {
        for (var i = 0; i < 16 ; i++) this.global[i] = this.local[i];
        return false;
    }
};


/**
 * Private function. Creates a transformation matrix from a Node's spec.
 *
 * @param {Node} node the node to create a transform for
 * @param {Transform} transform transform to apply
 *
 * @return {Boolean} whether or not the target array was changed
 */
function fromNode (node, transform) {
    var target = transform.getLocalTransform();
    var mySize = node.getSize();
    var vectors = transform.vectors;
    var offsets = transform.offsets;
    var parentSize = node.getParent().getSize();
    var changed = 0;

    var t00         = target[0];
    var t01         = target[1];
    var t02         = target[2];
    var t10         = target[4];
    var t11         = target[5];
    var t12         = target[6];
    var t20         = target[8];
    var t21         = target[9];
    var t22         = target[10];
    var t30         = target[12];
    var t31         = target[13];
    var t32         = target[14];
    var posX        = vectors.position[0];
    var posY        = vectors.position[1];
    var posZ        = vectors.position[2];
    var rotX        = vectors.rotation[0];
    var rotY        = vectors.rotation[1];
    var rotZ        = vectors.rotation[2];
    var rotW        = vectors.rotation[3];
    var scaleX      = vectors.scale[0];
    var scaleY      = vectors.scale[1];
    var scaleZ      = vectors.scale[2];
    var alignX      = offsets.align[0] * parentSize[0];
    var alignY      = offsets.align[1] * parentSize[1];
    var alignZ      = offsets.align[2] * parentSize[2];
    var mountPointX = offsets.mountPoint[0] * mySize[0];
    var mountPointY = offsets.mountPoint[1] * mySize[1];
    var mountPointZ = offsets.mountPoint[2] * mySize[2];
    var originX     = offsets.origin[0] * mySize[0];
    var originY     = offsets.origin[1] * mySize[1];
    var originZ     = offsets.origin[2] * mySize[2];

    var wx = rotW * rotX;
    var wy = rotW * rotY;
    var wz = rotW * rotZ;
    var xx = rotX * rotX;
    var yy = rotY * rotY;
    var zz = rotZ * rotZ;
    var xy = rotX * rotY;
    var xz = rotX * rotZ;
    var yz = rotY * rotZ;

    target[0] = (1 - 2 * (yy + zz)) * scaleX;
    target[1] = (2 * (xy + wz)) * scaleX;
    target[2] = (2 * (xz - wy)) * scaleX;
    target[3] = 0;
    target[4] = (2 * (xy - wz)) * scaleY;
    target[5] = (1 - 2 * (xx + zz)) * scaleY;
    target[6] = (2 * (yz + wx)) * scaleY;
    target[7] = 0;
    target[8] = (2 * (xz + wy)) * scaleZ;
    target[9] = (2 * (yz - wx)) * scaleZ;
    target[10] = (1 - 2 * (xx + yy)) * scaleZ;
    target[11] = 0;
    target[12] = alignX + posX - mountPointX + originX -
                 (target[0] * originX + target[4] * originY + target[8] * originZ);
    target[13] = alignY + posY - mountPointY + originY -
                 (target[1] * originX + target[5] * originY + target[9] * originZ);
    target[14] = alignZ + posZ - mountPointZ + originZ -
                 (target[2] * originX + target[6] * originY + target[10] * originZ);
    target[15] = 1;

    if (transform.calculatingWorldMatrix && transform.calculateWorldMatrix())
        changed |= Transform.WORLD_CHANGED;

    if (t00 !== target[0] ||
        t01 !== target[1] ||
        t02 !== target[2] ||
        t10 !== target[4] ||
        t11 !== target[5] ||
        t12 !== target[6] ||
        t20 !== target[8] ||
        t21 !== target[9] ||
        t22 !== target[10] ||
        t30 !== target[12] ||
        t31 !== target[13] ||
        t32 !== target[14]) changed |= Transform.LOCAL_CHANGED;

    return changed;
}

/**
 * Private function. Uses the parent transform, the node's spec, the node's size, and the parent's size
 * to calculate a final transform for the node. Returns true if the transform has changed.
 *
 * @private
 *
 * @param {Node} node the node to create a transform for
 * @param {Transform} transform transform to apply
 *
 * @return {Boolean} whether or not the transform changed
 */
function fromNodeWithParent (node, transform) {
    var target = transform.getLocalTransform();
    var parentMatrix = transform.parent.getLocalTransform();
    var mySize = node.getSize();
    var vectors = transform.vectors;
    var offsets = transform.offsets;
    var parentSize = node.getParent().getSize();
    var changed = false;

    // local cache of everything
    var t00         = target[0];
    var t01         = target[1];
    var t02         = target[2];
    var t10         = target[4];
    var t11         = target[5];
    var t12         = target[6];
    var t20         = target[8];
    var t21         = target[9];
    var t22         = target[10];
    var t30         = target[12];
    var t31         = target[13];
    var t32         = target[14];
    var p00         = parentMatrix[0];
    var p01         = parentMatrix[1];
    var p02         = parentMatrix[2];
    var p10         = parentMatrix[4];
    var p11         = parentMatrix[5];
    var p12         = parentMatrix[6];
    var p20         = parentMatrix[8];
    var p21         = parentMatrix[9];
    var p22         = parentMatrix[10];
    var p30         = parentMatrix[12];
    var p31         = parentMatrix[13];
    var p32         = parentMatrix[14];
    var posX        = vectors.position[0];
    var posY        = vectors.position[1];
    var posZ        = vectors.position[2];
    var rotX        = vectors.rotation[0];
    var rotY        = vectors.rotation[1];
    var rotZ        = vectors.rotation[2];
    var rotW        = vectors.rotation[3];
    var scaleX      = vectors.scale[0];
    var scaleY      = vectors.scale[1];
    var scaleZ      = vectors.scale[2];
    var alignX      = offsets.align[0] * parentSize[0];
    var alignY      = offsets.align[1] * parentSize[1];
    var alignZ      = offsets.align[2] * parentSize[2];
    var mountPointX = offsets.mountPoint[0] * mySize[0];
    var mountPointY = offsets.mountPoint[1] * mySize[1];
    var mountPointZ = offsets.mountPoint[2] * mySize[2];
    var originX     = offsets.origin[0] * mySize[0];
    var originY     = offsets.origin[1] * mySize[1];
    var originZ     = offsets.origin[2] * mySize[2];

    var wx = rotW * rotX;
    var wy = rotW * rotY;
    var wz = rotW * rotZ;
    var xx = rotX * rotX;
    var yy = rotY * rotY;
    var zz = rotZ * rotZ;
    var xy = rotX * rotY;
    var xz = rotX * rotZ;
    var yz = rotY * rotZ;

    var rs0 = (1 - 2 * (yy + zz)) * scaleX;
    var rs1 = (2 * (xy + wz)) * scaleX;
    var rs2 = (2 * (xz - wy)) * scaleX;
    var rs3 = (2 * (xy - wz)) * scaleY;
    var rs4 = (1 - 2 * (xx + zz)) * scaleY;
    var rs5 = (2 * (yz + wx)) * scaleY;
    var rs6 = (2 * (xz + wy)) * scaleZ;
    var rs7 = (2 * (yz - wx)) * scaleZ;
    var rs8 = (1 - 2 * (xx + yy)) * scaleZ;

    var tx = alignX + posX - mountPointX + originX - (rs0 * originX + rs3 * originY + rs6 * originZ);
    var ty = alignY + posY - mountPointY + originY - (rs1 * originX + rs4 * originY + rs7 * originZ);
    var tz = alignZ + posZ - mountPointZ + originZ - (rs2 * originX + rs5 * originY + rs8 * originZ);

    target[0] = p00 * rs0 + p10 * rs1 + p20 * rs2;
    target[1] = p01 * rs0 + p11 * rs1 + p21 * rs2;
    target[2] = p02 * rs0 + p12 * rs1 + p22 * rs2;
    target[3] = 0;
    target[4] = p00 * rs3 + p10 * rs4 + p20 * rs5;
    target[5] = p01 * rs3 + p11 * rs4 + p21 * rs5;
    target[6] = p02 * rs3 + p12 * rs4 + p22 * rs5;
    target[7] = 0;
    target[8] = p00 * rs6 + p10 * rs7 + p20 * rs8;
    target[9] = p01 * rs6 + p11 * rs7 + p21 * rs8;
    target[10] = p02 * rs6 + p12 * rs7 + p22 * rs8;
    target[11] = 0;
    target[12] = p00 * tx + p10 * ty + p20 * tz + p30;
    target[13] = p01 * tx + p11 * ty + p21 * tz + p31;
    target[14] = p02 * tx + p12 * ty + p22 * tz + p32;
    target[15] = 1;

    if (transform.calculatingWorldMatrix && transform.calculateWorldMatrix())
        changed |= Transform.WORLD_CHANGED;

    if (t00 !== target[0] ||
        t01 !== target[1] ||
        t02 !== target[2] ||
        t10 !== target[4] ||
        t11 !== target[5] ||
        t12 !== target[6] ||
        t20 !== target[8] ||
        t21 !== target[9] ||
        t22 !== target[10] ||
        t30 !== target[12] ||
        t31 !== target[13] ||
        t32 !== target[14]) changed |= Transform.LOCAL_CHANGED;

    return changed;
}

/**
 * private method to multiply two transforms.
 *
 * @method
 *
 * @param {Array} out The array to write the result to
 * @param {Array} a the left hand transform
 * @param {Array} b the right hand transform
 *
 * @return {undefined} undefined
 */
function multiply (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2],
        a10 = a[4], a11 = a[5], a12 = a[6],
        a20 = a[8], a21 = a[9], a22 = a[10],
        a30 = a[12], a31 = a[13], a32 = a[14];

    var changed = false;
    var res;

    // Cache only the current line of the second matrix
    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];

    res = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    changed = changed ? changed : out[0] === res;
    out[0] = res;

    res = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    changed = changed ? changed : out[1] === res;
    out[1] = res;

    res = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    changed = changed ? changed : out[2] === res;
    out[2] = res;

    out[3] = 0;

    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];

    res = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    changed = changed ? changed : out[4] === res;
    out[4] = res;

    res = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    changed = changed ? changed : out[5] === res;
    out[5] = res;

    res = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    changed = changed ? changed : out[6] === res;
    out[6] = res;

    out[7] = 0;

    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];

    res = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    changed = changed ? changed : out[8] === res;
    out[8] = res;

    res = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    changed = changed ? changed : out[9] === res;
    out[9] = res;

    res = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    changed = changed ? changed : out[10] === res;
    out[10] = res;

    out[11] = 0;

    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];

    res = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    changed = changed ? changed : out[12] === res;
    out[12] = res;

    res = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    changed = changed ? changed : out[13] === res;
    out[13] = res;

    res = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    changed = changed ? changed : out[14] === res;
    out[14] = res;

    out[15] = 1;

    return changed;
}

module.exports = Transform;

},{}],45:[function(require,module,exports){
(function (process){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var PathUtils = require('./Path');
var Transform = require('./Transform');
var Dispatch = require('./Dispatch');
var System = require('./System');
var assert = require('../utilities/assert');

/**
 * The transform class is responsible for calculating the transform of a particular
 * node from the data on the node and its parent
 *
 * @constructor {TransformSystem}
 */
function TransformSystem () {
    System.call(this);
}

TransformSystem.prototype = Object.create(System.prototype);
TransformSystem.prototype.constructor = TransformSystem;

/**
 * registers a new Transform for the given path. This transform will be updated
 * when the TransformSystem updates.
 *
 * @method registerTransformAtPath
 * @return {undefined} undefined
 *
 * @param {String} path for the transform to be registered to.
 * @param {Transform | undefined} transform optional transform to register.
 */
TransformSystem.prototype.registerTransformAtPath = function registerTransformAtPath (path, transform) {
    if (process.env.NODE_ENV === 'development') {
        assert(typeof path === 'string', 'path needs to be a string');
        assert(transform === undefined || transform.constructor === Transform, 'transform needs to be a Transform instance or undefined');
    }

    if (!PathUtils.depth(path))
        return this.insert(path, transform ? transform : new Transform());

    var parent = this.get(PathUtils.parent(path));

    if (process.env.NODE_ENV === 'development')
        assert(parent, 'transform needs to be registered at path ' + PathUtils.parent(path));

    if (transform) transform.setParent(parent);

    this.insert(path, transform ? transform : new Transform(parent));
};

/**
 * deregisters a transform registered at the given path.
 *
 * @method deregisterTransformAtPath
 * @return {void}
 *
 * @param {String} path at which to register the transform
 */
TransformSystem.prototype.deregisterTransformAtPath = TransformSystem.prototype.remove;

/**
 * Method which will make the transform currently stored at the given path a breakpoint.
 * A transform being a breakpoint means that both a local and world transform will be calculated
 * for that point. The local transform being the concatinated transform of all ancestor transforms up
 * until the nearest breakpoint, and the world being the concatinated transform of all ancestor transforms.
 * This method throws if no transform is at the provided path.
 *
 * @method
 *
 * @param {String} path The path at which to turn the transform into a breakpoint
 *
 * @return {undefined} undefined
 */
TransformSystem.prototype.makeBreakPointAt = function makeBreakPointAt (path) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof path === 'string', 'path needs to be a string');
    var transform = this.get(path);
    if (process.env.NODE_ENV === 'development')
        assert(transform, 'transform needs to be registered at path ' + path);
    transform.setBreakPoint();
};

/**
 * Method that will make the transform at this location calculate a world matrix.
 *
 * @method
 *
 * @param {String} path The path at which to make the transform calculate a world matrix
 *
 * @return {undefined} undefined
 */
TransformSystem.prototype.makeCalculateWorldMatrixAt = function makeCalculateWorldMatrixAt (path) {
    if (process.env.NODE_ENV === 'development')
        assert(typeof path === 'string', 'path needs to be a string');
    var transform = this.get(path);
    if (process.env.NODE_ENV === 'development')
        assert(transform, 'transform needs to be registered at path ' + path);
    transform.setCalculateWorldMatrix();
};

/**
 * update is called when the transform system requires an update.
 * It traverses the transform array and evaluates the necessary transforms
 * in the scene graph with the information from the corresponding node
 * in the scene graph
 *
 * @method update
 *
 * @return {undefined} undefined
 */
TransformSystem.prototype.update = function update () {
    var transforms = this.getItems();
    var paths = this.getPaths();
    var transform;
    var changed;
    var node;
    var vectors;
    var offsets;
    var components;
    var needsRecalc = false;

    for (var i = 0, len = transforms.length ; i < len ; i++) {
        node = Dispatch.getNode(paths[i]);
        if (!node) continue;
        components = node.getComponents();
        transform = transforms[i];
        vectors = transform.vectors;
        offsets = transform.offsets;

        needsRecalc =
            offsets.alignChanged ||
            offsets.mountPointChanged ||
            offsets.originChanged ||
            vectors.positionChanged ||
            vectors.rotationChanged ||
            vectors.scaleChanged ||
            (transform.parent && transform.parent._needsRecalc) ||
            transform._dirtyFromSizeChange;

        transform._dirtyFromSizeChange = false;
        transform._needsRecalc = needsRecalc;

        if (offsets.alignChanged) alignChanged(node, components, offsets);
        if (offsets.mountPointChanged) mountPointChanged(node, components, offsets);
        if (offsets.originChanged) originChanged(node, components, offsets);
        if (vectors.positionChanged) positionChanged(node, components, vectors);
        if (vectors.rotationChanged) rotationChanged(node, components, vectors);
        if (vectors.scaleChanged) scaleChanged(node, components, vectors);

        if (needsRecalc) {
            if ((changed = transform.calculate(node))) {
                transformChanged(node, components, transform);
                if (changed & Transform.LOCAL_CHANGED) localTransformChanged(node, components, transform.getLocalTransform());
                if (changed & Transform.WORLD_CHANGED) worldTransformChanged(node, components, transform.getWorldTransform());
            }
        }
    }
};

/**
 * Private method to call when align changes. Triggers 'onAlignChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to call onAlignChange if necessary
 * @param {Array} components the components on which to call onAlignChange if necessary
 * @param {Object} offsets the set of offsets from the transform
 *
 * @return {undefined} undefined
 */
function alignChanged (node, components, offsets) {
    var x = offsets.align[0];
    var y = offsets.align[1];
    var z = offsets.align[2];
    if (node.onAlignChange) node.onAlignChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onAlignChange)
            components[i].onAlignChange(x, y, z);
    offsets.alignChanged = false;
}

/**
 * Private method to call when MountPoint changes. Triggers 'onMountPointChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Object} offsets the set of offsets from the transform
 *
 * @return {undefined} undefined
 */
function mountPointChanged (node, components, offsets) {
    var x = offsets.mountPoint[0];
    var y = offsets.mountPoint[1];
    var z = offsets.mountPoint[2];
    if (node.onMountPointChange) node.onMountPointChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onMountPointChange)
            components[i].onMountPointChange(x, y, z);
    offsets.mountPointChanged = false;
}

/**
 * Private method to call when Origin changes. Triggers 'onOriginChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Object} offsets the set of offsets from the transform
 *
 * @return {undefined} undefined
 */
function originChanged (node, components, offsets) {
    var x = offsets.origin[0];
    var y = offsets.origin[1];
    var z = offsets.origin[2];
    if (node.onOriginChange) node.onOriginChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onOriginChange)
            components[i].onOriginChange(x, y, z);
    offsets.originChanged = false;
}

/**
 * Private method to call when Position changes. Triggers 'onPositionChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Object} vectors the set of vectors from the transform
 *
 * @return {undefined} undefined
 */
function positionChanged (node, components, vectors) {
    var x = vectors.position[0];
    var y = vectors.position[1];
    var z = vectors.position[2];
    if (node.onPositionChange) node.onPositionChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onPositionChange)
            components[i].onPositionChange(x, y, z);
    vectors.positionChanged = false;
}

/**
 * Private method to call when Rotation changes. Triggers 'onRotationChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Object} vectors the set of vectors from the transform
 *
 * @return {undefined} undefined
 */
function rotationChanged (node, components, vectors) {
    var x = vectors.rotation[0];
    var y = vectors.rotation[1];
    var z = vectors.rotation[2];
    var w = vectors.rotation[3];
    if (node.onRotationChange) node.onRotationChange(x, y, z, w);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onRotationChange)
            components[i].onRotationChange(x, y, z, w);
    vectors.rotationChanged = false;
}

/**
 * Private method to call when Scale changes. Triggers 'onScaleChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Object} vectors the set of vectors from the transform
 *
 * @return {undefined} undefined
 */
function scaleChanged (node, components, vectors) {
    var x = vectors.scale[0];
    var y = vectors.scale[1];
    var z = vectors.scale[2];
    if (node.onScaleChange) node.onScaleChange(x, y, z);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onScaleChange)
            components[i].onScaleChange(x, y, z);
    vectors.scaleChanged = false;
}

/**
 * Private method to call when either the Local or World Transform changes.
 * Triggers 'onTransformChange' methods on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Transform} transform the transform class that changed
 *
 * @return {undefined} undefined
 */
function transformChanged (node, components, transform) {
    if (node.onTransformChange) node.onTransformChange(transform);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onTransformChange)
            components[i].onTransformChange(transform);
}

/**
 * Private method to call when the local transform changes. Triggers 'onLocalTransformChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Array} transform the local transform
 *
 * @return {undefined} undefined
 */
function localTransformChanged (node, components, transform) {
    if (node.onLocalTransformChange) node.onLocalTransformChange(transform);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onLocalTransformChange)
            components[i].onLocalTransformChange(transform);
}

/**
 * Private method to call when the world transform changes. Triggers 'onWorldTransformChange' methods
 * on the node and all of the node's components
 *
 * @method
 * @private
 *
 * @param {Node} node the node on which to trigger a change event if necessary
 * @param {Array} components the components on which to trigger a change event if necessary
 * @param {Array} transform the world transform
 *
 * @return {undefined} undefined
 */
function worldTransformChanged (node, components, transform) {
    if (node.onWorldTransformChange) node.onWorldTransformChange(transform);
    for (var i = 0, len = components.length ; i < len ; i++)
        if (components[i] && components[i].onWorldTransformChange)
            components[i].onWorldTransformChange(transform);
}

module.exports = new TransformSystem();

}).call(this,require('_process'))

},{"../utilities/assert":70,"./Dispatch":33,"./Path":39,"./System":43,"./Transform":44,"_process":1}],46:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var EventEmitter = require('../utilities/EventEmitter');
var TransformSystem = require('../core/TransformSystem');
var OpacitySystem = require('../core/OpacitySystem');
var Commands = require('../core/Commands');
var Size = require('../core/Size');

/**
 * A DOMElement is a component that can be added to a Node with the
 * purpose of sending draw commands to the renderer. Renderables send draw commands
 * to through their Nodes to the Compositor where they are acted upon.
 *
 * @class DOMElement
 *
 * @param {Node} [node]                 The Node to which the `DOMElement`
 *                                      renderable should be attached to.
 * @param {Object} options              Initial options used for instantiating
 *                                      the Node.
 * @param {Object} options.style        CSS style that should be added to
 *                                      the actual DOMElement on the initial draw.
 * @param {Object} options.attributes   Element attributes that should be added to
 *                                      the actual DOMElement.
 * @param {String} options.id           String to be applied as 'id' of the actual
 *                                      DOMElement.
 * @param {String} options.content      String to be applied as the content of the
 *                                      actual DOMElement.
 */
function DOMElement(node, options) {
    if (node && node.constructor === Object) {
        options = node;
        node = null;
    }

    options = options || {};

    this._changeQueue = [];

    this._requestingUpdate = false;
    this._renderSized = false;
    this._requestRenderSize = false;

    this._UIEvents = [];
    this._classes = ['famous-dom-element'].concat(options.classes);
    this._requestingEventListeners = [];

    if (options.properties)
        console.warn('DOMElement properties have been renamed to style');

    this._style = options.properties || options.style || {};
    this._attributes = options.attributes || {};

    if (options.id != null)
        this._attributes.id = options.id;

    this._content = options.content || '';
    this._tagName = options.tagName || 'div';
    this._renderSize = [0, 0, 0];

    this._node = null;
    this._id = null;

    this._events = new EventEmitter();

    if (options.documentFlow != null)
        this.documentFlow(options.documentFlow);

    if (node) node.addComponent(this);
}

/**
 * Serializes the state of the DOMElement.
 *
 * @method
 *
 * @return {Object} serialized interal state
 */
DOMElement.prototype.getValue = function getValue() {
    return {
        classes: this._classes,
        style: this._style,
        attributes: this._attributes,
        content: this._content,
        id: this._attributes.id,
        tagName: this._tagName
    };
};

/**
 * Method to be invoked by the node as soon as an update occurs. This allows
 * the DOMElement renderable to dynamically react to state changes on the Node.
 *
 * This flushes the internal draw command queue by sending individual commands
 * to the node using `sendDrawCommand`.
 *
 * @method
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onUpdate = function onUpdate () {
    var node = this._node;
    var queue = this._changeQueue;
    var len = queue.length;

    if (len && node) {
        node.sendDrawCommand(Commands.WITH);
        node.sendDrawCommand(node.getLocation());

        while (len--) node.sendDrawCommand(queue.shift());
        if (this._requestRenderSize) {
            node.sendDrawCommand(Commands.DOM_RENDER_SIZE);
            node.sendDrawCommand(node.getLocation());
            this._requestRenderSize = false;
        }

    }

    this._requestingUpdate = false;
};

/**
 * Method to be invoked by the Node as soon as the node (or any of its
 * ancestors) is being mounted.
 *
 * @method onMount
 *
 * @param {Node} node      Parent node to which the component should be added.
 * @param {String} id      Path at which the component (or node) is being
 *                          attached. The path is being set on the actual
 *                          DOMElement as a `data-fa-path`-attribute.
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onMount = function onMount(node, id) {
    var i;
    var len;
    var key;

    this._node = node;
    this._id = id;
    this._UIEvents = node.getUIEvents().slice(0);

    this._changeQueue.push(Commands.INIT_DOM, this._tagName);

    TransformSystem.makeBreakPointAt(node.getLocation());
    OpacitySystem.makeBreakPointAt(node.getLocation());

    this._inDraw = true;
    this._initialized = true;

    this.onSizeModeChange.apply(this, node.getSizeMode());
    this.setAttribute('data-fa-path', node.getLocation());

    this.onTransformChange(TransformSystem.get(this._node.getLocation()));
    this.onOpacityChange(OpacitySystem.get(this._node.getLocation()));

    for (i = 0, len = this._classes.length; i < len; i++)
        this.addClass(this._classes[i]);

    for (key in this._attributes)
        this.setAttribute(key, this._attributes[key]);

    for (key in this._style)
        this.setStyle(key, this._style[key]);

    this.setContent(this._content);

    for (i = 0, len = this._UIEvents.length; i < len; i++)
        this.onAddUIEvent(this._UIEvents[i]);

    this._inDraw = false;

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Method to be invoked by the Node as soon as the node is being dismounted
 * either directly or by dismounting one of its ancestors.
 *
 * @method
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onDismount = function onDismount() {
    this.setStyle('display', 'none');
    this.setAttribute('data-fa-path', '');

    this.onUpdate();
    this._initialized = false;
};

/**
 * Method to be invoked by the node as soon as the DOMElement is being shown.
 * This results into the DOMElement setting the `display` property to `block`
 * and therefore visually showing the corresponding DOMElement (again).
 *
 * @method
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onShow = function onShow() {
    this.setStyle('display', 'block');
};

/**
 * Method to be invoked by the node as soon as the DOMElement is being hidden.
 * This results into the DOMElement setting the `display` property to `none`
 * and therefore visually hiding the corresponding DOMElement (again).
 *
 * @method
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onHide = function onHide() {
    this.setStyle('display', 'none');
};

/**
 * Method that removes the absolute positioning and DOM styling on the DOMElement.
 *
 * @method
 *
 * @param {Boolean} onoff whether or not the DOMElement should have document flow
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.documentFlow = function documentFlow(onoff) {
    if (onoff) this.removeClass('famous-dom-element');
    else this.addClass('famous-dom-element');
    return this;
};

/**
 * Method to be invoked by the node as soon as the transform matrix associated
 * with the node changes. The DOMElement will react to transform changes by sending
 * `CHANGE_TRANSFORM` commands to the `DOMRenderer`.
 *
 * @method
 *
 * @param {Float32Array} transform The final transform matrix
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onTransformChange = function onTransformChange (transform) {
    this._changeQueue.push(Commands.CHANGE_TRANSFORM);
    transform = transform.getLocalTransform();

    for (var i = 0, len = transform.length ; i < len ; i++)
        this._changeQueue.push(transform[i]);

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Method to be invoked by the node as soon as its computed size changes.
 *
 * @method
 *
 * @param {Number} x width of the Node the DOMElement is attached to
 * @param {Number} y height of the Node the DOMElement is attached to
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.onSizeChange = function onSizeChange(x, y) {
    var sizeMode = this._node.getSizeMode();
    var sizedX = sizeMode[0] !== Size.RENDER;
    var sizedY = sizeMode[1] !== Size.RENDER;
    if (this._initialized)
        this._changeQueue.push(Commands.CHANGE_SIZE,
            sizedX ? x : sizedX,
            sizedY ? y : sizedY);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};

/**
 * Method to be invoked by the node as soon as its opacity changes
 *
 * @method
 *
 * @param {Number} opacity The new opacity, as a scalar from 0 to 1
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.onOpacityChange = function onOpacityChange(opacity) {
    opacity = opacity.getLocalOpacity();
    return this.setStyle('opacity', opacity);
};

/**
 * Method to be invoked by the node as soon as a new UIEvent is being added.
 * This results into an `ADD_EVENT_LISTENER` command being sent.
 *
 * @param {String} uiEvent uiEvent to be subscribed to (e.g. `click`)
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onAddUIEvent = function onAddUIEvent(uiEvent) {
    if (this._UIEvents.indexOf(uiEvent) === -1) {
        this._subscribe(uiEvent);
        this._UIEvents.push(uiEvent);
    }
    else if (this._inDraw) {
        this._subscribe(uiEvent);
    }
    return this;
};

/**
 * Method to be invoked by the node as soon as a UIEvent is removed from
 * the node.  This results into an `UNSUBSCRIBE` command being sent.
 *
 * @param {String} UIEvent UIEvent to be removed (e.g. `mousedown`)
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onRemoveUIEvent = function onRemoveUIEvent(UIEvent) {
    var index = this._UIEvents.indexOf(UIEvent);
    if (index !== -1) {
        this._unsubscribe(UIEvent);
        this._UIEvents.splice(index, 1);
    }
    else if (this._inDraw) {
        this._unsubscribe(UIEvent);
    }
    return this;
};

/**
 * Appends an `SUBSCRIBE` command to the command queue.
 *
 * @method
 * @private
 *
 * @param {String} uiEvent Event type (e.g. `click`)
 *
 * @return {undefined} undefined
 */
DOMElement.prototype._subscribe = function _subscribe (uiEvent) {
    if (this._initialized) {
        this._changeQueue.push(Commands.SUBSCRIBE, uiEvent);
    }

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * When running in a worker, the browser's default action for specific events
 * can't be prevented on a case by case basis (via `e.preventDefault()`).
 * Instead this function should be used to register an event to be prevented by
 * default.
 *
 * @method
 *
 * @param  {String} uiEvent     UI Event (e.g. wheel) for which to prevent the
 *                              browser's default action (e.g. form submission,
 *                              scrolling)
 * @return {undefined}          undefined
 */
DOMElement.prototype.preventDefault = function preventDefault (uiEvent) {
    if (this._initialized) {
        this._changeQueue.push(Commands.PREVENT_DEFAULT, uiEvent);
    }
    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Opposite of {@link DOMElement#preventDefault}. No longer prevent the
 * browser's default action on subsequent events of this type.
 *
 * @method
 *
 * @param  {type} uiEvent       UI Event previously registered using
 *                              {@link DOMElement#preventDefault}.
 * @return {undefined}          undefined
 */
DOMElement.prototype.allowDefault = function allowDefault (uiEvent) {
    if (this._initialized) {
        this._changeQueue.push(Commands.ALLOW_DEFAULT, uiEvent);
    }

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Appends an `UNSUBSCRIBE` command to the command queue.
 *
 * @method
 * @private
 *
 * @param {String} UIEvent Event type (e.g. `click`)
 *
 * @return {undefined} undefined
 */
DOMElement.prototype._unsubscribe = function _unsubscribe (UIEvent) {
    if (this._initialized) {
        this._changeQueue.push(Commands.UNSUBSCRIBE, UIEvent);
    }

    if (!this._requestingUpdate) this._requestUpdate();
};

/**
 * Method to be invoked by the node as soon as the underlying size mode
 * changes. This results into the size being fetched from the node in
 * order to update the actual, rendered size.
 *
 * @method
 *
 * @param {Number} x the sizing mode in use for determining size in the x direction
 * @param {Number} y the sizing mode in use for determining size in the y direction
 * @param {Number} z the sizing mode in use for determining size in the z direction
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onSizeModeChange = function onSizeModeChange(x, y, z) {
    if (x === Size.RENDER || y === Size.RENDER || z === Size.RENDER) {
        this._renderSized = true;
        this._requestRenderSize = true;
    }
    var size = this._node.getSize();
    this.onSizeChange(size[0], size[1]);
};

/**
 * Method to be retrieve the rendered size of the DOM element that is
 * drawn for this node.
 *
 * @method
 *
 * @return {Array} size of the rendered DOM element in pixels
 */
DOMElement.prototype.getRenderSize = function getRenderSize() {
    return this._renderSize;
};

/**
 * Method to have the component request an update from its Node
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
DOMElement.prototype._requestUpdate = function _requestUpdate() {
    if (!this._requestingUpdate && this._id != null) {
        this._node.requestUpdate(this._id);
        this._requestingUpdate = true;
    }
};

/**
 * Sets the id attribute of the DOMElement.
 *
 * @method
 *
 * @param {String} id New id to be set
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.setId = function setId (id) {
    this.setAttribute('id', id);
    return this;
};

/**
 * Adds a new class to the internal class list of the underlying Element in the
 * DOM.
 *
 * @method
 *
 * @param {String} value New class name to be added
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.addClass = function addClass (value) {
    if (this._classes.indexOf(value) < 0) {
        if (this._initialized) this._changeQueue.push(Commands.ADD_CLASS, value);
        this._classes.push(value);
        if (!this._requestingUpdate) this._requestUpdate();
        if (this._renderSized) this._requestRenderSize = true;
        return this;
    }

    if (this._inDraw) {
        if (this._initialized) this._changeQueue.push(Commands.ADD_CLASS, value);
        if (!this._requestingUpdate) this._requestUpdate();
    }
    return this;
};

/**
 * Removes a class from the DOMElement's classList.
 *
 * @method
 *
 * @param {String} value Class name to be removed
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.removeClass = function removeClass (value) {
    var index = this._classes.indexOf(value);

    if (index < 0) return this;

    this._changeQueue.push(Commands.REMOVE_CLASS, value);

    this._classes.splice(index, 1);

    if (!this._requestingUpdate) this._requestUpdate();
    return this;
};


/**
 * Checks if the DOMElement has the passed in class.
 *
 * @method
 *
 * @param {String} value The class name
 *
 * @return {Boolean} Boolean value indicating whether the passed in class name is in the DOMElement's class list.
 */
DOMElement.prototype.hasClass = function hasClass (value) {
    return this._classes.indexOf(value) !== -1;
};

/**
 * Sets an attribute of the DOMElement.
 *
 * @method
 *
 * @param {String} name Attribute key (e.g. `src`)
 * @param {String} value Attribute value (e.g. `http://famo.us`)
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.setAttribute = function setAttribute (name, value) {
    if (this._attributes[name] !== value || this._inDraw) {
        this._attributes[name] = value;
        if (this._initialized) this._changeQueue.push(Commands.CHANGE_ATTRIBUTE, name, value);
        if (!this._requestUpdate) this._requestUpdate();
    }

    return this;
};

/**
 * Sets a CSS property.
 *
 * @chainable
 *
 * @param {String} name  Name of the CSS rule (e.g. `background-color`)
 * @param {String} value Value of CSS property (e.g. `red`)
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.setStyle = function setStyle (name, value) {
    if (this._style[name] !== value || this._inDraw) {
        this._style[name] = value;
        if (this._initialized) this._changeQueue.push(Commands.CHANGE_STYLE, name, value);
        if (!this._requestingUpdate) this._requestUpdate();
        if (this._renderSized) this._requestRenderSize = true;
    }

    return this;
};

/**
 * @deprecated Use {@link DOMElement#setStyle} instead!
 */
DOMElement.prototype.setProperty = function () {
    console.warn(
        'DOMElement#setProperty has been deprecated, use ' +
        'DOMElement#setStyle instead.'
    );
    return this.setStyle.apply(this, arguments);
};

/**
 * Sets the content of the DOMElement. This is using `innerHTML`, escaping user
 * generated content is therefore essential for security purposes.
 *
 * @method
 *
 * @param {String} content Content to be set using `.innerHTML = ...`
 *
 * @return {DOMElement} this
 */
DOMElement.prototype.setContent = function setContent (content) {
    if (this._content !== content || this._inDraw) {
        this._content = content;
        if (this._initialized) this._changeQueue.push(Commands.CHANGE_CONTENT, content);
        if (!this._requestingUpdate) this._requestUpdate();
        if (this._renderSized) this._requestRenderSize = true;
    }

    return this;
};

/**
 * Subscribes to a DOMElement using.
 *
 * @method on
 *
 * @param {String} event       The event type (e.g. `click`).
 * @param {Function} listener  Handler function for the specified event type
 *                              in which the payload event object will be
 *                              passed into.
 *
 * @return {Function} A function to call if you want to remove the callback
 */
DOMElement.prototype.on = function on (event, listener) {
    return this._events.on(event, listener);
};

/**
 * Function to be invoked by the Node whenever an event is being received.
 * There are two different ways to subscribe for those events:
 *
 * 1. By overriding the onReceive method (and possibly using `switch` in order
 *     to differentiate between the different event types).
 * 2. By using DOMElement and using the built-in EventEmitter.
 *
 * @method
 *
 * @param {String} event Event type (e.g. `click`)
 * @param {Object} payload Event object.
 *
 * @return {undefined} undefined
 */
DOMElement.prototype.onReceive = function onReceive (event, payload) {
    switch (event) {
        case 'resize':
        this._renderSize[0] = payload.val[0];
        this._renderSize[1] = payload.val[1];
        if (!this._requestingUpdate) this._requestUpdate();
    }

    this._events.trigger(event, payload);
};

module.exports = DOMElement;

},{"../core/Commands":32,"../core/OpacitySystem":38,"../core/Size":41,"../core/TransformSystem":45,"../utilities/EventEmitter":69}],47:[function(require,module,exports){
(function (process){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var ElementCache = require('./ElementCache');
var math = require('./Math');
var PathUtils = require('../core/Path');
var vendorPrefix = require('../utilities/vendorPrefix');
var assert = require('../utilities/assert');
var EventEmitter = require('../utilities/EventEmitter');
var eventMap = require('./events/EventMap');

var TRANSFORM = null;

/**
 * DOMRenderer is a class responsible for adding elements
 * to the DOM and writing to those elements.
 * There is a DOMRenderer per context, represented as an
 * element and a selector. It is instantiated in the
 * context class.
 *
 * @class DOMRenderer
 *
 * @param {HTMLElement} element an element.
 * @param {String} selector the selector of the element.
 * @param {Compositor} compositor the compositor controlling the renderer
 */
function DOMRenderer (element, selector, compositor) {
    var _this = this;

    element.classList.add('famous-dom-renderer');

    TRANSFORM = TRANSFORM || vendorPrefix('transform');
    this._compositor = compositor; // a reference to the compositor

    this._target = null; // a register for holding the current
                         // element that the Renderer is operating
                         // upon

    this._parent = null; // a register for holding the parent
                         // of the target

    this._path = null; // a register for holding the path of the target
                       // this register must be set first, and then
                       // children, target, and parent are all looked
                       // up from that.

    this._children = []; // a register for holding the children of the
                         // current target.

     this._insertElEventEmitter = new EventEmitter();
     this._removeElEventEmitter = new EventEmitter();

    this._root = new ElementCache(element, selector); // the root
                                                      // of the dom tree that this
                                                      // renderer is responsible
                                                      // for

    this._boundTriggerEvent = function (ev) {
        return _this._triggerEvent(ev);
    };

    this._selector = selector;

    this._elements = {};

    this._elements[selector] = this._root;

    this.perspectiveTransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
    this._VPtransform = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);

    this._lastEv = null;
}


/**
 * Attaches an EventListener to the element associated with the passed in path.
 * Prevents the default browser action on all subsequent events if
 * `preventDefault` is truthy.
 * All incoming events will be forwarded to the compositor by invoking the
 * `sendEvent` method.
 * Delegates events if possible by attaching the event listener to the context.
 *
 * @method
 *
 * @param {String} type DOM event type (e.g. click, mouseover).
 * @param {Boolean} preventDefault Whether or not the default browser action should be prevented.
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.subscribe = function subscribe(type) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');
    this._listen(type);
    this._target.subscribe[type] = true;
};

/**
 * Used to preventDefault if an event of the specified type is being emitted on
 * the currently loaded target.
 *
 * @method
 *
 * @param  {String} type    The type of events that should be prevented.
 * @return {undefined}      undefined
 */
DOMRenderer.prototype.preventDefault = function preventDefault(type) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');
    this._listen(type);
    this._target.preventDefault[type] = true;
};

/**
 * Used to undo a previous call to preventDefault. No longer `preventDefault`
 * for this event on the loaded target.
 *
 * @method
 * @private
 *
 * @param  {String} type    The event type that should no longer be affected by
 *                          `preventDefault`.
 * @return {undefined}      undefined
 */
DOMRenderer.prototype.allowDefault = function allowDefault(type) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');
    this._listen(type);
    this._target.preventDefault[type] = false;
};

/**
 * Internal helper function used for adding an event listener for the the
 * currently loaded ElementCache.
 *
 * If the event can be delegated as specified in the {@link EventMap}, the
 * bound {@link _triggerEvent} function will be added as a listener on the
 * root element. Otherwise, the listener will be added directly to the target
 * element.
 *
 * @private
 * @method
 *
 * @param  {String} type    The event type to listen to (e.g. click).
 * @return {undefined}      undefined
 */
DOMRenderer.prototype._listen = function _listen(type) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');

    if (
        !this._target.listeners[type] && !this._root.listeners[type]
    ) {
        // FIXME Add to content DIV if available
        var target = eventMap[type][1] ? this._root : this._target;
        target.listeners[type] = this._boundTriggerEvent;
        target.element.addEventListener(type, this._boundTriggerEvent);
    }
};

/**
 * Unsubscribes from all events that are of the specified type.
 *
 * @method
 *
 * @param {String} type DOM event type (e.g. click, mouseover).
 * @return {undefined} undefined
 */
DOMRenderer.prototype.unsubscribe = function unsubscribe(type) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');
    this._target.subscribe[type] = false;
};

/**
 * Function to be added using `addEventListener` to the corresponding
 * DOMElement.
 *
 * @method
 * @private
 *
 * @param {Event} ev DOM Event payload
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype._triggerEvent = function _triggerEvent(ev) {
    if (this._lastEv === ev) return;

    // Use ev.path, which is an array of Elements (polyfilled if needed).
    var evPath = ev.path ? ev.path : _getPath(ev);
    // First element in the path is the element on which the event has actually
    // been emitted.
    for (var i = 0; i < evPath.length; i++) {
        // Skip nodes that don't have a dataset property or data-fa-path
        // attribute.
        if (!evPath[i].dataset) continue;
        var path = evPath[i].dataset.faPath;
        if (!path) continue;

        // Optionally preventDefault. This needs forther consideration and
        // should be optional. Eventually this should be a separate command/
        // method.
        if (this._elements[path].preventDefault[ev.type]) {
            ev.preventDefault();
        }

        // Stop further event propogation and path traversal as soon as the
        // first ElementCache subscribing for the emitted event has been found.
        if (this._elements[path] && this._elements[path].subscribe[ev.type]) {
            this._lastEv = ev;

            var NormalizedEventConstructor = eventMap[ev.type][0];

            // Finally send the event to the Worker Thread through the
            // compositor.
            this._compositor.sendEvent(path, ev.type, new NormalizedEventConstructor(ev));

            break;
        }
    }
};


/**
 * getSizeOf gets the dom size of a particular DOM element.  This is
 * needed for render sizing in the scene graph.
 *
 * @method
 *
 * @param {String} path path of the Node in the scene graph
 *
 * @return {Array} a vec3 of the offset size of the dom element
 */
DOMRenderer.prototype.getSizeOf = function getSizeOf(path) {
    var element = this._elements[path];
    if (!element) return null;

    var res = {val: element.size};
    this._compositor.sendEvent(path, 'resize', res);
    return res;
};

function _getPath(ev) {
    // TODO move into _triggerEvent, avoid object allocation
    var path = [];
    var node = ev.target;
    while (node !== document.body) {
        path.push(node);
        node = node.parentNode;
    }
    return path;
}

/**
 * Executes the retrieved draw commands. Draw commands only refer to the
 * cross-browser normalized `transform` property.
 *
 * @method
 *
 * @param {Object} renderState description
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.draw = function draw(renderState) {
    if (renderState.perspectiveDirty) {
        this.perspectiveDirty = true;

        this.perspectiveTransform[0] = renderState.perspectiveTransform[0];
        this.perspectiveTransform[1] = renderState.perspectiveTransform[1];
        this.perspectiveTransform[2] = renderState.perspectiveTransform[2];
        this.perspectiveTransform[3] = renderState.perspectiveTransform[3];

        this.perspectiveTransform[4] = renderState.perspectiveTransform[4];
        this.perspectiveTransform[5] = renderState.perspectiveTransform[5];
        this.perspectiveTransform[6] = renderState.perspectiveTransform[6];
        this.perspectiveTransform[7] = renderState.perspectiveTransform[7];

        this.perspectiveTransform[8] = renderState.perspectiveTransform[8];
        this.perspectiveTransform[9] = renderState.perspectiveTransform[9];
        this.perspectiveTransform[10] = renderState.perspectiveTransform[10];
        this.perspectiveTransform[11] = renderState.perspectiveTransform[11];

        this.perspectiveTransform[12] = renderState.perspectiveTransform[12];
        this.perspectiveTransform[13] = renderState.perspectiveTransform[13];
        this.perspectiveTransform[14] = renderState.perspectiveTransform[14];
        this.perspectiveTransform[15] = renderState.perspectiveTransform[15];
    }

    if (renderState.viewDirty || renderState.perspectiveDirty) {
        math.multiply(this._VPtransform, this.perspectiveTransform, renderState.viewTransform);
        this._root.element.style[TRANSFORM] = this._stringifyMatrix(this._VPtransform);
    }
};

/**
 * Finds and sets the parent of the currently loaded element (path).
 *
 * @method
 * @private
 *
 * @return {ElementCache} Parent element.
 */
DOMRenderer.prototype.findParent = function findParent () {
    if (process.env.NODE_ENV === 'development')
        assert(this._path, 'No path loaded');

    var path = this._path;
    var parent;

    while (!parent && path.length) {
        path = path.substring(0, path.lastIndexOf('/'));
        parent = this._elements[path];
    }

    this._parent = parent;
    return parent;
};

/**
 * Loads the passed in path into the DOMRenderer.
 *
 * @method
 *
 * @param {String} path Path to be loaded
 *
 * @return {String} Loaded path
 */
DOMRenderer.prototype.loadPath = function loadPath (path) {
    this._path = path;
    this._target = this._elements[this._path];
    return this._path;
};

/**
 * Finds children of a parent element that are descendents of a inserted element in the scene
 * graph. Appends those children to the inserted element.
 *
 * @method resolveChildren
 * @return {void}
 *
 * @param {HTMLElement} element the inserted element
 * @param {HTMLElement} parent the parent of the inserted element
 */
DOMRenderer.prototype.resolveChildren = function resolveChildren (element, parent) {
    var i = 0;
    var childNode;
    var path = this._path;
    var childPath;

    while ((childNode = parent.childNodes[i])) {
        if (!childNode.dataset) {
            i++;
            continue;
        }
        childPath = childNode.dataset.faPath;
        if (!childPath) {
            i++;
            continue;
        }
        if (PathUtils.isDescendentOf(childPath, path)) element.appendChild(childNode);
        else i++;
    }
};

/**
 * Inserts a DOMElement at the currently loaded path, assuming no target is
 * loaded. Only one DOMElement can be associated with each path.
 *
 * @method
 *
 * @param {String} tagName Tag name (capitalization will be normalized).
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.insertEl = function insertEl (tagName) {
    this.findParent();

    if (process.env.NODE_ENV === 'development')
        assert(this._parent, 'No parent loaded');

    if (this._parent.void)
        throw new Error(
            this._parent.path + ' is a void element. ' +
            'Void elements are not allowed to have children.'
        );

    if (!this._target) this._target = new ElementCache(document.createElement(tagName), this._path);

    var el = this._target.element;
    var parent = this._parent.element;

    this.resolveChildren(el, parent);

    parent.appendChild(el);
    this._elements[this._path] = this._target;

    this._compositor.sendEvent(this._path, 'insertEl', {});
    this._insertElEventEmitter.trigger(this._path, this._target);
};


/**
 * Sets a property on the currently loaded target.
 *
 * @method
 *
 * @param {String} name Property name (e.g. background, color, font)
 * @param {String} value Proprty value (e.g. black, 20px)
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setProperty = function setProperty (name, value) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');
    this._target.element.style[name] = value;
};


/**
 * Sets the size of the currently loaded target.
 * Removes any explicit sizing constraints when passed in `false`
 * ("true-sizing").
 *
 * Invoking setSize is equivalent to a manual invocation of `setWidth` followed
 * by `setHeight`.
 *
 * @method
 *
 * @param {Number|false} width   Width to be set.
 * @param {Number|false} height  Height to be set.
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setSize = function setSize (width, height) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');

    this.setWidth(width);
    this.setHeight(height);
};

/**
 * Sets the width of the currently loaded ElementCache.
 *
 * @method
 *
 * @param  {Number|false} width     The explicit width to be set on the
 *                                  ElementCache's target (and content) element.
 *                                  `false` removes any explicit sizing
 *                                  constraints from the underlying DOM
 *                                  Elements.
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setWidth = function setWidth(width) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');

    var contentWrapper = this._target.content;

    if (width === false) {
        this._target.explicitWidth = true;
        if (contentWrapper) contentWrapper.style.width = '';
        width = contentWrapper ? contentWrapper.offsetWidth : 0;
        this._target.element.style.width = width + 'px';
    }
    else {
        this._target.explicitWidth = false;
        if (contentWrapper) contentWrapper.style.width = width + 'px';
        this._target.element.style.width = width + 'px';
    }

    this._target.size[0] = width;
};

/**
 * Sets the height of the currently loaded ElementCache.
 *
 * @method  setHeight
 *
 * @param  {Number|false} height    The explicit height to be set on the
 *                                  ElementCache's target (and content) element.
 *                                  `false` removes any explicit sizing
 *                                  constraints from the underlying DOM
 *                                  Elements.
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setHeight = function setHeight(height) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');

    var contentWrapper = this._target.content;

    if (height === false) {
        this._target.explicitHeight = true;
        if (contentWrapper) contentWrapper.style.height = '';
        height = contentWrapper ? contentWrapper.offsetHeight : 0;
        this._target.element.style.height = height + 'px';
    }
    else {
        this._target.explicitHeight = false;
        if (contentWrapper) contentWrapper.style.height = height + 'px';
        this._target.element.style.height = height + 'px';
    }

    this._target.size[1] = height;
};

/**
 * Sets an attribute on the currently loaded target.
 *
 * @method
 *
 * @param {String} name Attribute name (e.g. href)
 * @param {String} value Attribute value (e.g. http://famous.org)
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setAttribute = function setAttribute(name, value) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');
    this._target.element.setAttribute(name, value);
};

/**
 * Sets the `innerHTML` content of the currently loaded target.
 *
 * @method
 *
 * @param {String} content Content to be set as `innerHTML`
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setContent = function setContent(content) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');

    if (this._target.formElement) {
        this._target.element.value = content;
    }
    else {
        if (!this._target.content) {
            this._target.content = document.createElement('div');
            this._target.content.classList.add('famous-dom-element-content');
            this._target.element.insertBefore(
                this._target.content,
                this._target.element.firstChild
            );
        }
        this._target.content.innerHTML = content;
    }


    this.setSize(
        this._target.explicitWidth ? false : this._target.size[0],
        this._target.explicitHeight ? false : this._target.size[1]
    );
};


/**
 * Sets the passed in transform matrix (world space). Inverts the parent's world
 * transform.
 *
 * @method
 *
 * @param {Float32Array} transform The transform for the loaded DOM Element in world space
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.setMatrix = function setMatrix (transform) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');
    this._target.element.style[TRANSFORM] = this._stringifyMatrix(transform);
};


/**
 * Adds a class to the classList associated with the currently loaded target.
 *
 * @method
 *
 * @param {String} domClass Class name to be added to the current target.
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.addClass = function addClass(domClass) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');
    this._target.element.classList.add(domClass);
};


/**
 * Removes a class from the classList associated with the currently loaded
 * target.
 *
 * @method
 *
 * @param {String} domClass Class name to be removed from currently loaded target.
 *
 * @return {undefined} undefined
 */
DOMRenderer.prototype.removeClass = function removeClass(domClass) {
    if (process.env.NODE_ENV === 'development')
        assert(this._target, 'No target loaded');
    this._target.element.classList.remove(domClass);
};


/**
 * Stringifies the passed in matrix for setting the `transform` property.
 *
 * @method  _stringifyMatrix
 * @private
 *
 * @param {Array} m    Matrix as an array or array-like object.
 * @return {String}     Stringified matrix as `matrix3d`-property.
 */
DOMRenderer.prototype._stringifyMatrix = function _stringifyMatrix(m) {
    var r = 'matrix3d(';

    r += (m[0] < 0.000001 && m[0] > -0.000001) ? '0,' : m[0] + ',';
    r += (m[1] < 0.000001 && m[1] > -0.000001) ? '0,' : m[1] + ',';
    r += (m[2] < 0.000001 && m[2] > -0.000001) ? '0,' : m[2] + ',';
    r += (m[3] < 0.000001 && m[3] > -0.000001) ? '0,' : m[3] + ',';
    r += (m[4] < 0.000001 && m[4] > -0.000001) ? '0,' : m[4] + ',';
    r += (m[5] < 0.000001 && m[5] > -0.000001) ? '0,' : m[5] + ',';
    r += (m[6] < 0.000001 && m[6] > -0.000001) ? '0,' : m[6] + ',';
    r += (m[7] < 0.000001 && m[7] > -0.000001) ? '0,' : m[7] + ',';
    r += (m[8] < 0.000001 && m[8] > -0.000001) ? '0,' : m[8] + ',';
    r += (m[9] < 0.000001 && m[9] > -0.000001) ? '0,' : m[9] + ',';
    r += (m[10] < 0.000001 && m[10] > -0.000001) ? '0,' : m[10] + ',';
    r += (m[11] < 0.000001 && m[11] > -0.000001) ? '0,' : m[11] + ',';
    r += (m[12] < 0.000001 && m[12] > -0.000001) ? '0,' : m[12] + ',';
    r += (m[13] < 0.000001 && m[13] > -0.000001) ? '0,' : m[13] + ',';
    r += (m[14] < 0.000001 && m[14] > -0.000001) ? '0,' : m[14] + ',';

    r += m[15] + ')';
    return r;
};

/**
 * Registers a function to be executed when a new element is being inserted at
 * the specified path.
 *
 * @method
 *
 * @param  {String}   path      Path at which to listen for element insertion.
 * @param  {Function} callback  Function to be executed when an insertion
 *                              occurs.
 * @return {DOMRenderer}        this
 */
DOMRenderer.prototype.onInsertEl = function onInsertEl(path, callback) {
    this._insertElEventEmitter.on(path, callback);
    return this;
};

/**
 * Deregisters a listener function to be no longer executed on future element
 * insertions at the specified path.
 *
 * @method
 *
 * @param  {String}   path      Path at which the listener function has been
 *                              registered.
 * @param  {Function} callback  Callback function to be deregistered.
 * @return {DOMRenderer}        this
 */
DOMRenderer.prototype.offInsertEl = function offInsertEl(path, callback) {
    this._insertElEventEmitter.off(path, callback);
    return this;
};

/**
 * Registers an event handler to be triggered as soon as an element at the
 * specified path is being removed.
 *
 * @method
 *
 * @param  {String}   path      Path at which to listen for the removal of an
 *                              element.
 * @param  {Function} callback  Function to be executed when an element is
 *                              being removed at the specified path.
 * @return {DOMRenderer}        this
 */
DOMRenderer.prototype.onRemoveEl = function onRemoveEl(path, callback) {
    this._removeElEventEmitter.on(path, callback);
    return this;
};

/**
 * Deregisters a listener function to be no longer executed when an element is
 * being removed from the specified path.
 *
 * @method
 *
 * @param  {String}   path      Path at which the listener function has been
 *                              registered.
 * @param  {Function} callback  Callback function to be deregistered.
 * @return {DOMRenderer}        this
 */
DOMRenderer.prototype.offRemoveEl = function offRemoveEl(path, callback) {
    this._removeElEventEmitter.off(path, callback);
    return this;
};

module.exports = DOMRenderer;

}).call(this,require('_process'))

},{"../core/Path":39,"../utilities/EventEmitter":69,"../utilities/assert":70,"../utilities/vendorPrefix":71,"./ElementCache":48,"./Math":49,"./events/EventMap":53,"_process":1}],48:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var VoidElements = require('./VoidElements');

/**
 * ElementCache is being used for keeping track of an element's DOM Element,
 * path, world transform, inverted parent, final transform (as being used for
 * setting the actual `transform`-property) and post render size (final size as
 * being rendered to the DOM).
 *
 * @class ElementCache
 *
 * @param {Element} element DOMElement
 * @param {String} path Path used for uniquely identifying the location in the
 *                      scene graph.
 */
function ElementCache (element, path) {
    this.tagName = element.tagName.toLowerCase();
    this.void = VoidElements[this.tagName];

    var constructor = element.constructor;

    this.formElement = constructor === HTMLInputElement ||
        constructor === HTMLTextAreaElement ||
        constructor === HTMLSelectElement;

    this.element = element;
    this.path = path;
    this.content = null;
    this.size = new Int16Array(3);
    this.explicitHeight = false;
    this.explicitWidth = false;
    this.postRenderSize = new Float32Array(2);
    this.listeners = {};
    this.preventDefault = {};
    this.subscribe = {};
}

module.exports = ElementCache;

},{"./VoidElements":50}],49:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * A method for inverting a transform matrix
 *
 * @method
 *
 * @param {Array} out array to store the return of the inversion
 * @param {Array} a transform matrix to inverse
 *
 * @return {Array} out
 *   output array that is storing the transform matrix
 */
function invert (out, a) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b00 = a00 * a11 - a01 * a10,
        b01 = a00 * a12 - a02 * a10,
        b02 = a00 * a13 - a03 * a10,
        b03 = a01 * a12 - a02 * a11,
        b04 = a01 * a13 - a03 * a11,
        b05 = a02 * a13 - a03 * a12,
        b06 = a20 * a31 - a21 * a30,
        b07 = a20 * a32 - a22 * a30,
        b08 = a20 * a33 - a23 * a30,
        b09 = a21 * a32 - a22 * a31,
        b10 = a21 * a33 - a23 * a31,
        b11 = a22 * a33 - a23 * a32,

        // Calculate the determinant
        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

    if (!det) {
        return null;
    }
    det = 1.0 / det;

    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

    return out;
}

/**
 * A method for multiplying two matricies
 *
 * @method
 *
 * @param {Array} out array to store the return of the multiplication
 * @param {Array} a transform matrix to multiply
 * @param {Array} b transform matrix to multiply
 *
 * @return {Array} out
 *   output array that is storing the transform matrix
 */
function multiply (out, a, b) {
    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

        b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3],
        b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7],
        b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11],
        b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];

    var changed = false;
    var out0, out1, out2, out3;

    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[0] ||
                        out1 === out[1] ||
                        out2 === out[2] ||
                        out3 === out[3];

    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = out3;

    b0 = b4; b1 = b5; b2 = b6; b3 = b7;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[4] ||
                        out1 === out[5] ||
                        out2 === out[6] ||
                        out3 === out[7];

    out[4] = out0;
    out[5] = out1;
    out[6] = out2;
    out[7] = out3;

    b0 = b8; b1 = b9; b2 = b10; b3 = b11;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[8] ||
                        out1 === out[9] ||
                        out2 === out[10] ||
                        out3 === out[11];

    out[8] = out0;
    out[9] = out1;
    out[10] = out2;
    out[11] = out3;

    b0 = b12; b1 = b13; b2 = b14; b3 = b15;
    out0 = b0*a00 + b1*a10 + b2*a20 + b3*a30;
    out1 = b0*a01 + b1*a11 + b2*a21 + b3*a31;
    out2 = b0*a02 + b1*a12 + b2*a22 + b3*a32;
    out3 = b0*a03 + b1*a13 + b2*a23 + b3*a33;

    changed = changed ?
              changed : out0 === out[12] ||
                        out1 === out[13] ||
                        out2 === out[14] ||
                        out3 === out[15];

    out[12] = out0;
    out[13] = out1;
    out[14] = out2;
    out[15] = out3;

    return out;
}

module.exports = {
    multiply: multiply,
    invert: invert
};

},{}],50:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * Map of void elements as defined by the
 * [HTML5 spec](http://www.w3.org/TR/html5/syntax.html#elements-0).
 *
 * @type {Object}
 */
var VoidElements = {
    area  : true,
    base  : true,
    br    : true,
    col   : true,
    embed : true,
    hr    : true,
    img   : true,
    input : true,
    keygen: true,
    link  : true,
    meta  : true,
    param : true,
    source: true,
    track : true,
    wbr   : true
};

module.exports = VoidElements;

},{}],51:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#events-compositionevents).
 *
 * @class CompositionEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function CompositionEvent(ev) {
    // [Constructor(DOMString typeArg, optional CompositionEventInit compositionEventInitDict)]
    // interface CompositionEvent : UIEvent {
    //     readonly    attribute DOMString data;
    // };

    UIEvent.call(this, ev);

    /**
     * @name CompositionEvent#data
     * @type String
     */
    this.data = ev.data;
}

CompositionEvent.prototype = Object.create(UIEvent.prototype);
CompositionEvent.prototype.constructor = CompositionEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
CompositionEvent.prototype.toString = function toString () {
    return 'CompositionEvent';
};

module.exports = CompositionEvent;

},{"./UIEvent":59}],52:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * The Event class is being used in order to normalize native DOM events.
 * Events need to be normalized in order to be serialized through the structured
 * cloning algorithm used by the `postMessage` method (Web Workers).
 *
 * Wrapping DOM events also has the advantage of providing a consistent
 * interface for interacting with DOM events across browsers by copying over a
 * subset of the exposed properties that is guaranteed to be consistent across
 * browsers.
 *
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#interface-Event).
 *
 * @class Event
 *
 * @param {Event} ev The native DOM event.
 */
function Event(ev) {
    // [Constructor(DOMString type, optional EventInit eventInitDict),
    //  Exposed=Window,Worker]
    // interface Event {
    //   readonly attribute DOMString type;
    //   readonly attribute EventTarget? target;
    //   readonly attribute EventTarget? currentTarget;

    //   const unsigned short NONE = 0;
    //   const unsigned short CAPTURING_PHASE = 1;
    //   const unsigned short AT_TARGET = 2;
    //   const unsigned short BUBBLING_PHASE = 3;
    //   readonly attribute unsigned short eventPhase;

    //   void stopPropagation();
    //   void stopImmediatePropagation();

    //   readonly attribute boolean bubbles;
    //   readonly attribute boolean cancelable;
    //   void preventDefault();
    //   readonly attribute boolean defaultPrevented;

    //   [Unforgeable] readonly attribute boolean isTrusted;
    //   readonly attribute DOMTimeStamp timeStamp;

    //   void initEvent(DOMString type, boolean bubbles, boolean cancelable);
    // };

    /**
     * @name Event#type
     * @type String
     */
    this.type = ev.type;

    /**
     * @name Event#defaultPrevented
     * @type Boolean
     */
    this.defaultPrevented = ev.defaultPrevented;

    /**
     * @name Event#timeStamp
     * @type Number
     */
    this.timeStamp = ev.timeStamp;


    /**
     * Used for exposing the current target's value.
     *
     * @name Event#value
     * @type String
     */
    var targetConstructor = ev.target.constructor;
    // TODO Support HTMLKeygenElement
    if (
        targetConstructor === HTMLInputElement ||
        targetConstructor === HTMLTextAreaElement ||
        targetConstructor === HTMLSelectElement
    ) {
        this.value = ev.target.value;
    }
}

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
Event.prototype.toString = function toString () {
    return 'Event';
};

module.exports = Event;

},{}],53:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var CompositionEvent = require('./CompositionEvent');
var Event = require('./Event');
var FocusEvent = require('./FocusEvent');
var InputEvent = require('./InputEvent');
var KeyboardEvent = require('./KeyboardEvent');
var MouseEvent = require('./MouseEvent');
var TouchEvent = require('./TouchEvent');
var UIEvent = require('./UIEvent');
var WheelEvent = require('./WheelEvent');

/**
 * A mapping of DOM events to the corresponding handlers
 *
 * @name EventMap
 * @type Object
 */
var EventMap = {
    change                         : [Event, true],
    submit                         : [Event, true],

    // UI Events (http://www.w3.org/TR/uievents/)
    abort                          : [Event, false],
    beforeinput                    : [InputEvent, true],
    blur                           : [FocusEvent, false],
    click                          : [MouseEvent, true],
    compositionend                 : [CompositionEvent, true],
    compositionstart               : [CompositionEvent, true],
    compositionupdate              : [CompositionEvent, true],
    dblclick                       : [MouseEvent, true],
    focus                          : [FocusEvent, false],
    focusin                        : [FocusEvent, true],
    focusout                       : [FocusEvent, true],
    input                          : [InputEvent, true],
    keydown                        : [KeyboardEvent, true],
    keyup                          : [KeyboardEvent, true],
    load                           : [Event, false],
    mousedown                      : [MouseEvent, true],
    mouseenter                     : [MouseEvent, false],
    mouseleave                     : [MouseEvent, false],

    // bubbles, but will be triggered very frequently
    mousemove                      : [MouseEvent, false],

    mouseout                       : [MouseEvent, true],
    mouseover                      : [MouseEvent, true],
    mouseup                        : [MouseEvent, true],
    contextMenu                    : [MouseEvent, true],
    resize                         : [UIEvent, false],

    // might bubble
    scroll                         : [UIEvent, false],

    select                         : [Event, true],
    unload                         : [Event, false],
    wheel                          : [WheelEvent, true],

    // Touch Events Extension (http://www.w3.org/TR/touch-events-extensions/)
    touchcancel                    : [TouchEvent, true],
    touchend                       : [TouchEvent, true],
    touchmove                      : [TouchEvent, true],
    touchstart                     : [TouchEvent, true]
};

module.exports = EventMap;

},{"./CompositionEvent":51,"./Event":52,"./FocusEvent":54,"./InputEvent":55,"./KeyboardEvent":56,"./MouseEvent":57,"./TouchEvent":58,"./UIEvent":59,"./WheelEvent":60}],54:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#events-focusevent).
 *
 * @class FocusEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function FocusEvent(ev) {
    // [Constructor(DOMString typeArg, optional FocusEventInit focusEventInitDict)]
    // interface FocusEvent : UIEvent {
    //     readonly    attribute EventTarget? relatedTarget;
    // };

    UIEvent.call(this, ev);
}

FocusEvent.prototype = Object.create(UIEvent.prototype);
FocusEvent.prototype.constructor = FocusEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
FocusEvent.prototype.toString = function toString () {
    return 'FocusEvent';
};

module.exports = FocusEvent;

},{"./UIEvent":59}],55:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

/**
 * See [Input Events](http://w3c.github.io/editing-explainer/input-events.html#idl-def-InputEvent).
 *
 * @class InputEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function InputEvent(ev) {
    // [Constructor(DOMString typeArg, optional InputEventInit inputEventInitDict)]
    // interface InputEvent : UIEvent {
    //     readonly    attribute DOMString inputType;
    //     readonly    attribute DOMString data;
    //     readonly    attribute boolean   isComposing;
    //     readonly    attribute Range     targetRange;
    // };

    UIEvent.call(this, ev);

    /**
     * @name    InputEvent#inputType
     * @type    String
     */
    this.inputType = ev.inputType;

    /**
     * @name    InputEvent#data
     * @type    String
     */
    this.data = ev.data;

    /**
     * @name    InputEvent#isComposing
     * @type    Boolean
     */
    this.isComposing = ev.isComposing;

    /**
     * **Limited browser support**.
     *
     * @name    InputEvent#targetRange
     * @type    Boolean
     */
    this.targetRange = ev.targetRange;
}

InputEvent.prototype = Object.create(UIEvent.prototype);
InputEvent.prototype.constructor = InputEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
InputEvent.prototype.toString = function toString () {
    return 'InputEvent';
};

module.exports = InputEvent;

},{"./UIEvent":59}],56:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#events-keyboardevents).
 *
 * @class KeyboardEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function KeyboardEvent(ev) {
    // [Constructor(DOMString typeArg, optional KeyboardEventInit keyboardEventInitDict)]
    // interface KeyboardEvent : UIEvent {
    //     // KeyLocationCode
    //     const unsigned long DOM_KEY_LOCATION_STANDARD = 0x00;
    //     const unsigned long DOM_KEY_LOCATION_LEFT = 0x01;
    //     const unsigned long DOM_KEY_LOCATION_RIGHT = 0x02;
    //     const unsigned long DOM_KEY_LOCATION_NUMPAD = 0x03;
    //     readonly    attribute DOMString     key;
    //     readonly    attribute DOMString     code;
    //     readonly    attribute unsigned long location;
    //     readonly    attribute boolean       ctrlKey;
    //     readonly    attribute boolean       shiftKey;
    //     readonly    attribute boolean       altKey;
    //     readonly    attribute boolean       metaKey;
    //     readonly    attribute boolean       repeat;
    //     readonly    attribute boolean       isComposing;
    //     boolean getModifierState (DOMString keyArg);
    // };

    UIEvent.call(this, ev);

    /**
     * @name KeyboardEvent#DOM_KEY_LOCATION_STANDARD
     * @type Number
     */
    this.DOM_KEY_LOCATION_STANDARD = 0x00;

    /**
     * @name KeyboardEvent#DOM_KEY_LOCATION_LEFT
     * @type Number
     */
    this.DOM_KEY_LOCATION_LEFT = 0x01;

    /**
     * @name KeyboardEvent#DOM_KEY_LOCATION_RIGHT
     * @type Number
     */
    this.DOM_KEY_LOCATION_RIGHT = 0x02;

    /**
     * @name KeyboardEvent#DOM_KEY_LOCATION_NUMPAD
     * @type Number
     */
    this.DOM_KEY_LOCATION_NUMPAD = 0x03;

    /**
     * @name KeyboardEvent#key
     * @type String
     */
    this.key = ev.key;

    /**
     * @name KeyboardEvent#code
     * @type String
     */
    this.code = ev.code;

    /**
     * @name KeyboardEvent#location
     * @type Number
     */
    this.location = ev.location;

    /**
     * @name KeyboardEvent#ctrlKey
     * @type Boolean
     */
    this.ctrlKey = ev.ctrlKey;

    /**
     * @name KeyboardEvent#shiftKey
     * @type Boolean
     */
    this.shiftKey = ev.shiftKey;

    /**
     * @name KeyboardEvent#altKey
     * @type Boolean
     */
    this.altKey = ev.altKey;

    /**
     * @name KeyboardEvent#metaKey
     * @type Boolean
     */
    this.metaKey = ev.metaKey;

    /**
     * @name KeyboardEvent#repeat
     * @type Boolean
     */
    this.repeat = ev.repeat;

    /**
     * @name KeyboardEvent#isComposing
     * @type Boolean
     */
    this.isComposing = ev.isComposing;

    /**
     * @name KeyboardEvent#keyCode
     * @type String
     * @deprecated
     */
    this.keyCode = ev.keyCode;
}

KeyboardEvent.prototype = Object.create(UIEvent.prototype);
KeyboardEvent.prototype.constructor = KeyboardEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
KeyboardEvent.prototype.toString = function toString () {
    return 'KeyboardEvent';
};

module.exports = KeyboardEvent;

},{"./UIEvent":59}],57:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#events-mouseevents).
 *
 * @class KeyboardEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function MouseEvent(ev) {
    // [Constructor(DOMString typeArg, optional MouseEventInit mouseEventInitDict)]
    // interface MouseEvent : UIEvent {
    //     readonly    attribute long           screenX;
    //     readonly    attribute long           screenY;
    //     readonly    attribute long           clientX;
    //     readonly    attribute long           clientY;
    //     readonly    attribute boolean        ctrlKey;
    //     readonly    attribute boolean        shiftKey;
    //     readonly    attribute boolean        altKey;
    //     readonly    attribute boolean        metaKey;
    //     readonly    attribute short          button;
    //     readonly    attribute EventTarget?   relatedTarget;
    //     // Introduced in this specification
    //     readonly    attribute unsigned short buttons;
    //     boolean getModifierState (DOMString keyArg);
    // };

    UIEvent.call(this, ev);

    /**
     * @name MouseEvent#screenX
     * @type Number
     */
    this.screenX = ev.screenX;

    /**
     * @name MouseEvent#screenY
     * @type Number
     */
    this.screenY = ev.screenY;

    /**
     * @name MouseEvent#clientX
     * @type Number
     */
    this.clientX = ev.clientX;

    /**
     * @name MouseEvent#clientY
     * @type Number
     */
    this.clientY = ev.clientY;

    /**
     * @name MouseEvent#ctrlKey
     * @type Boolean
     */
    this.ctrlKey = ev.ctrlKey;

    /**
     * @name MouseEvent#shiftKey
     * @type Boolean
     */
    this.shiftKey = ev.shiftKey;

    /**
     * @name MouseEvent#altKey
     * @type Boolean
     */
    this.altKey = ev.altKey;

    /**
     * @name MouseEvent#metaKey
     * @type Boolean
     */
    this.metaKey = ev.metaKey;

    /**
     * @type MouseEvent#button
     * @type Number
     */
    this.button = ev.button;

    /**
     * @type MouseEvent#buttons
     * @type Number
     */
    this.buttons = ev.buttons;

    /**
     * @type MouseEvent#pageX
     * @type Number
     */
    this.pageX = ev.pageX;

    /**
     * @type MouseEvent#pageY
     * @type Number
     */
    this.pageY = ev.pageY;

    /**
     * @type MouseEvent#x
     * @type Number
     */
    this.x = ev.x;

    /**
     * @type MouseEvent#y
     * @type Number
     */
    this.y = ev.y;

    /**
     * @type MouseEvent#offsetX
     * @type Number
     */
    this.offsetX = ev.offsetX;

    /**
     * @type MouseEvent#offsetY
     * @type Number
     */
    this.offsetY = ev.offsetY;
}

MouseEvent.prototype = Object.create(UIEvent.prototype);
MouseEvent.prototype.constructor = MouseEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
MouseEvent.prototype.toString = function toString () {
    return 'MouseEvent';
};

module.exports = MouseEvent;

},{"./UIEvent":59}],58:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var UIEvent = require('./UIEvent');

var EMPTY_ARRAY = [];

/**
 * See [Touch Interface](http://www.w3.org/TR/2013/REC-touch-events-20131010/#touch-interface).
 *
 * @class Touch
 * @private
 *
 * @param {Touch} touch The native Touch object.
 */
function Touch(touch) {
    // interface Touch {
    //     readonly    attribute long        identifier;
    //     readonly    attribute EventTarget target;
    //     readonly    attribute double      screenX;
    //     readonly    attribute double      screenY;
    //     readonly    attribute double      clientX;
    //     readonly    attribute double      clientY;
    //     readonly    attribute double      pageX;
    //     readonly    attribute double      pageY;
    // };

    /**
     * @name Touch#identifier
     * @type Number
     */
    this.identifier = touch.identifier;

    /**
     * @name Touch#screenX
     * @type Number
     */
    this.screenX = touch.screenX;

    /**
     * @name Touch#screenY
     * @type Number
     */
    this.screenY = touch.screenY;

    /**
     * @name Touch#clientX
     * @type Number
     */
    this.clientX = touch.clientX;

    /**
     * @name Touch#clientY
     * @type Number
     */
    this.clientY = touch.clientY;

    /**
     * @name Touch#pageX
     * @type Number
     */
    this.pageX = touch.pageX;

    /**
     * @name Touch#pageY
     * @type Number
     */
    this.pageY = touch.pageY;
}


/**
 * Normalizes the browser's native TouchList by converting it into an array of
 * normalized Touch objects.
 *
 * @method  cloneTouchList
 * @private
 *
 * @param  {TouchList} touchList    The native TouchList array.
 * @return {Array.<Touch>}          An array of normalized Touch objects.
 */
function cloneTouchList(touchList) {
    if (!touchList) return EMPTY_ARRAY;
    // interface TouchList {
    //     readonly    attribute unsigned long length;
    //     getter Touch? item (unsigned long index);
    // };

    var touchListArray = [];
    for (var i = 0; i < touchList.length; i++) {
        touchListArray[i] = new Touch(touchList[i]);
    }
    return touchListArray;
}

/**
 * See [Touch Event Interface](http://www.w3.org/TR/2013/REC-touch-events-20131010/#touchevent-interface).
 *
 * @class TouchEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function TouchEvent(ev) {
    // interface TouchEvent : UIEvent {
    //     readonly    attribute TouchList touches;
    //     readonly    attribute TouchList targetTouches;
    //     readonly    attribute TouchList changedTouches;
    //     readonly    attribute boolean   altKey;
    //     readonly    attribute boolean   metaKey;
    //     readonly    attribute boolean   ctrlKey;
    //     readonly    attribute boolean   shiftKey;
    // };
    UIEvent.call(this, ev);

    /**
     * @name TouchEvent#touches
     * @type Array.<Touch>
     */
    this.touches = cloneTouchList(ev.touches);

    /**
     * @name TouchEvent#targetTouches
     * @type Array.<Touch>
     */
    this.targetTouches = cloneTouchList(ev.targetTouches);

    /**
     * @name TouchEvent#changedTouches
     * @type TouchList
     */
    this.changedTouches = cloneTouchList(ev.changedTouches);

    /**
     * @name TouchEvent#altKey
     * @type Boolean
     */
    this.altKey = ev.altKey;

    /**
     * @name TouchEvent#metaKey
     * @type Boolean
     */
    this.metaKey = ev.metaKey;

    /**
     * @name TouchEvent#ctrlKey
     * @type Boolean
     */
    this.ctrlKey = ev.ctrlKey;

    /**
     * @name TouchEvent#shiftKey
     * @type Boolean
     */
    this.shiftKey = ev.shiftKey;
}

TouchEvent.prototype = Object.create(UIEvent.prototype);
TouchEvent.prototype.constructor = TouchEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
TouchEvent.prototype.toString = function toString () {
    return 'TouchEvent';
};

module.exports = TouchEvent;

},{"./UIEvent":59}],59:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Event = require('./Event');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428).
 *
 * @class UIEvent
 * @augments Event
 *
 * @param  {Event} ev   The native DOM event.
 */
function UIEvent(ev) {
    // [Constructor(DOMString type, optional UIEventInit eventInitDict)]
    // interface UIEvent : Event {
    //     readonly    attribute Window? view;
    //     readonly    attribute long    detail;
    // };
    Event.call(this, ev);

    /**
     * @name UIEvent#detail
     * @type Number
     */
    this.detail = ev.detail;
}

UIEvent.prototype = Object.create(Event.prototype);
UIEvent.prototype.constructor = UIEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
UIEvent.prototype.toString = function toString () {
    return 'UIEvent';
};

module.exports = UIEvent;

},{"./Event":52}],60:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var MouseEvent = require('./MouseEvent');

/**
 * See [UI Events (formerly DOM Level 3 Events)](http://www.w3.org/TR/2015/WD-uievents-20150428/#events-wheelevents).
 *
 * @class WheelEvent
 * @augments UIEvent
 *
 * @param {Event} ev The native DOM event.
 */
function WheelEvent(ev) {
    // [Constructor(DOMString typeArg, optional WheelEventInit wheelEventInitDict)]
    // interface WheelEvent : MouseEvent {
    //     // DeltaModeCode
    //     const unsigned long DOM_DELTA_PIXEL = 0x00;
    //     const unsigned long DOM_DELTA_LINE = 0x01;
    //     const unsigned long DOM_DELTA_PAGE = 0x02;
    //     readonly    attribute double        deltaX;
    //     readonly    attribute double        deltaY;
    //     readonly    attribute double        deltaZ;
    //     readonly    attribute unsigned long deltaMode;
    // };

    MouseEvent.call(this, ev);

    /**
     * @name WheelEvent#DOM_DELTA_PIXEL
     * @type Number
     */
    this.DOM_DELTA_PIXEL = 0x00;

    /**
     * @name WheelEvent#DOM_DELTA_LINE
     * @type Number
     */
    this.DOM_DELTA_LINE = 0x01;

    /**
     * @name WheelEvent#DOM_DELTA_PAGE
     * @type Number
     */
    this.DOM_DELTA_PAGE = 0x02;

    /**
     * @name WheelEvent#deltaX
     * @type Number
     */
    this.deltaX = ev.deltaX;

    /**
     * @name WheelEvent#deltaY
     * @type Number
     */
    this.deltaY = ev.deltaY;

    /**
     * @name WheelEvent#deltaZ
     * @type Number
     */
    this.deltaZ = ev.deltaZ;

    /**
     * @name WheelEvent#deltaMode
     * @type Number
     */
    this.deltaMode = ev.deltaMode;
}

WheelEvent.prototype = Object.create(MouseEvent.prototype);
WheelEvent.prototype.constructor = WheelEvent;

/**
 * Return the name of the event type
 *
 * @method
 *
 * @return {String} Name of the event type
 */
WheelEvent.prototype.toString = function toString () {
    return 'WheelEvent';
};

module.exports = WheelEvent;

},{"./MouseEvent":57}],61:[function(require,module,exports){
// http://paulirish.com/2011/requestanimationframe-for-smart-animating/
// http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating
// requestAnimationFrame polyfill by Erik Möller. fixes from Paul Irish and Tino Zijdel
// MIT license

'use strict';

var lastTime = 0;
var vendors = ['ms', 'moz', 'webkit', 'o'];

var rAF, cAF;

if (typeof window === 'object') {
    rAF = window.requestAnimationFrame;
    cAF = window.cancelAnimationFrame || window.cancelRequestAnimationFrame;
    for (var x = 0; x < vendors.length && !rAF; ++x) {
        rAF = window[vendors[x] + 'RequestAnimationFrame'];
        cAF = window[vendors[x] + 'CancelRequestAnimationFrame'] ||
              window[vendors[x] + 'CancelAnimationFrame'];
    }

    if (rAF && !cAF) {
        // cAF not supported.
        // Fall back to setInterval for now (very rare).
        rAF = null;
    }
}

if (!rAF) {
    var now = Date.now ? Date.now : function () {
        return new Date().getTime();
    };

    rAF = function(callback) {
        var currTime = now();
        var timeToCall = Math.max(0, 16 - (currTime - lastTime));
        var id = setTimeout(function () {
            callback(currTime + timeToCall);
        }, timeToCall);
        lastTime = currTime + timeToCall;
        return id;
    };

    cAF = function (id) {
        clearTimeout(id);
    };
}

var animationFrame = {
    /**
     * Cross browser version of [requestAnimationFrame]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame}.
     *
     * Used by Engine in order to establish a render loop.
     *
     * If no (vendor prefixed version of) `requestAnimationFrame` is available,
     * `setTimeout` will be used in order to emulate a render loop running at
     * approximately 60 frames per second.
     *
     * @method  requestAnimationFrame
     *
     * @param   {Function}  callback function to be invoked on the next frame.
     * @return  {Number}    requestId to be used to cancel the request using
     *                      {@link cancelAnimationFrame}.
     */
    requestAnimationFrame: rAF,

    /**
     * Cross browser version of [cancelAnimationFrame]{@link https://developer.mozilla.org/en-US/docs/Web/API/window/cancelAnimationFrame}.
     *
     * Cancels a previously using [requestAnimationFrame]{@link animationFrame#requestAnimationFrame}
     * scheduled request.
     *
     * Used for immediately stopping the render loop within the Engine.
     *
     * @method  cancelAnimationFrame
     *
     * @param   {Number}    requestId of the scheduled callback function
     *                      returned by [requestAnimationFrame]{@link animationFrame#requestAnimationFrame}.
     */
    cancelAnimationFrame: cAF
};

module.exports = animationFrame;

},{}],62:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var animationFrame = require('../polyfills/animationFrame');
var rAF = animationFrame.requestAnimationFrame;
var cAF = animationFrame.cancelAnimationFrame;

/**
 * Boolean constant indicating whether the RequestAnimationFrameLoop has access
 * to the document. The document is being used in order to subscribe for
 * visibilitychange events used for normalizing the RequestAnimationFrameLoop
 * time when e.g. when switching tabs.
 *
 * @constant
 * @type {Boolean}
 */
var DOCUMENT_ACCESS = typeof document !== 'undefined';

if (DOCUMENT_ACCESS) {
    var VENDOR_HIDDEN, VENDOR_VISIBILITY_CHANGE;

    // Opera 12.10 and Firefox 18 and later support
    if (typeof document.hidden !== 'undefined') {
        VENDOR_HIDDEN = 'hidden';
        VENDOR_VISIBILITY_CHANGE = 'visibilitychange';
    }
    else if (typeof document.mozHidden !== 'undefined') {
        VENDOR_HIDDEN = 'mozHidden';
        VENDOR_VISIBILITY_CHANGE = 'mozvisibilitychange';
    }
    else if (typeof document.msHidden !== 'undefined') {
        VENDOR_HIDDEN = 'msHidden';
        VENDOR_VISIBILITY_CHANGE = 'msvisibilitychange';
    }
    else if (typeof document.webkitHidden !== 'undefined') {
        VENDOR_HIDDEN = 'webkitHidden';
        VENDOR_VISIBILITY_CHANGE = 'webkitvisibilitychange';
    }
}

/**
 * RequestAnimationFrameLoop class used for updating objects on a frame-by-frame.
 * Synchronizes the `update` method invocations to the refresh rate of the
 * screen. Manages the `requestAnimationFrame`-loop by normalizing the passed in
 * timestamp when switching tabs.
 *
 * @class RequestAnimationFrameLoop
 */
function RequestAnimationFrameLoop() {
    var _this = this;

    // References to objects to be updated on next frame.
    this._updates = [];

    this._looper = function(time) {
        _this.loop(time);
    };
    this._time = 0;
    this._stoppedAt = 0;
    this._sleep = 0;

    // Indicates whether the engine should be restarted when the tab/ window is
    // being focused again (visibility change).
    this._startOnVisibilityChange = true;

    // requestId as returned by requestAnimationFrame function;
    this._rAF = null;

    this._sleepDiff = true;

    // The engine is being started on instantiation.
    // TODO(alexanderGugel)
    this.start();

    // The RequestAnimationFrameLoop supports running in a non-browser
    // environment (e.g. Worker).
    if (DOCUMENT_ACCESS) {
        document.addEventListener(VENDOR_VISIBILITY_CHANGE, function() {
            _this._onVisibilityChange();
        });
    }
}

/**
 * Handle the switching of tabs.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
RequestAnimationFrameLoop.prototype._onVisibilityChange = function _onVisibilityChange() {
    if (document[VENDOR_HIDDEN]) {
        this._onUnfocus();
    }
    else {
        this._onFocus();
    }
};

/**
 * Internal helper function to be invoked as soon as the window/ tab is being
 * focused after a visibiltiy change.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
RequestAnimationFrameLoop.prototype._onFocus = function _onFocus() {
    if (this._startOnVisibilityChange) {
        this._start();
    }
};

/**
 * Internal helper function to be invoked as soon as the window/ tab is being
 * unfocused (hidden) after a visibiltiy change.
 *
 * @method  _onFocus
 * @private
 *
 * @return {undefined} undefined
 */
RequestAnimationFrameLoop.prototype._onUnfocus = function _onUnfocus() {
    this._stop();
};

/**
 * Starts the RequestAnimationFrameLoop. When switching to a differnt tab/
 * window (changing the visibiltiy), the engine will be retarted when switching
 * back to a visible state.
 *
 * @method
 *
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.start = function start() {
    if (!this._running) {
        this._startOnVisibilityChange = true;
        this._start();
    }
    return this;
};

/**
 * Internal version of RequestAnimationFrameLoop's start function, not affecting
 * behavior on visibilty change.
 *
 * @method
 * @private
*
 * @return {undefined} undefined
 */
RequestAnimationFrameLoop.prototype._start = function _start() {
    this._running = true;
    this._sleepDiff = true;
    this._rAF = rAF(this._looper);
};

/**
 * Stops the RequestAnimationFrameLoop.
 *
 * @method
 * @private
 *
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.stop = function stop() {
    if (this._running) {
        this._startOnVisibilityChange = false;
        this._stop();
    }
    return this;
};

/**
 * Internal version of RequestAnimationFrameLoop's stop function, not affecting
 * behavior on visibilty change.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
RequestAnimationFrameLoop.prototype._stop = function _stop() {
    this._running = false;
    this._stoppedAt = this._time;

    // Bug in old versions of Fx. Explicitly cancel.
    cAF(this._rAF);
};

/**
 * Determines whether the RequestAnimationFrameLoop is currently running or not.
 *
 * @method
 *
 * @return {Boolean} boolean value indicating whether the
 * RequestAnimationFrameLoop is currently running or not
 */
RequestAnimationFrameLoop.prototype.isRunning = function isRunning() {
    return this._running;
};

/**
 * Updates all registered objects.
 *
 * @method
 *
 * @param {Number} time high resolution timstamp used for invoking the `update`
 * method on all registered objects
 *
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.step = function step (time) {
    this._time = time;
    if (this._sleepDiff) {
        this._sleep += time - this._stoppedAt;
        this._sleepDiff = false;
    }

    // The same timetamp will be emitted immediately before and after visibility
    // change.
    var normalizedTime = time - this._sleep;
    for (var i = 0, len = this._updates.length ; i < len ; i++) {
        this._updates[i].update(normalizedTime);
    }
    return this;
};

/**
 * Method being called by `requestAnimationFrame` on every paint. Indirectly
 * recursive by scheduling a future invocation of itself on the next paint.
 *
 * @method
 *
 * @param {Number} time high resolution timstamp used for invoking the `update`
 * method on all registered objects
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.loop = function loop(time) {
    this.step(time);
    this._rAF = rAF(this._looper);
    return this;
};

/**
 * Registeres an updateable object which `update` method should be invoked on
 * every paint, starting on the next paint (assuming the
 * RequestAnimationFrameLoop is running).
 *
 * @method
 *
 * @param {Object} updateable object to be updated
 * @param {Function} updateable.update update function to be called on the
 * registered object
 *
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.update = function update(updateable) {
    if (this._updates.indexOf(updateable) === -1) {
        this._updates.push(updateable);
    }
    return this;
};

/**
 * Deregisters an updateable object previously registered using `update` to be
 * no longer updated.
 *
 * @method
 *
 * @param {Object} updateable updateable object previously registered using
 * `update`
 *
 * @return {RequestAnimationFrameLoop} this
 */
RequestAnimationFrameLoop.prototype.noLongerUpdate = function noLongerUpdate(updateable) {
    var index = this._updates.indexOf(updateable);
    if (index > -1) {
        this._updates.splice(index, 1);
    }
    return this;
};

module.exports = RequestAnimationFrameLoop;

},{"../polyfills/animationFrame":61}],63:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Context = require('./Context');
var injectCSS = require('./inject-css');
var Commands = require('../core/Commands');

/**
 * Instantiates a new Compositor.
 * The Compositor receives draw commands frm the UIManager and routes the to the
 * respective context objects.
 *
 * Upon creation, it injects a stylesheet used for styling the individual
 * renderers used in the context objects.
 *
 * @class Compositor
 * @constructor
 * @return {undefined} undefined
 */
function Compositor() {
    injectCSS();

    this._contexts = {};
    this._outCommands = [];
    this._inCommands = [];
    this._time = null;

    this._resized = false;

    var _this = this;
    window.addEventListener('resize', function() {
        _this.onResize();
    });
}

Compositor.prototype.onResize = function onResize () {
    this._resized = true;
    for (var selector in this._contexts) {
        this._contexts[selector].updateSize();
    }
};

/**
 * Retrieves the time being used by the internal clock managed by
 * `FamousEngine`.
 *
 * The time is being passed into core by the Engine through the UIManager.
 * Since core has the ability to scale the time, the time needs to be passed
 * back to the rendering system.
 *
 * @method
 *
 * @return {Number} time The clock time used in core.
 */
Compositor.prototype.getTime = function getTime() {
    return this._time;
};

/**
 * Schedules an event to be sent the next time the out command queue is being
 * flushed.
 *
 * @method
 * @private
 *
 * @param  {String} path Render path to the node the event should be triggered
 * on (*targeted event*)
 * @param  {String} ev Event type
 * @param  {Object} payload Event object (serializable using structured cloning
 * algorithm)
 *
 * @return {undefined} undefined
 */
Compositor.prototype.sendEvent = function sendEvent(path, ev, payload) {
    this._outCommands.push(Commands.WITH, path, Commands.TRIGGER, ev, payload);
};

/**
 * Internal helper method used for notifying externally
 * resized contexts (e.g. by resizing the browser window).
 *
 * @method
 * @private
 *
 * @param  {String} selector render path to the node (context) that should be
 * resized
 * @param  {Array} size new context size
 *
 * @return {undefined} undefined
 */
Compositor.prototype.sendResize = function sendResize (selector, size) {
    this.sendEvent(selector, 'CONTEXT_RESIZE', size);
};

/**
 * Internal helper method used by `drawCommands`.
 * Subsequent commands are being associated with the node defined the the path
 * following the `WITH` command.
 *
 * @method
 * @private
 *
 * @param  {Number} iterator position index within the commands queue
 * @param  {Array} commands remaining message queue received, used to
 * shift single messages from
 *
 * @return {undefined} undefined
 */
Compositor.prototype.handleWith = function handleWith (iterator, commands) {
    var path = commands[iterator];
    var pathArr = path.split('/');
    var context = this.getOrSetContext(pathArr.shift());
    return context.receive(path, commands, iterator);
};

/**
 * Retrieves the top-level Context associated with the passed in document
 * query selector. If no such Context exists, a new one will be instantiated.
 *
 * @method
 *
 * @param  {String} selector document query selector used for retrieving the
 * DOM node that should be used as a root element by the Context
 *
 * @return {Context} context
 */
Compositor.prototype.getOrSetContext = function getOrSetContext(selector) {
    if (this._contexts[selector]) {
        return this._contexts[selector];
    }
    else {
        var context = new Context(selector, this);
        this._contexts[selector] = context;
        return context;
    }
};

/**
 * Retrieves a context object registered under the passed in selector.
 *
 * @method
 *
 * @param  {String} selector    Query selector that has previously been used to
 *                              register the context.
 * @return {Context}            The repsective context.
 */
Compositor.prototype.getContext = function getContext(selector) {
    if (this._contexts[selector])
        return this._contexts[selector];
};

/**
 * Processes the previously via `receiveCommands` updated incoming "in"
 * command queue.
 * Called by UIManager on a frame by frame basis.
 *
 * @method
 *
 * @return {Array} outCommands set of commands to be sent back
 */
Compositor.prototype.drawCommands = function drawCommands() {
    var commands = this._inCommands;
    var localIterator = 0;
    var command = commands[localIterator];
    while (command) {
        switch (command) {
            case Commands.TIME:
                this._time = commands[++localIterator];
                break;
            case Commands.WITH:
                localIterator = this.handleWith(++localIterator, commands);
                break;
            case Commands.NEED_SIZE_FOR:
                this.giveSizeFor(++localIterator, commands);
                break;
        }
        command = commands[++localIterator];
    }

    // TODO: Switch to associative arrays here...

    for (var key in this._contexts) {
        this._contexts[key].draw();
    }

    if (this._resized) {
        this.updateSize();
    }

    return this._outCommands;
};


/**
 * Updates the size of all previously registered context objects.
 * This results into CONTEXT_RESIZE events being sent and the root elements
 * used by the individual renderers being resized to the the DOMRenderer's root
 * size.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Compositor.prototype.updateSize = function updateSize() {
    for (var selector in this._contexts) {
        this._contexts[selector].updateSize();
    }
};

/**
 * Used by ThreadManager to update the internal queue of incoming commands.
 * Receiving commands does not immediately start the rendering process.
 *
 * @method
 *
 * @param  {Array} commands command queue to be processed by the compositor's
 * `drawCommands` method
 *
 * @return {undefined} undefined
 */
Compositor.prototype.receiveCommands = function receiveCommands(commands) {
    var len = commands.length;
    for (var i = 0; i < len; i++) {
        this._inCommands.push(commands[i]);
    }

    for (var selector in this._contexts) {
        this._contexts[selector].checkInit();
    }
};

/**
 * Internal helper method used by `drawCommands`.
 *
 * @method
 * @private
 *
 * @param  {Number} iterator position index within the command queue
 * @param  {Array} commands remaining message queue received, used to
 * shift single messages
 *
 * @return {undefined} undefined
 */
Compositor.prototype.giveSizeFor = function giveSizeFor(iterator, commands) {
    var selector = commands[iterator];
    var context = this.getContext(selector);
    if (context) {
        var size = context.getRootSize();
        this.sendResize(selector, size);
    }
    else {
        this.getOrSetContext(selector);
    }
};

/**
 * Flushes the queue of outgoing "out" commands.
 * Called by ThreadManager.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Compositor.prototype.clearCommands = function clearCommands() {
    this._inCommands.length = 0;
    this._outCommands.length = 0;
    this._resized = false;
};

 /**
 * Removes the context from the internal registry.
 *
 * @method
 *
 * @param  {String} selector    Selector used for accessing the regisered
 *                              context.
 * @return {undefined}          undefined
 */
Compositor.prototype.removeContext = function removeContext (selector) {
    var context = this._contexts[selector];
    delete this._contexts[selector];
    context.cleanup();
};

module.exports = Compositor;

},{"../core/Commands":32,"./Context":64,"./inject-css":66}],64:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Camera = require('../components/Camera');
var DOMRenderer = require('../dom-renderers/DOMRenderer');
var Commands = require('../core/Commands');

/**
 * Context is a render layer with its own WebGLRenderer and DOMRenderer.
 * It is the interface between the Compositor which receives commands
 * and the renderers that interpret them. It also relays information to
 * the renderers about resizing.
 *
 * The DOMElement at the given query selector is used as the root. A
 * new DOMElement is appended to this root element, and used as the
 * parent element for all Famous DOM rendering at this context. A
 * canvas is added and used for all WebGL rendering at this context.
 *
 * @class Context
 * @constructor
 *
 * @param {String} selector Query selector used to locate root element of
 * context layer.
 * @param {Compositor} compositor Compositor reference to pass down to
 * WebGLRenderer.
 */
function Context(selector, compositor) {
    this._compositor = compositor;
    this._rootEl = document.querySelector(selector);
    this._selector = selector;

    if (this._rootEl === null) {
        throw new Error(
            'Failed to create Context: ' +
            'No matches for "' + selector + '" found.'
        );
    }

    this._selector = selector;

    // Initializes the DOMRenderer.
    // Every Context has at least a DOMRenderer for now.
    this._initDOMRenderer();
    this._canvasEl = null;

    // State holders

    this._renderState = {
        projectionType: Camera.ORTHOGRAPHIC_PROJECTION,
        perspectiveTransform: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        viewTransform: new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
        viewDirty: false,
        perspectiveDirty: false
    };

    this._size = [];

    this._initDOM = false;
    this._currentTransform = new Float32Array(16);

    this._commandCallbacks = [];
    this.initCommandCallbacks();

    this.updateSize();
}

/**
 * Queries DOMRenderer size and updates canvas size. Relays size information to
 * WebGLRenderer.
 *
 * @method
 *
 * @return {Context} this
 */
Context.prototype.updateSize = function () {
    var width = this._rootEl.offsetWidth;
    var height = this._rootEl.offsetHeight;

    this._size[0] = width;
    this._size[1] = height;
    this._size[2] = (width > height) ? width : height;

    this._compositor.sendResize(this._selector, this._size);

    return this;
};

/**
 * Draw function called after all commands have been handled for current frame.
 * Issues draw commands to all renderers with current renderState.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Context.prototype.draw = function draw() {
    this._domRenderer.draw(this._renderState);

    if (this._renderState.perspectiveDirty) this._renderState.perspectiveDirty = false;
    if (this._renderState.viewDirty) this._renderState.viewDirty = false;
};

/**
 * Initializes the DOMRenderer by creating a root DIV element and appending it
 * to the context.
 *
 * @method
 * @private
 *
 * @return {undefined} undefined
 */
Context.prototype._initDOMRenderer = function _initDOMRenderer() {
    this._domRendererRootEl = document.createElement('div');
    this._rootEl.appendChild(this._domRendererRootEl);
    this._domRendererRootEl.style.visibility = 'hidden';

    this._domRenderer = new DOMRenderer(
        this._domRendererRootEl,
        this._selector,
        this._compositor
    );
};

Context.prototype.initCommandCallbacks = function initCommandCallbacks () {
    this._commandCallbacks[Commands.INIT_DOM] = initDOM;
    this._commandCallbacks[Commands.DOM_RENDER_SIZE] = domRenderSize;
    this._commandCallbacks[Commands.CHANGE_TRANSFORM] = changeTransform;
    this._commandCallbacks[Commands.CHANGE_SIZE] = changeSize;
    this._commandCallbacks[Commands.CHANGE_STYLE] = changeProperty;
    this._commandCallbacks[Commands.CHANGE_CONTENT] = changeContent;
    this._commandCallbacks[Commands.CHANGE_ATTRIBUTE] = changeAttribute;
    this._commandCallbacks[Commands.ADD_CLASS] = addClass;
    this._commandCallbacks[Commands.REMOVE_CLASS] = removeClass;
    this._commandCallbacks[Commands.SUBSCRIBE] = subscribe;
    this._commandCallbacks[Commands.UNSUBSCRIBE] = unsubscribe;
    this._commandCallbacks[Commands.PINHOLE_PROJECTION] = pinholeProjection;
    this._commandCallbacks[Commands.ORTHOGRAPHIC_PROJECTION] = orthographicProjection;
    this._commandCallbacks[Commands.CHANGE_VIEW_TRANSFORM] = changeViewTransform;
    this._commandCallbacks[Commands.PREVENT_DEFAULT] = preventDefault;
    this._commandCallbacks[Commands.ALLOW_DEFAULT] = allowDefault;
    this._commandCallbacks[Commands.READY] = ready;
    this._commandCallbacks[Commands.REMOVE_SCENE] = removeScene;
};

/**
 * Gets the size of the parent element of the DOMRenderer for this context.
 *
 * @method
 *
 * @return {undefined} undefined
 */
Context.prototype.getRootSize = function getRootSize() {
    return [
        this._rootEl.offsetWidth,
        this._rootEl.offsetHeight
    ];
};


/**
 * Initializes the context if the `READY` command has been received earlier.
 *
 * @return {undefined} undefined
 */
Context.prototype.checkInit = function checkInit () {
    if (this._initDOM) {
        this._domRendererRootEl.style.visibility = 'visible';
        this._initDOM = false;
    }
};

/**
 * Handles delegation of commands to renderers of this context.
 *
 * @method
 *
 * @param {String} path String used as identifier of a given node in the
 * scene graph.
 * @param {Array} commands List of all commands from this frame.
 * @param {Number} iterator Number indicating progress through the command
 * queue.
 *
 * @return {Number} iterator indicating progress through the command queue.
 */
Context.prototype.receive = function receive(path, commands, iterator) {
    var localIterator = iterator;

    var command = commands[++localIterator];

    this._domRenderer.loadPath(path);

    while (command != null) {
        if (command === Commands.WITH || command === Commands.TIME) return localIterator - 1;
        else localIterator = this._commandCallbacks[command](this, path, commands, localIterator) + 1;
        command = commands[localIterator];
    }

    return localIterator;
};

/**
 * Getter method used for retrieving the used DOMRenderer.
 *
 * @method
 *
 * @return {DOMRenderer}    The DOMRenderer being used by the Context.
 */
Context.prototype.getDOMRenderer = function getDOMRenderer() {
    return this._domRenderer;
};

Context.prototype.cleanup = function cleanup () {
    this._rootEl.removeChild(this._domRendererRootEl);
    if (this._webGLRendererRootEl)
        this._rootEl.removeChild(this._webGLRendererRootEl);
};

// Command Callbacks
function preventDefault (context, path, commands, iterator) {
    context._domRenderer.preventDefault(commands[++iterator]);
    return iterator;
}

function allowDefault (context, path, commands, iterator) {
    context._domRenderer.allowDefault(commands[++iterator]);
    return iterator;
}

function ready (context, path, commands, iterator) {
    context._initDOM = true;
    return iterator;
}

function initDOM (context, path, commands, iterator) {
    context._domRenderer.insertEl(commands[++iterator]);
    return iterator;
}

function domRenderSize (context, path, commands, iterator) {
    context._domRenderer.getSizeOf(commands[++iterator]);
    return iterator;
}

function changeTransform (context, path, commands, iterator) {
    var temp = context._currentTransform;

    temp[0] = commands[++iterator];
    temp[1] = commands[++iterator];
    temp[2] = commands[++iterator];
    temp[3] = commands[++iterator];
    temp[4] = commands[++iterator];
    temp[5] = commands[++iterator];
    temp[6] = commands[++iterator];
    temp[7] = commands[++iterator];
    temp[8] = commands[++iterator];
    temp[9] = commands[++iterator];
    temp[10] = commands[++iterator];
    temp[11] = commands[++iterator];
    temp[12] = commands[++iterator];
    temp[13] = commands[++iterator];
    temp[14] = commands[++iterator];
    temp[15] = commands[++iterator];

    context._domRenderer.setMatrix(temp);

    return iterator;
}

function changeSize (context, path, commands, iterator) {
    var width = commands[++iterator];
    var height = commands[++iterator];

    context._domRenderer.setSize(width, height);

    return iterator;
}

function changeProperty (context, path, commands, iterator) {
    context._domRenderer.setProperty(commands[++iterator], commands[++iterator]);
    return iterator;
}

function changeContent (context, path, commands, iterator) {
    context._domRenderer.setContent(commands[++iterator]);
    return iterator;
}

function changeAttribute (context, path, commands, iterator) {
    context._domRenderer.setAttribute(commands[++iterator], commands[++iterator]);
    return iterator;
}

function addClass (context, path, commands, iterator) {
    context._domRenderer.addClass(commands[++iterator]);
    return iterator;
}

function removeClass (context, path, commands, iterator) {
    context._domRenderer.removeClass(commands[++iterator]);
    return iterator;
}

function subscribe (context, path, commands, iterator) {
    context._domRenderer.subscribe(commands[++iterator]);
    return iterator;
}

function unsubscribe (context, path, commands, iterator) {
    context._domRenderer.unsubscribe(commands[++iterator]);
    return iterator;
}

function pinholeProjection (context, path, commands, iterator) {
    context._renderState.projectionType = Camera.PINHOLE_PROJECTION;
    context._renderState.perspectiveTransform[11] = -1 / commands[++iterator];
    context._renderState.perspectiveDirty = true;
    return iterator;
}

function orthographicProjection (context, path, commands, iterator) {
    context._renderState.projectionType = Camera.ORTHOGRAPHIC_PROJECTION;
    context._renderState.perspectiveTransform[11] = 0;
    context._renderState.perspectiveDirty = true;
    return iterator;
}

function changeViewTransform (context, path, commands, iterator) {
    context._renderState.viewTransform[0] = commands[++iterator];
    context._renderState.viewTransform[1] = commands[++iterator];
    context._renderState.viewTransform[2] = commands[++iterator];
    context._renderState.viewTransform[3] = commands[++iterator];

    context._renderState.viewTransform[4] = commands[++iterator];
    context._renderState.viewTransform[5] = commands[++iterator];
    context._renderState.viewTransform[6] = commands[++iterator];
    context._renderState.viewTransform[7] = commands[++iterator];

    context._renderState.viewTransform[8] = commands[++iterator];
    context._renderState.viewTransform[9] = commands[++iterator];
    context._renderState.viewTransform[10] = commands[++iterator];
    context._renderState.viewTransform[11] = commands[++iterator];

    context._renderState.viewTransform[12] = commands[++iterator];
    context._renderState.viewTransform[13] = commands[++iterator];
    context._renderState.viewTransform[14] = commands[++iterator];
    context._renderState.viewTransform[15] = commands[++iterator];

    context._renderState.viewDirty = true;
    return iterator;
}

function removeScene (context, path, commands, iterator) {
    context._compositor.removeContext(path);
    return commands.length - 1;
}

module.exports = Context;

},{"../components/Camera":25,"../core/Commands":32,"../dom-renderers/DOMRenderer":47}],65:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Commands = require('../core/Commands');

/**
 * The UIManager is being updated by an Engine by consecutively calling its
 * `update` method. It can either manage a real Web-Worker or the global
 * FamousEngine core singleton.
 *
 * @example
 * var compositor = new Compositor();
 * var engine = new Engine();
 *
 * // Using a Web Worker
 * var worker = new Worker('worker.bundle.js');
 * var threadmanger = new UIManager(worker, compositor, engine);
 *
 * // Without using a Web Worker
 * var threadmanger = new UIManager(Famous, compositor, engine);
 *
 * @class  UIManager
 * @constructor
 *
 * @param {Famous|Worker} thread The thread being used to receive messages
 * from and post messages to. Expected to expose a WebWorker-like API, which
 * means providing a way to listen for updates by setting its `onmessage`
 * property and sending updates using `postMessage`.
 * @param {Compositor} compositor an instance of Compositor used to extract
 * enqueued draw commands from to be sent to the thread.
 * @param {RenderLoop} renderLoop an instance of Engine used for executing
 * the `ENGINE` commands on.
 */
function UIManager (thread, compositor, renderLoop) {
    this._thread = thread;
    this._compositor = compositor;
    this._renderLoop = renderLoop;

    this._renderLoop.update(this);

    var _this = this;
    this._thread.onmessage = function (ev) {
        var message = ev.data ? ev.data : ev;
        if (message[0] === Commands.ENGINE) {
            switch (message[1]) {
                case Commands.START:
                    _this._engine.start();
                    break;
                case Commands.STOP:
                    _this._engine.stop();
                    break;
                default:
                    console.error(
                        'Unknown ENGINE command "' + message[1] + '"'
                    );
                    break;
            }
        }
        else {
            _this._compositor.receiveCommands(message);
        }
    };
    this._thread.onerror = function (error) {
        console.error(error);
    };
}

/**
 * Returns the thread being used by the UIManager.
 * This could either be an an actual web worker or a `FamousEngine` singleton.
 *
 * @method
 *
 * @return {Worker|FamousEngine} Either a web worker or a `FamousEngine` singleton.
 */
UIManager.prototype.getThread = function getThread() {
    return this._thread;
};

/**
 * Returns the compositor being used by this UIManager.
 *
 * @method
 *
 * @return {Compositor} The compositor used by the UIManager.
 */
UIManager.prototype.getCompositor = function getCompositor() {
    return this._compositor;
};

/**
 * Returns the render loop currently being used by the UIManager.
 *
 * @method
 *
 * @return {RenderLoop}  The registered render loop used for updating the
 * UIManager.
 */
UIManager.prototype.getRenderLoop = function getRenderLoop() {
    return this._renderLoop;
};

/**
 * Update method being invoked by the Engine on every `requestAnimationFrame`.
 * Used for updating the notion of time within the managed thread by sending
 * a FRAME command and sending messages to
 *
 * @method
 *
 * @param  {Number} time unix timestamp to be passed down to the worker as a
 * FRAME command
 * @return {undefined} undefined
 */
UIManager.prototype.update = function update (time) {
    this._thread.postMessage([Commands.FRAME, time]);
    var threadMessages = this._compositor.drawCommands();
    this._thread.postMessage(threadMessages);
    this._compositor.clearCommands();
};

module.exports = UIManager;

},{"../core/Commands":32}],66:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var css = '.famous-dom-renderer {' +
    'width:100%;' +
    'height:100%;' +
    'transform-style:preserve-3d;' +
    '-webkit-transform-style:preserve-3d;' +
    '-webkit-transform:translateZ(0);' +
    'transform:translateZ(0);' +
'}' +

'.famous-dom-element {' +
    '-webkit-transform-origin:0% 0%;' +
    'transform-origin:0% 0%;' +
    '-webkit-backface-visibility:visible;' +
    'backface-visibility:visible;' +
    '-webkit-transform-style:preserve-3d;' +
    'transform-style:preserve-3d;' +
    '-webkit-tap-highlight-color:transparent;' +
    'pointer-events:auto;' +
    'z-index:1;' +
'}' +

'.famous-dom-element-content,' +
'.famous-dom-element {' +
    'position:absolute;' +
    'box-sizing:border-box;' +
    '-moz-box-sizing:border-box;' +
    '-webkit-box-sizing:border-box;' +
'}' +

'.famous-webgl-renderer {' +
    '-webkit-transform:translateZ(1000000px);' +  /* TODO: Fix when Safari Fixes*/
    'transform:translateZ(1000000px);' +
    'pointer-events:none;' +
    'position:absolute;' +
    'z-index:1;' +
    'top:0;' +
    'width:100%;' +
    'height:100%;' +
'}';

var INJECTED = typeof document === 'undefined';

function injectCSS() {
    if (INJECTED) return;
    INJECTED = true;
    if (document.createStyleSheet) {
        var sheet = document.createStyleSheet();
        sheet.cssText = css;
    }
    else {
        var head = document.getElementsByTagName('head')[0];
        var style = document.createElement('style');

        if (style.styleSheet) {
            style.styleSheet.cssText = css;
        }
        else {
            style.appendChild(document.createTextNode(css));
        }

        (head ? head : document.documentElement).appendChild(style);
    }
}

module.exports = injectCSS;

},{}],67:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

/*jshint -W008 */

'use strict';

/**
 * A library of curves which map an animation explicitly as a function of time.
 *
 * @namespace
 * @property {Function} linear
 * @property {Function} easeIn
 * @property {Function} easeOut
 * @property {Function} easeInOut
 * @property {Function} easeOutBounce
 * @property {Function} spring
 * @property {Function} inQuad
 * @property {Function} outQuad
 * @property {Function} inOutQuad
 * @property {Function} inCubic
 * @property {Function} outCubic
 * @property {Function} inOutCubic
 * @property {Function} inQuart
 * @property {Function} outQuart
 * @property {Function} inOutQuart
 * @property {Function} inQuint
 * @property {Function} outQuint
 * @property {Function} inOutQuint
 * @property {Function} inSine
 * @property {Function} outSine
 * @property {Function} inOutSine
 * @property {Function} inExpo
 * @property {Function} outExpo
 * @property {Function} inOutExp
 * @property {Function} inCirc
 * @property {Function} outCirc
 * @property {Function} inOutCirc
 * @property {Function} inElastic
 * @property {Function} outElastic
 * @property {Function} inOutElastic
 * @property {Function} inBounce
 * @property {Function} outBounce
 * @property {Function} inOutBounce
 * @property {Function} flat            - Useful for delaying the execution of
 *                                        a subsequent transition.
 */
var Curves = {
    linear: function(t) {
        return t;
    },

    easeIn: function(t) {
        return t*t;
    },

    easeOut: function(t) {
        return t*(2-t);
    },

    easeInOut: function(t) {
        if (t <= 0.5) return 2*t*t;
        else return -2*t*t + 4*t - 1;
    },

    easeOutBounce: function(t) {
        return t*(3 - 2*t);
    },

    spring: function(t) {
        return (1 - t) * Math.sin(6 * Math.PI * t) + t;
    },

    inQuad: function(t) {
        return t*t;
    },

    outQuad: function(t) {
        return -(t-=1)*t+1;
    },

    inOutQuad: function(t) {
        if ((t/=.5) < 1) return .5*t*t;
        return -.5*((--t)*(t-2) - 1);
    },

    inCubic: function(t) {
        return t*t*t;
    },

    outCubic: function(t) {
        return ((--t)*t*t + 1);
    },

    inOutCubic: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t;
        return .5*((t-=2)*t*t + 2);
    },

    inQuart: function(t) {
        return t*t*t*t;
    },

    outQuart: function(t) {
        return -((--t)*t*t*t - 1);
    },

    inOutQuart: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t;
        return -.5 * ((t-=2)*t*t*t - 2);
    },

    inQuint: function(t) {
        return t*t*t*t*t;
    },

    outQuint: function(t) {
        return ((--t)*t*t*t*t + 1);
    },

    inOutQuint: function(t) {
        if ((t/=.5) < 1) return .5*t*t*t*t*t;
        return .5*((t-=2)*t*t*t*t + 2);
    },

    inSine: function(t) {
        return -1.0*Math.cos(t * (Math.PI/2)) + 1.0;
    },

    outSine: function(t) {
        return Math.sin(t * (Math.PI/2));
    },

    inOutSine: function(t) {
        return -.5*(Math.cos(Math.PI*t) - 1);
    },

    inExpo: function(t) {
        return (t===0) ? 0.0 : Math.pow(2, 10 * (t - 1));
    },

    outExpo: function(t) {
        return (t===1.0) ? 1.0 : (-Math.pow(2, -10 * t) + 1);
    },

    inOutExpo: function(t) {
        if (t===0) return 0.0;
        if (t===1.0) return 1.0;
        if ((t/=.5) < 1) return .5 * Math.pow(2, 10 * (t - 1));
        return .5 * (-Math.pow(2, -10 * --t) + 2);
    },

    inCirc: function(t) {
        return -(Math.sqrt(1 - t*t) - 1);
    },

    outCirc: function(t) {
        return Math.sqrt(1 - (--t)*t);
    },

    inOutCirc: function(t) {
        if ((t/=.5) < 1) return -.5 * (Math.sqrt(1 - t*t) - 1);
        return .5 * (Math.sqrt(1 - (t-=2)*t) + 1);
    },

    inElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return -(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/ p));
    },

    outElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if (t===1) return 1.0;  if (!p) p=.3;
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        return a*Math.pow(2,-10*t) * Math.sin((t-s)*(2*Math.PI)/p) + 1.0;
    },

    inOutElastic: function(t) {
        var s=1.70158;var p=0;var a=1.0;
        if (t===0) return 0.0;  if ((t/=.5)===2) return 1.0;  if (!p) p=(.3*1.5);
        s = p/(2*Math.PI) * Math.asin(1.0/a);
        if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p));
        return a*Math.pow(2,-10*(t-=1)) * Math.sin((t-s)*(2*Math.PI)/p)*.5 + 1.0;
    },

    inBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return t*t*((s+1)*t - s);
    },

    outBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        return ((--t)*t*((s+1)*t + s) + 1);
    },

    inOutBack: function(t, s) {
        if (s === undefined) s = 1.70158;
        if ((t/=.5) < 1) return .5*(t*t*(((s*=(1.525))+1)*t - s));
        return .5*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2);
    },

    inBounce: function(t) {
        return 1.0 - Curves.outBounce(1.0-t);
    },

    outBounce: function(t) {
        if (t < (1/2.75)) {
            return (7.5625*t*t);
        }
        else if (t < (2/2.75)) {
            return (7.5625*(t-=(1.5/2.75))*t + .75);
        }
        else if (t < (2.5/2.75)) {
            return (7.5625*(t-=(2.25/2.75))*t + .9375);
        }
        else {
            return (7.5625*(t-=(2.625/2.75))*t + .984375);
        }
    },

    inOutBounce: function(t) {
        if (t < .5) return Curves.inBounce(t*2) * .5;
        return Curves.outBounce(t*2-1.0) * .5 + .5;
    },

    flat: function() {
        return 0;
    }
};

module.exports = Curves;

},{}],68:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var Curves = require('./Curves');
var FamousEngine = require('../core/FamousEngine');

/**
 * A state maintainer for a smooth transition between
 *    numerically-specified states. Example numeric states include floats and
 *    arrays of floats objects.
 *
 * An initial state is set with the constructor or using
 *     {@link Transitionable#from}. Subsequent transitions consist of an
 *     intermediate state, easing curve, duration and callback. The final state
 *     of each transition is the initial state of the subsequent one. Calls to
 *     {@link Transitionable#get} provide the interpolated state along the way.
 *
 * Note that there is no event loop here - calls to {@link Transitionable#get}
 *    are the only way to find state projected to the current (or provided)
 *    time and are the only way to trigger callbacks and mutate the internal
 *    transition queue.
 *
 * @example
 * var t = new Transitionable([0, 0]);
 * t
 *     .to([100, 0], 'linear', 1000)
 *     .delay(1000)
 *     .to([200, 0], 'outBounce', 1000);
 *
 * var div = document.createElement('div');
 * div.style.background = 'blue';
 * div.style.width = '100px';
 * div.style.height = '100px';
 * document.body.appendChild(div);
 *
 * div.addEventListener('click', function() {
 *     t.isPaused() ? t.resume() : t.pause();
 * });
 *
 * requestAnimationFrame(function loop() {
 *     div.style.transform = 'translateX(' + t.get()[0] + 'px)' + ' translateY(' + t.get()[1] + 'px)';
 *     requestAnimationFrame(loop);
 * });
 *
 * @class Transitionable
 * @constructor
 * @param {Number|Array.Number} initialState    initial state to transition
 *                                              from - equivalent to a pursuant
 *                                              invocation of
 *                                              {@link Transitionable#from}
 */
function Transitionable(initialState) {
    this._queue = [];
    this._from = null;
    this._state = null;
    this._startedAt = null;
    this._pausedAt = null;
    if (initialState != null) this.from(initialState);
}

/**
 * Internal Clock used for determining the current time for the ongoing
 * transitions.
 *
 * @type {Performance|Date|Clock}
 */
Transitionable.Clock = FamousEngine.getClock();

/**
 * Registers a transition to be pushed onto the internal queue.
 *
 * @method to
 * @chainable
 *
 * @param  {Number|Array.Number}    finalState              final state to
 *                                                          transiton to
 * @param  {String|Function}        [curve=Curves.linear]   easing function
 *                                                          used for
 *                                                          interpolating
 *                                                          [0, 1]
 * @param  {Number}                 [duration=100]          duration of
 *                                                          transition
 * @param  {Function}               [callback]              callback function
 *                                                          to be called after
 *                                                          the transition is
 *                                                          complete
 * @param  {String}                 [method]                method used for
 *                                                          interpolation
 *                                                          (e.g. slerp)
 * @return {Transitionable}         this
 */
Transitionable.prototype.to = function to(finalState, curve, duration, callback, method) {
    curve = curve != null && curve.constructor === String ? Curves[curve] : curve;
    if (this._queue.length === 0) {
        this._startedAt = this.constructor.Clock.now();
        this._pausedAt = null;
    }
    this._queue.push(
        finalState,
        curve != null ? curve : Curves.linear,
        duration != null ? duration : 100,
        callback,
        method
    );
    return this;
};

/**
 * Resets the transition queue to a stable initial state.
 *
 * @method from
 * @chainable
 *
 * @param  {Number|Array.Number}    initialState    initial state to
 *                                                  transition from
 * @return {Transitionable}         this
 */
Transitionable.prototype.from = function from(initialState) {
    this._state = initialState;
    this._from = this._sync(null, this._state);
    this._queue.length = 0;
    this._startedAt = this.constructor.Clock.now();
    this._pausedAt = null;
    return this;
};

/**
 * Delays the execution of the subsequent transition for a certain period of
 * time.
 *
 * @method delay
 * @chainable
 *
 * @param {Number}      duration    delay time in ms
 * @param {Function}    [callback]  Zero-argument function to call on observed
 *                                  completion (t=1)
 * @return {Transitionable}         this
 */
Transitionable.prototype.delay = function delay(duration, callback) {
    var endState = this._queue.length > 0 ? this._queue[this._queue.length - 5] : this._state;
    return this.to(endState, Curves.flat, duration, callback);
};

/**
 * Overrides current transition.
 *
 * @method override
 * @chainable
 *
 * @param  {Number|Array.Number}    [finalState]    final state to transiton to
 * @param  {String|Function}        [curve]         easing function used for
 *                                                  interpolating [0, 1]
 * @param  {Number}                 [duration]      duration of transition
 * @param  {Function}               [callback]      callback function to be
 *                                                  called after the transition
 *                                                  is complete
 * @param {String}                  [method]        optional method used for
 *                                                  interpolating between the
 *                                                  values. Set to `slerp` for
 *                                                  spherical linear
 *                                                  interpolation.
 * @return {Transitionable}         this
 */
Transitionable.prototype.override = function override(finalState, curve, duration, callback, method) {
    if (this._queue.length > 0) {
        if (finalState != null) this._queue[0] = finalState;
        if (curve != null)      this._queue[1] = curve.constructor === String ? Curves[curve] : curve;
        if (duration != null)   this._queue[2] = duration;
        if (callback != null)   this._queue[3] = callback;
        if (method != null)     this._queue[4] = method;
    }
    return this;
};


/**
 * Used for interpolating between the start and end state of the currently
 * running transition
 *
 * @method  _interpolate
 * @private
 *
 * @param  {Object|Array|Number} output     Where to write to (in order to avoid
 *                                          object allocation and therefore GC).
 * @param  {Object|Array|Number} from       Start state of current transition.
 * @param  {Object|Array|Number} to         End state of current transition.
 * @param  {Number} progress                Progress of the current transition,
 *                                          in [0, 1]
 * @param  {String} method                  Method used for interpolation (e.g.
 *                                          slerp)
 * @return {Object|Array|Number}            output
 */
Transitionable.prototype._interpolate = function _interpolate(output, from, to, progress, method) {
    if (to instanceof Object) {
        if (method === 'slerp') {
            var x, y, z, w;
            var qx, qy, qz, qw;
            var omega, cosomega, sinomega, scaleFrom, scaleTo;

            x = from[0];
            y = from[1];
            z = from[2];
            w = from[3];

            qx = to[0];
            qy = to[1];
            qz = to[2];
            qw = to[3];

            if (progress === 1) {
                output[0] = qx;
                output[1] = qy;
                output[2] = qz;
                output[3] = qw;
                return output;
            }

            cosomega = w * qw + x * qx + y * qy + z * qz;
            if ((1.0 - cosomega) > 1e-5) {
                omega = Math.acos(cosomega);
                sinomega = Math.sin(omega);
                scaleFrom = Math.sin((1.0 - progress) * omega) / sinomega;
                scaleTo = Math.sin(progress * omega) / sinomega;
            }
            else {
                scaleFrom = 1.0 - progress;
                scaleTo = progress;
            }

            output[0] = x * scaleFrom + qx * scaleTo;
            output[1] = y * scaleFrom + qy * scaleTo;
            output[2] = z * scaleFrom + qz * scaleTo;
            output[3] = w * scaleFrom + qw * scaleTo;
        }
        else if (to instanceof Array) {
            for (var i = 0, len = to.length; i < len; i++) {
                output[i] = this._interpolate(output[i], from[i], to[i], progress, method);
            }
        }
        else {
            for (var key in to) {
                output[key] = this._interpolate(output[key], from[key], to[key], progress, method);
            }
        }
    }
    else {
        output = from + progress * (to - from);
    }
    return output;
};


/**
 * Internal helper method used for synchronizing the current, absolute state of
 * a transition to a given output array, object literal or number. Supports
 * nested state objects by through recursion.
 *
 * @method  _sync
 * @private
 *
 * @param  {Number|Array|Object} output     Where to write to (in order to avoid
 *                                          object allocation and therefore GC).
 * @param  {Number|Array|Object} input      Input state to proxy onto the
 *                                          output.
 * @return {Number|Array|Object} output     Passed in output object.
 */
Transitionable.prototype._sync = function _sync(output, input) {
    if (typeof input === 'number') output = input;
    else if (input instanceof Array) {
        if (output == null) output = [];
        for (var i = 0, len = input.length; i < len; i++) {
            output[i] = _sync(output[i], input[i]);
        }
    }
    else if (input instanceof Object) {
        if (output == null) output = {};
        for (var key in input) {
            output[key] = _sync(output[key], input[key]);
        }
    }
    return output;
};

/**
 * Get interpolated state of current action at provided time. If the last
 *    action has completed, invoke its callback.
 *
 * @method get
 *
 * @param {Number=} t               Evaluate the curve at a normalized version
 *                                  of this time. If omitted, use current time
 *                                  (Unix epoch time retrieved from Clock).
 * @return {Number|Array.Number}    Beginning state interpolated to this point
 *                                  in time.
 */
Transitionable.prototype.get = function get(t) {
    if (this._queue.length === 0) return this._state;

    t = this._pausedAt ? this._pausedAt : t;
    t = t ? t : this.constructor.Clock.now();

    var progress = (t - this._startedAt) / this._queue[2];
    this._state = this._interpolate(
        this._state,
        this._from,
        this._queue[0],
        this._queue[1](progress > 1 ? 1 : progress),
        this._queue[4]
    );
    var state = this._state;
    if (progress >= 1) {
        this._startedAt = this._startedAt + this._queue[2];
        this._from = this._sync(this._from, this._state);
        this._queue.shift();
        this._queue.shift();
        this._queue.shift();
        var callback = this._queue.shift();
        this._queue.shift();
        if (callback) callback();
    }
    return progress > 1 ? this.get() : state;
};

/**
 * Is there at least one transition pending completion?
 *
 * @method isActive
 *
 * @return {Boolean}    Boolean indicating whether there is at least one pending
 *                      transition. Paused transitions are still being
 *                      considered active.
 */
Transitionable.prototype.isActive = function isActive() {
    return this._queue.length > 0;
};

/**
 * Halt transition at current state and erase all pending actions.
 *
 * @method halt
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.halt = function halt() {
    return this.from(this.get());
};

/**
 * Pause transition. This will not erase any actions.
 *
 * @method pause
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.pause = function pause() {
    this._pausedAt = this.constructor.Clock.now();
    return this;
};

/**
 * Has the current action been paused?
 *
 * @method isPaused
 * @chainable
 *
 * @return {Boolean} if the current action has been paused
 */
Transitionable.prototype.isPaused = function isPaused() {
    return !!this._pausedAt;
};

/**
 * Resume a previously paused transition.
 *
 * @method resume
 * @chainable
 *
 * @return {Transitionable} this
 */
Transitionable.prototype.resume = function resume() {
    var diff = this._pausedAt - this._startedAt;
    this._startedAt = this.constructor.Clock.now() - diff;
    this._pausedAt = null;
    return this;
};

/**
 * Cancel all transitions and reset to a stable state
 *
 * @method reset
 * @chainable
 * @deprecated Use `.from` instead!
 *
 * @param {Number|Array.Number|Object.<number, number>} start
 *    stable state to set to
 * @return {Transitionable}                             this
 */
Transitionable.prototype.reset = function(start) {
    return this.from(start);
};

/**
 * Add transition to end state to the queue of pending transitions. Special
 *    Use: calling without a transition resets the object to that state with
 *    no pending actions
 *
 * @method set
 * @chainable
 * @deprecated Use `.to` instead!
 *
 * @param {Number|FamousEngineMatrix|Array.Number|Object.<number, number>} state
 *    end state to which we interpolate
 * @param {transition=} transition object of type {duration: number, curve:
 *    f[0,1] -> [0,1] or name}. If transition is omitted, change will be
 *    instantaneous.
 * @param {function()=} callback Zero-argument function to call on observed
 *    completion (t=1)
 * @return {Transitionable} this
 */
Transitionable.prototype.set = function(state, transition, callback) {
    if (transition == null) {
        this.from(state);
        if (callback) callback();
    }
    else {
        this.to(state, transition.curve, transition.duration, callback, transition.method);
    }
    return this;
};

module.exports = Transitionable;

},{"../core/FamousEngine":35,"./Curves":67}],69:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

/**
 * A lightweight, featureless EventEmitter.
 *
 * @class EventEmitter
 * @constructor
 */
function EventEmitter () {
    this._events = {};
}

/**
 * Adds a listener for the specified event (= key).
 *
 * @method on
 * @chainable
 *
 * @param  {String}   key       The event type (e.g. `click`).
 * @param  {Function} callback  A callback function to be invoked whenever `key`
 *                              event is being triggered.
 * @return {Function} destroy   A function to call if you want to remove the
 *                              callback.
 */
EventEmitter.prototype.on = function on (key, callback) {
    if (!this._events[key]) this._events[key] = [];
    var callbackList = this._events[key];
    callbackList.push(callback);
    return function () {
        callbackList.splice(callbackList.indexOf(callback), 1);
    };
};

/**
 * Removes a previously added event listener.
 *
 * @method off
 * @chainable
 *
 * @param  {String} key         The event type from which the callback function
 *                              should be removed.
 * @param  {Function} callback  The callback function to be removed from the
 *                              listeners for key.
 * @return {EventEmitter} this
 */
EventEmitter.prototype.off = function off (key, callback) {
    var events = this._events[key];
    if (events) events.splice(events.indexOf(callback), 1);
    return this;
};

/**
 * Invokes all the previously for this key registered callbacks.
 *
 * @method trigger
 * @chainable
 *
 * @param  {String}        key      The event type.
 * @param  {Object}        payload  The event payload (event object).
 * @return {EventEmitter} this
 */
EventEmitter.prototype.trigger = function trigger (key, payload) {
    var events = this._events[key];
    if (events) {
        var i = 0;
        var len = events.length;
        for (; i < len ; i++) events[i](payload);
    }
    return this;
};

module.exports = EventEmitter;

},{}],70:[function(require,module,exports){
'use strict';

function assert(ok, errorMsg) {
    if (!ok) {
        if (!errorMsg) {
            throw new Error(
                'Condition not met. Debug in development environment for ' +
                'further inspection and error message.'
            );
        }

        throw new Error('Failed assertion: ' + errorMsg);
    }
}

module.exports = assert;

},{}],71:[function(require,module,exports){
/**
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Famous Industries Inc.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

'use strict';

var PREFIXES = ['', '-ms-', '-webkit-', '-moz-', '-o-'];

/**
 * A helper function used for determining the vendor prefixed version of the
 * passed in CSS property.
 *
 * Vendor checks are being conducted in the following order:
 *
 * 1. (no prefix)
 * 2. `-mz-`
 * 3. `-webkit-`
 * 4. `-moz-`
 * 5. `-o-`
 *
 * @method vendorPrefix
 *
 * @param {String} property     CSS property (no camelCase), e.g.
 *                              `border-radius`.
 * @return {String} prefixed    Vendor prefixed version of passed in CSS
 *                              property (e.g. `-webkit-border-radius`).
 */
function vendorPrefix(property) {
    for (var i = 0; i < PREFIXES.length; i++) {
        var prefixed = PREFIXES[i] + property;
        if (document.documentElement.style[prefixed] === '') {
            return prefixed;
        }
    }
    return property;
}

module.exports = vendorPrefix;

},{}]},{},[13])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwiL1VzZXJzL21pY2hhZWxvYnJpZW5hL01lL3NyYy9BcHAvaW5kZXguanMiLCIvVXNlcnMvbWljaGFlbG9icmllbmEvTWUvc3JjL2Fib3V0L0JsdXJiLmpzIiwiL1VzZXJzL21pY2hhZWxvYnJpZW5hL01lL3NyYy9hYm91dC9MaXN0ZW5pbmdUby5qcyIsIi9Vc2Vycy9taWNoYWVsb2JyaWVuYS9NZS9zcmMvYWJvdXQvUGxheWluZy5qcyIsIi9Vc2Vycy9taWNoYWVsb2JyaWVuYS9NZS9zcmMvYWJvdXQvUmVhZGluZy5qcyIsIi9Vc2Vycy9taWNoYWVsb2JyaWVuYS9NZS9zcmMvYWJvdXQvaW5kZXguanMiLCIvVXNlcnMvbWljaGFlbG9icmllbmEvTWUvc3JjL2hlbHBlcnMvYm94L0JveC5qcyIsIi9Vc2Vycy9taWNoYWVsb2JyaWVuYS9NZS9zcmMvaGVscGVycy9ib3gvQnJlYXRoZXIuanMiLCIvVXNlcnMvbWljaGFlbG9icmllbmEvTWUvc3JjL2hlbHBlcnMvYm94L01pZGRsZUJveC5qcyIsIi9Vc2Vycy9taWNoYWVsb2JyaWVuYS9NZS9zcmMvaGVscGVycy9ib3gvT3V0ZXJCb3guanMiLCIvVXNlcnMvbWljaGFlbG9icmllbmEvTWUvc3JjL2hlbHBlcnMvY29sb3JzLmpzIiwiL1VzZXJzL21pY2hhZWxvYnJpZW5hL01lL3NyYy9pbmRleC5qcyIsIi9Vc2Vycy9taWNoYWVsb2JyaWVuYS9NZS9zcmMvbGF5ZXJzL2luZGV4LmpzIiwiL1VzZXJzL21pY2hhZWxvYnJpZW5hL01lL3NyYy9sYXlvdXRzL0dyaWQuanMiLCIvVXNlcnMvbWljaGFlbG9icmllbmEvTWUvc3JjL2xvZ28vaW5kZXguanMiLCIvVXNlcnMvbWljaGFlbG9icmllbmEvTWUvc3JjL21haW4vaW5kZXguanMiLCIvVXNlcnMvbWljaGFlbG9icmllbmEvTWUvc3JjL21vZGFsL2luZGV4LmpzIiwiL1VzZXJzL21pY2hhZWxvYnJpZW5hL01lL3NyYy9zYW5kYm94L1RlbnRhY2xlcy9pbmRleC5qcyIsIi9Vc2Vycy9taWNoYWVsb2JyaWVuYS9NZS9zcmMvc2FuZGJveC9UdW5uZWxzL2luZGV4LmpzIiwiL1VzZXJzL21pY2hhZWxvYnJpZW5hL01lL3NyYy9zYW5kYm94L2luZGV4LmpzIiwiL1VzZXJzL21pY2hhZWxvYnJpZW5hL01lL3NyYy9zYW5kYm94L3NsaWRpbmdHcmlkL2luZGV4LmpzIiwiL1VzZXJzL21pY2hhZWxvYnJpZW5hL01lL3NyYy9zaWRlYmFyL2luZGV4LmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvY29tcG9uZW50cy9BbGlnbi5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvbXBvbmVudHMvQ2FtZXJhLmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvY29tcG9uZW50cy9Nb3VudFBvaW50LmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvY29tcG9uZW50cy9PcGFjaXR5LmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvY29tcG9uZW50cy9Qb3NpdGlvbi5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvbXBvbmVudHMvU2l6ZS5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvcmUvQ2hhbm5lbC5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvcmUvQ2xvY2suanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9jb3JlL0NvbW1hbmRzLmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvY29yZS9EaXNwYXRjaC5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvcmUvRXZlbnQuanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9jb3JlL0ZhbW91c0VuZ2luZS5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvcmUvTm9kZS5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvcmUvT3BhY2l0eS5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvcmUvT3BhY2l0eVN5c3RlbS5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvcmUvUGF0aC5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvcmUvU2NlbmUuanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9jb3JlL1NpemUuanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9jb3JlL1NpemVTeXN0ZW0uanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9jb3JlL1N5c3RlbS5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2NvcmUvVHJhbnNmb3JtLmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvY29yZS9UcmFuc2Zvcm1TeXN0ZW0uanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudC5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2RvbS1yZW5kZXJlcnMvRE9NUmVuZGVyZXIuanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9kb20tcmVuZGVyZXJzL0VsZW1lbnRDYWNoZS5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2RvbS1yZW5kZXJlcnMvTWF0aC5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2RvbS1yZW5kZXJlcnMvVm9pZEVsZW1lbnRzLmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvZG9tLXJlbmRlcmVycy9ldmVudHMvQ29tcG9zaXRpb25FdmVudC5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2RvbS1yZW5kZXJlcnMvZXZlbnRzL0V2ZW50LmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvZG9tLXJlbmRlcmVycy9ldmVudHMvRXZlbnRNYXAuanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9kb20tcmVuZGVyZXJzL2V2ZW50cy9Gb2N1c0V2ZW50LmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvZG9tLXJlbmRlcmVycy9ldmVudHMvSW5wdXRFdmVudC5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2RvbS1yZW5kZXJlcnMvZXZlbnRzL0tleWJvYXJkRXZlbnQuanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9kb20tcmVuZGVyZXJzL2V2ZW50cy9Nb3VzZUV2ZW50LmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvZG9tLXJlbmRlcmVycy9ldmVudHMvVG91Y2hFdmVudC5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL2RvbS1yZW5kZXJlcnMvZXZlbnRzL1VJRXZlbnQuanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9kb20tcmVuZGVyZXJzL2V2ZW50cy9XaGVlbEV2ZW50LmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvcG9seWZpbGxzL2FuaW1hdGlvbkZyYW1lLmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvcmVuZGVyLWxvb3BzL1JlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AuanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy9yZW5kZXJlcnMvQ29tcG9zaXRvci5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL3JlbmRlcmVycy9Db250ZXh0LmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvcmVuZGVyZXJzL1VJTWFuYWdlci5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL3JlbmRlcmVycy9pbmplY3QtY3NzLmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvdHJhbnNpdGlvbnMvQ3VydmVzLmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvdHJhbnNpdGlvbnMvVHJhbnNpdGlvbmFibGUuanMiLCIuLi9mYW1vdXMvZW5naW5lL3NyYy91dGlsaXRpZXMvRXZlbnRFbWl0dGVyLmpzIiwiLi4vZmFtb3VzL2VuZ2luZS9zcmMvdXRpbGl0aWVzL2Fzc2VydC5qcyIsIi4uL2ZhbW91cy9lbmdpbmUvc3JjL3V0aWxpdGllcy92ZW5kb3JQcmVmaXguanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUksRUFBRSxTQUFTO0FBQ2YsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsY0FBTSxFQUFFLFNBQVM7QUFDakIsY0FBTSxFQUFFLFNBQVM7QUFDakIsY0FBTSxFQUFFLFNBQVM7QUFDakIsY0FBTSxFQUFFLFNBQVM7S0FDcEI7QUFDRCxXQUFPLEVBQUU7QUFDTCxZQUFJLEVBQUUsU0FBUztBQUNmLGFBQUssRUFBRSxTQUFTO0FBQ2hCLGFBQUssRUFBRSxTQUFTO0FBQ2hCLGFBQUssRUFBRSxTQUFTO0FBQ2hCLGFBQUssRUFBRSxTQUFTO0FBQ2hCLGFBQUssRUFBRSxTQUFTO0FBQ2hCLGFBQUssRUFBRSxTQUFTO0FBQ2hCLGFBQUssRUFBRSxTQUFTO0FBQ2hCLGFBQUssRUFBRSxTQUFTO0FBQ2hCLGFBQUssRUFBRSxTQUFTO0FBQ2hCLGNBQU0sRUFBRSxTQUFTO0FBQ2pCLGNBQU0sRUFBRSxTQUFTO0FBQ2pCLGNBQU0sRUFBRSxTQUFTO0FBQ2pCLGNBQU0sRUFBRSxTQUFTO0tBQ3BCO0FBQ0QsZ0JBQVksRUFBRTtBQUNWLFlBQUksRUFBRSxTQUFTO0FBQ2YsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsYUFBSyxFQUFFLFNBQVM7QUFDaEIsY0FBTSxFQUFFLFNBQVM7QUFDakIsY0FBTSxFQUFFLFNBQVM7QUFDakIsY0FBTSxFQUFFLFNBQVM7QUFDakIsY0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcktBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3paQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDemNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3owQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1TUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNsVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUM1UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNqTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2x4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDcllBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNXBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9EQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcE1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdFRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgc2V0VGltZW91dChkcmFpblF1ZXVlLCAwKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbi8vIFRPRE8oc2h0eWxtYW4pXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJpbXBvcnQgTm9kZSBmcm9tICdmYW1vdXMvc3JjL2NvcmUvTm9kZSc7XG5pbXBvcnQgRmFtb3VzRW5naW5lIGZyb20gJ2ZhbW91cy9zcmMvY29yZS9GYW1vdXNFbmdpbmUnO1xuaW1wb3J0IHtMb2dvfSBmcm9tICcuLi9sb2dvLyc7XG5pbXBvcnQge1NpZGViYXJ9IGZyb20gJy4uL3NpZGViYXIvJztcbmltcG9ydCB7TWFpbkNvbnRyb2xsZXJ9IGZyb20gJy4uL21haW4vJztcbmltcG9ydCB7TW9kYWx9IGZyb20gJy4uL21vZGFsLyc7XG5pbXBvcnQge0xheWVyfSBmcm9tICcuLi9sYXllcnMvJztcblxuZXhwb3J0IGNsYXNzIEFwcCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5tb2RhbCA9IHRoaXMuYWRkQ2hpbGQobmV3IExheWVyKHsgXG4gICAgICAgICAgICBpZDogJ21vZGFsJyxcbiAgICAgICAgICAgIHpJbmRleDogNVxuICAgICAgICB9KSkuYWRkQ2hpbGQobmV3IE1vZGFsKCkpO1xuXG4gICAgICAgIHRoaXMubG9nbyA9IHRoaXMuYWRkQ2hpbGQobmV3IExheWVyKHtcbiAgICAgICAgICAgIGlkOiAnbG9nbycsXG4gICAgICAgICAgICB6SW5kZXg6IDRcbiAgICAgICAgfSkpLmFkZENoaWxkKG5ldyBMb2dvKCkpO1xuXG4gICAgICAgIHRoaXMuc2lkZWJhciA9IHRoaXMuYWRkQ2hpbGQobmV3IExheWVyKHtcbiAgICAgICAgICAgIGlkOiAnc2lkZWJhcicsXG4gICAgICAgICAgICB6SW5kZXg6IDNcbiAgICAgICAgfSkpLmFkZENoaWxkKG5ldyBTaWRlYmFyKCkpO1xuXG4gICAgICAgIHRoaXMubWFpbiA9IHRoaXMuYWRkQ2hpbGQobmV3IExheWVyKHtcbiAgICAgICAgICAgIGlkOiAnbWFpbicsXG4gICAgICAgICAgICB6SW5kZXg6IDIsXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMjEyMTIxJyxcbiAgICAgICAgICAgIC8vIHBlcnNwZWN0aXZlOiAnMjAwMHB4J1xuICAgICAgICB9KSkuYWRkQ2hpbGQobmV3IE1haW5Db250cm9sbGVyKCkpO1xuXG4gICAgICAgIHRoaXMuYmFja2dyb3VuZExheWVyID0gdGhpcy5hZGRDaGlsZChuZXcgTGF5ZXIoe1xuICAgICAgICAgICAgaWQ6ICdiYWNrZ3JvdW5kJyxcbiAgICAgICAgICAgIHpJbmRleDogMVxuICAgICAgICB9KSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnZmFtb3VzL3NyYy9jb3JlL05vZGUnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnZmFtb3VzL3NyYy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudCc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4uL2hlbHBlcnMvY29sb3JzJztcblxuZXhwb3J0IGNsYXNzIEJsdXJiIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLnNldFNpemVNb2RlKDIsIDIsIDIpO1xuICAgICAgICB0aGlzLmVsID0gbmV3IERPTUVsZW1lbnQoe1xuICAgICAgICAgICAgY29udGVudDogb3B0aW9ucy5jb250ZW50LFxuICAgICAgICAgICAgc3R5bGVzOiBvcHRpb25zLnByb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnZmFtb3VzL3NyYy9jb3JlL05vZGUnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnZmFtb3VzL3NyYy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudCc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4uL2hlbHBlcnMvY29sb3JzJztcbmltcG9ydCBHcmlkIGZyb20gJy4uL2xheW91dHMvR3JpZCc7XG5cbmV4cG9ydCBjbGFzcyBMaXN0ZW5pbmdUbyBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIHRlc3QgPSBbWzAsIDBdLCBbMSwgMF0sIFswLCAxXSwgWzEsIDFdXTtcbiAgICAgICAgdmFyIHlvdXR1YmVVcmxzID0gW1xuICAgICAgICAgICAgJzxpZnJhbWUgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlXCIgc3JjPVwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvcjRHMG5icEx5U0lcIiBmcmFtZWJvcmRlcj1cIjBcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+JyxcbiAgICAgICAgICAgICc8aWZyYW1lIHN0eWxlPVwid2lkdGg6IDEwMCU7IGhlaWdodDogMTAwJVwiIHNyYz1cImh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL2VtYmVkL3gyQU9qYjlIVzJFXCIgZnJhbWVib3JkZXI9XCIwXCIgYWxsb3dmdWxsc2NyZWVuPjwvaWZyYW1lPicsXG4gICAgICAgICAgICAnPGlmcmFtZSBzdHlsZT1cIndpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCVcIiBzcmM9XCJodHRwczovL3d3dy55b3V0dWJlLmNvbS9lbWJlZC9IN2JxWklwQzNQZ1wiIGZyYW1lYm9yZGVyPVwiMFwiIGFsbG93ZnVsbHNjcmVlbj48L2lmcmFtZT4nLFxuICAgICAgICAgICAgJzxpZnJhbWUgc3R5bGU9XCJ3aWR0aDogMTAwJTsgaGVpZ2h0OiAxMDAlXCIgc3JjPVwiaHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvc3BVY3hCRkVwQk1cIiBmcmFtZWJvcmRlcj1cIjBcIiBhbGxvd2Z1bGxzY3JlZW4+PC9pZnJhbWU+J1xuICAgICAgICBdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IHRoaXMuYWRkQ2hpbGQoKTtcbiAgICAgICAgICAgIG5vZGUuc2V0RGlmZmVyZW50aWFsU2l6ZSgtMjAsIC0yMCwgMCk7XG4gICAgICAgICAgICBub2RlLnNldFByb3BvcnRpb25hbFNpemUoLjUsIC41LCAwKTtcbiAgICAgICAgICAgIG5vZGUuc2V0TW91bnRQb2ludCh0ZXN0W2ldWzBdLCB0ZXN0W2ldWzFdKTtcbiAgICAgICAgICAgIG5vZGUuc2V0QWxpZ24odGVzdFtpXVswXSwgdGVzdFtpXVsxXSk7XG4gICAgICAgICAgICB2YXIgZWwgPSBuZXcgRE9NRWxlbWVudChub2RlLCB7XG4gICAgICAgICAgICAgICAgY29udGVudDogeW91dHViZVVybHNbaV1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnZmFtb3VzL3NyYy9jb3JlL05vZGUnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnZmFtb3VzL3NyYy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudCc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4uL2hlbHBlcnMvY29sb3JzJztcblxuZXhwb3J0IGNsYXNzIFBsYXlpbmcgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnZmFtb3VzL3NyYy9jb3JlL05vZGUnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnZmFtb3VzL3NyYy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudCc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4uL2hlbHBlcnMvY29sb3JzJztcblxuZXhwb3J0IGNsYXNzIFJlYWRpbmcgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIH1cblxufVxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnZmFtb3VzL3NyYy9jb3JlL05vZGUnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnZmFtb3VzL3NyYy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudCc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4uL2hlbHBlcnMvY29sb3JzJztcbmltcG9ydCBCbHVyYiBmcm9tICcuL0JsdXJiJztcbmltcG9ydCBSZWFkaW5nIGZyb20gJy4vUmVhZGluZyc7XG5pbXBvcnQgUGxheWluZyBmcm9tICcuL1BsYXlpbmcnO1xuaW1wb3J0IHtMaXN0ZW5pbmdUb30gZnJvbSAnLi9MaXN0ZW5pbmdUbyc7XG5cbmV4cG9ydCBjbGFzcyBBYm91dCBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdGhpcy5yb290ID0gdGhpcy5hZGRDaGlsZCgpO1xuICAgICAgICB0aGlzLnJvb3RFbCA9IG5ldyBET01FbGVtZW50KHRoaXMucm9vdCwge1xuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIG92ZXJmbG93OiAnc2Nyb2xsJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucm9vdC5hZGRDaGlsZCgpO1xuICAgICAgICB0aGlzLnJvb3Quc2V0QWJzb2x1dGVTaXplKDYwMCwgbnVsbCwgbnVsbCk7XG4gICAgICAgIHRoaXMucm9vdC5zZXRTaXplTW9kZSgxLCAwLCAwKTtcbiAgICAgICAgdGhpcy5yb290LnNldEFsaWduKC41LCAwLCAwKTtcbiAgICAgICAgdGhpcy5yb290LnNldE1vdW50UG9pbnQoLjUsIDAsIDApO1xuXG5cbiAgICAgICAgdGhpcy50aXRsZU5vZGUgPSB0aGlzLnJvb3QuYWRkQ2hpbGQoKTtcbiAgICAgICAgdGhpcy50aXRsZU5vZGUuc2V0UG9zaXRpb24oMCwgMTAwLCAwKTtcbiAgICAgICAgdGhpcy50aXRsZU5vZGUuc2V0QWJzb2x1dGVTaXplKG51bGwsIDEwMCwgbnVsbCk7XG4gICAgICAgIHRoaXMudGl0bGVOb2RlLnNldFNpemVNb2RlKDAsIDEsIDApO1xuICAgICAgICB0aGlzLnRpdGxlRWwgPSBuZXcgRE9NRWxlbWVudCh0aGlzLnRpdGxlTm9kZSwge1xuICAgICAgICAgICAgY29udGVudDogJ0FCT1VUJyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnZnV0dXJhJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzQ4cHgnLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcxMDBweCcsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAncmlnaHQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYmx1cmJOb2RlID0gdGhpcy50aXRsZU5vZGUuYWRkQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5ibHVyYk5vZGUuc2V0UG9zaXRpb24oMCwgMTAwLCAwKTtcbiAgICAgICAgdGhpcy5ibHVyYkVsID0gbmV3IERPTUVsZW1lbnQodGhpcy5ibHVyYk5vZGUsIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdIaSwgSVxcJ20gTWlrZSBPXFwnQnJpZW4sIGFuZCBJIGxvdmUgdG8gZmluZCBwYXR0ZXJucyBpbiBldmVyeXRoaW5nLiAgSSBhbSBjdXJyZW50bHkgYSBTb2Z0d2FyZSBFbmdpbmVlciBhdCBGYW1vdXMgd2hlcmUgSSB3b3JrIG9uIHRoZSByZW5kZXJpbmcgZW5naW5lIGFuZCB1c2luZyBpdCB0byBidWlsZCBncmVhdCBleHBlcmllbmNlcy48YnI+PGJyPkhvcGUgeW91IGVuam95IG15IHNpdGUgYW5kIHNlZSB0aGUgcHJvZ3Jlc3MgdGhhdCBnZXRzIG1hZGUgaGVyZSBhcyBJIGNvbnRpbnVlIG15IGVmZm9ydHMgdG8gbGVhcm4gYWxsIEkgY2FuLiAgTGl2ZSB5b3VyIGxpZmUgdW5hcG9sb2dldGljYWxseS4nLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdmdXR1cmEnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnMThweCcsXG4gICAgICAgICAgICAgICAgZm9udFNwYWNpbmc6ICcycHgnLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcyMnB4JyxcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0J1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxpc3RlbmluZ1RvVGl0bGUgPSB0aGlzLmJsdXJiTm9kZS5hZGRDaGlsZCgpO1xuICAgICAgICB0aGlzLmxpc3RlbmluZ1RvVGl0bGUuc2V0UG9zaXRpb24oMCwgMjAwLCAwKTtcbiAgICAgICAgdGhpcy5saXN0ZW5pbmdUb1RpdGxlRWwgPSBuZXcgRE9NRWxlbWVudCh0aGlzLmxpc3RlbmluZ1RvVGl0bGUsIHtcbiAgICAgICAgICAgIGNvbnRlbnQ6ICdXaGF0IEkgYW0gbGlzdGVuaW5nIHRvJyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3doaXRlJyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnZnV0dXJhJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzMycHgnLFxuICAgICAgICAgICAgICAgIGZvbnRTcGFjaW5nOiAnMnB4JyxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAnMjJweCcsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAncmlnaHQnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubGlzdGVuaW5nVG8gPSB0aGlzLmxpc3RlbmluZ1RvVGl0bGUuYWRkQ2hpbGQobmV3IExpc3RlbmluZ1RvKCkpO1xuICAgICAgICB0aGlzLmxpc3RlbmluZ1RvLnNldFBvc2l0aW9uKDAsIDEwMCwgMClcbiAgICAgICAgdGhpcy5saXN0ZW5pbmdUby5zZXRTaXplTW9kZSgwLCAxLCAwKTtcbiAgICAgICAgdGhpcy5saXN0ZW5pbmdUby5zZXRBYnNvbHV0ZVNpemUobnVsbCwgNDAwLCBudWxsKTtcbiAgICB9XG59XG5cbiIsImltcG9ydCBOb2RlIGZyb20gJ2ZhbW91cy9zcmMvY29yZS9Ob2RlJztcbmltcG9ydCBET01FbGVtZW50IGZyb20gJ2ZhbW91cy9zcmMvZG9tLXJlbmRlcmFibGVzL0RPTUVsZW1lbnQnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuLi8uLi9oZWxwZXJzL2NvbG9ycyc7XG5cbmV4cG9ydCBjbGFzcyBCb3ggZXh0ZW5kcyBOb2RlIHtcblx0Y29uc3RydWN0b3Iob3B0aW9ucykge1xuXHRcdHN1cGVyKG9wdGlvbnMpOyAgICBcbiAgICAgICAgdGhpcy5mYWNlcyA9IFtdO1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcHRpb25zLm9wYWNpdHkgfHwgMTtcbiAgICAgICAgdGhpcy5fd2lkdGggPSBvcHRpb25zLndpZHRoIHx8IDA7XG4gICAgICAgIHRoaXMuX2hlaWdodCA9IG9wdGlvbnMuaGVpZ2h0IHx8IDA7XG4gICAgICAgIHRoaXMuX2RlcHRoID0gb3B0aW9ucy5kZXB0aCB8fCAwO1xuXG5cbiAgICAgICAgdGhpcy5zZXRPcmlnaW4oLjUsIC41LCAuNSk7XG4gICAgICAgIHRoaXMuc2V0TW91bnRQb2ludCguNSwgLjUsIC41KTtcbiAgICAgICAgdGhpcy5zZXRBbGlnbiguNSwgLjUsIC41KTtcblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuYWRkQ29tcG9uZW50KHtcbiAgICAgICAgICAgIG9uU2l6ZUNoYW5nZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgZGVwdGgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgICAgIHNlbGYuX2hlaWdodCA9IGhlaWdodDtcbiAgICAgICAgICAgICAgICBzZWxmLl9kZXB0aCA9IGRlcHRoO1xuXG4gICAgICAgICAgICAgICAgc2VsZi5yZXNpemUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5fY29uc3RydWN0RmFjZXMoKTtcblx0fVxuXG4gICAgX2NvbnN0cnVjdEZhY2VzKCkge1xuICAgICAgICB0aGlzLmZhY2VzLnB1c2godGhpcy5hZGRDaGlsZCgpKTtcbiAgICAgICAgbmV3IERPTUVsZW1lbnQodGhpcy5mYWNlc1swXSwge1xuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5waW5rWzUwMF0sXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkIGJsYWNrJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZhY2VzLnB1c2godGhpcy5hZGRDaGlsZCgpKTtcbiAgICAgICAgdGhpcy5mYWNlc1sxXS5zZXRSb3RhdGlvbigwLCBNYXRoLlBJLCAwKTtcbiAgICAgICAgdGhpcy5mYWNlc1sxXS5zZXRPcmlnaW4oLjUsIC41LCAuNSk7XG4gICAgICAgIG5ldyBET01FbGVtZW50KHRoaXMuZmFjZXNbMV0sIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMucGlua1s1MDBdLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzJweCBzb2xpZCBibGFjaycsXG4gICAgICAgICAgICAgICAgYmFja2ZhY2VWaXNpYmlsaXR5OiAndmlzaWJsZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5mYWNlcy5wdXNoKHRoaXMuYWRkQ2hpbGQoKSk7XG4gICAgICAgIHRoaXMuZmFjZXNbMl0uc2V0Um90YXRpb24oMCwgTWF0aC5QSS8yLCAwKTtcbiAgICAgICAgdGhpcy5mYWNlc1syXS5zZXRPcmlnaW4oLjUsIC41LCAuNSk7XG4gICAgICAgIG5ldyBET01FbGVtZW50KHRoaXMuZmFjZXNbMl0sIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMueWVsbG93WzUwMF0sXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkIGJsYWNrJyxcbiAgICAgICAgICAgICAgICBiYWNrZmFjZVZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZhY2VzLnB1c2godGhpcy5hZGRDaGlsZCgpKTtcbiAgICAgICAgdGhpcy5mYWNlc1szXS5zZXRSb3RhdGlvbigwLCAtTWF0aC5QSS8yLCAwKTtcbiAgICAgICAgdGhpcy5mYWNlc1szXS5zZXRPcmlnaW4oLjUsIC41LCAuNSk7XG4gICAgICAgIG5ldyBET01FbGVtZW50KHRoaXMuZmFjZXNbM10sIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMueWVsbG93WzUwMF0sXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkIGJsYWNrJyxcbiAgICAgICAgICAgICAgICBiYWNrZmFjZVZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZhY2VzLnB1c2godGhpcy5hZGRDaGlsZCgpKTtcbiAgICAgICAgdGhpcy5mYWNlc1s0XS5zZXRSb3RhdGlvbihNYXRoLlBJLzIsIDAsIDApO1xuICAgICAgICB0aGlzLmZhY2VzWzRdLnNldE9yaWdpbiguNSwgLjUsIC41KTtcbiAgICAgICAgbmV3IERPTUVsZW1lbnQodGhpcy5mYWNlc1s0XSwge1xuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMub3BhY2l0eSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGNvbG9ycy5kZWVwT3JhbmdlWzUwMF0sXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnMnB4IHNvbGlkIGJsYWNrJyxcbiAgICAgICAgICAgICAgICBiYWNrZmFjZVZpc2liaWxpdHk6ICd2aXNpYmxlJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZhY2VzLnB1c2godGhpcy5hZGRDaGlsZCgpKTtcbiAgICAgICAgdGhpcy5mYWNlc1s1XS5zZXRSb3RhdGlvbigtTWF0aC5QSS8yLCAwLCAwKTtcbiAgICAgICAgdGhpcy5mYWNlc1s1XS5zZXRPcmlnaW4oLjUsIC41LCAuNSk7XG4gICAgICAgIG5ldyBET01FbGVtZW50KHRoaXMuZmFjZXNbNV0sIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5OiB0aGlzLm9wYWNpdHksXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMuZGVlcE9yYW5nZVs1MDBdLFxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzJweCBzb2xpZCBibGFjaycsXG4gICAgICAgICAgICAgICAgYmFja2ZhY2VWaXNpYmlsaXR5OiAndmlzaWJsZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICB9XG5cbiAgICByZXNpemUoKSB7XG4gICAgICAgIHRoaXMuZmFjZXNbMF0uc2V0UG9zaXRpb24oMCwgMCwgdGhpcy5fZGVwdGgvMik7XG4gICAgICAgIHRoaXMuZmFjZXNbMV0uc2V0UG9zaXRpb24oMCwgMCwgLXRoaXMuX2RlcHRoLzIpO1xuICAgICAgICB0aGlzLmZhY2VzWzJdLnNldFBvc2l0aW9uKC10aGlzLl93aWR0aC8yLCAwLCAwKTtcbiAgICAgICAgdGhpcy5mYWNlc1szXS5zZXRQb3NpdGlvbih0aGlzLl93aWR0aC8yLCAwLCAwKTtcbiAgICAgICAgdGhpcy5mYWNlc1s0XS5zZXRQb3NpdGlvbigwLCB0aGlzLl9oZWlnaHQvMiwgMCk7XG4gICAgICAgIHRoaXMuZmFjZXNbNV0uc2V0UG9zaXRpb24oMCwgLXRoaXMuX2hlaWdodC8yLCAwKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgVHJhbnNpdGlvbmFibGUgZnJvbSAnZmFtb3VzL3NyYy90cmFuc2l0aW9ucy9UcmFuc2l0aW9uYWJsZSc7XG5cbnZhciBtYWluVHJhbnNpdGlvbmFibGUgPSBuZXcgVHJhbnNpdGlvbmFibGUoMCk7XG5cbmZ1bmN0aW9uIGJyZWF0aGUoKSB7XG4gICAgbWFpblRyYW5zaXRpb25hYmxlLnNldCgxLCB7ZHVyYXRpb246IDIwMDAsIGN1cnZlOiAnZWFzZUluT3V0J30sIGZ1bmN0aW9uKCkge1xuICAgICAgICBtYWluVHJhbnNpdGlvbmFibGUuc2V0KDAsIHtkdXJhdGlvbjogMjAwMCwgY3VydmU6ICdlYXNlSW5PdXQnfSwgYnJlYXRoZSk7XG4gICAgfSk7ICAgIFxufVxuYnJlYXRoZSgpO1xuXG5leHBvcnQgY2xhc3MgQnJlYXRoZXIge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgICAgICB0aGlzLmRpcmVjdGlvbiA9IG9wdGlvbnMuZGlyZWN0aW9uIHx8ICcteCc7XG4gICAgICAgIHRoaXMuX2lkID0gbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3dpZHRoID0gMDtcbiAgICAgICAgdGhpcy5faGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fZGVwdGggPSAwO1xuICAgIH1cblxuICAgIG9uU2l6ZUNoYW5nZSh3aWR0aCwgaGVpZ2h0LCBkZXB0aCkge1xuICAgICAgICB0aGlzLl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuX2RlcHRoID0gZGVwdGg7XG4gICAgfVxuXG4gICAgb25VcGRhdGUodGltZSkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICcteCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZXRQb3NpdGlvbigtdGhpcy5fd2lkdGgqMiAtICh0aGlzLl93aWR0aCAqIG1haW5UcmFuc2l0aW9uYWJsZS5nZXQoKSksIDAsIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnK3gnOlxuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUuc2V0UG9zaXRpb24odGhpcy5fd2lkdGgqMiArICh0aGlzLl93aWR0aCAqIG1haW5UcmFuc2l0aW9uYWJsZS5nZXQoKSksIDAsIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnLXknOlxuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUuc2V0UG9zaXRpb24oMCwgLXRoaXMuX2hlaWdodCoyIC0gKHRoaXMuX2hlaWdodCAqIG1haW5UcmFuc2l0aW9uYWJsZS5nZXQoKSksIDApO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnK3knOlxuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUuc2V0UG9zaXRpb24oMCwgdGhpcy5faGVpZ2h0KjIgKyAodGhpcy5faGVpZ2h0ICogbWFpblRyYW5zaXRpb25hYmxlLmdldCgpKSwgMCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcteic6XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZXRQb3NpdGlvbigwLCAwLCAtdGhpcy5fZGVwdGgqMi0gKHRoaXMuX2RlcHRoICogbWFpblRyYW5zaXRpb25hYmxlLmdldCgpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICcreic6XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZXRQb3NpdGlvbigwLCAwLCB0aGlzLl9kZXB0aCoyICsgKHRoaXMuX2RlcHRoICogbWFpblRyYW5zaXRpb25hYmxlLmdldCgpKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKHRoaXMuX2lkKTtcbiAgICB9XG59XG4iLCJpbXBvcnQgTm9kZSBmcm9tICdmYW1vdXMvc3JjL2NvcmUvTm9kZSc7XG5pbXBvcnQgRE9NRWxlbWVudCBmcm9tICdmYW1vdXMvc3JjL2RvbS1yZW5kZXJhYmxlcy9ET01FbGVtZW50JztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi4vLi4vaGVscGVycy9jb2xvcnMnO1xuaW1wb3J0IHtCcmVhdGhlcn0gZnJvbSAnLi4vLi4vaGVscGVycy9ib3gvQnJlYXRoZXInO1xuaW1wb3J0IHtCb3h9IGZyb20gJy4uLy4uL2hlbHBlcnMvYm94L0JveCc7XG5pbXBvcnQge091dGVyQm94fSBmcm9tICcuLi8uLi9oZWxwZXJzL2JveC9PdXRlckJveCc7XG5cbmV4cG9ydCBjbGFzcyBNaWRkbGVCb3ggZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIG5ldyBCcmVhdGhlcih0aGlzLCB7ZGlyZWN0aW9uOiBvcHRpb25zLmRpcmVjdGlvbn0pO1xuICAgICAgICB0aGlzLmFkZENoaWxkKG5ldyBCb3goe1xuICAgICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICAgIHR5cGU6ICdkb20nXG4gICAgICAgIH0pKTtcblxuICAgICAgICB0aGlzLm91dGVyUm90YXRpb25Ob2RlID0gdGhpcy5hZGRDaGlsZCgpO1xuICAgICAgICB0aGlzLm91dGVyUm90YXRpb25Ob2RlLnNldFByb3BvcnRpb25hbFNpemUoLjUsIC41LCAuNSk7XG4gICAgICAgIHRoaXMub3V0ZXJSb3RhdGlvbk5vZGUuc2V0QWxpZ24oLjUsIC41LCAuNSk7XG4gICAgICAgIHRoaXMub3V0ZXJSb3RhdGlvbk5vZGUuc2V0T3JpZ2luKC41LCAuNSwgLjUpO1xuICAgICAgICB0aGlzLm91dGVyUm90YXRpb25Ob2RlLnNldE1vdW50UG9pbnQoLjUsIC41LCAuNSk7XG4gICAgICAgIHRoaXMub3V0ZXJSb3RhdGlvbk5vZGUuYWRkQ2hpbGQobmV3IEJveCh7Y29sb3JzOiBbXSwgdHlwZTogJ2RvbSd9KSk7XG4gICAgfVxuXG4gICAgb25TaXplQ2hhbmdlKHdpZHRoLGhlaWdodCwgZGVwdGgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm9wdGlvbnMuZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlICcreCc6XG4gICAgICAgICAgICAgICAgdGhpcy5vdXRlclJvdGF0aW9uTm9kZS5zZXRQb3NpdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxufSAgICIsImltcG9ydCBOb2RlIGZyb20gJ2ZhbW91cy9zcmMvY29yZS9Ob2RlJztcbmltcG9ydCB7Qm94fSBmcm9tICcuLi8uLi9oZWxwZXJzL2JveC9Cb3gnO1xuXG5leHBvcnQgY2xhc3MgT3V0ZXJCb3ggZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gICAgICAgIHRoaXMucm90YXRpb25Ob2RlID0gdGhpcy5hZGRDaGlsZCgpO1xuICAgICAgICB0aGlzLnJvdGF0aW9uTm9kZS5zZXRQb3NpdGlvbigpO1xuICAgICAgICB0aGlzLnJvdGF0aW9uTm9kZS5zZXRQcm9wb3J0aW9uYWxTaXplKC41LCAuNSwgLjUpO1xuXG4gICAgICAgIHRoaXMucm90YXRpb25Ob2RlLmFkZENoaWxkKG5ldyBCb3goe1xuICAgICAgICAgICAgY29sb3JzOiBbXSxcbiAgICAgICAgICAgIHR5cGU6ICdkb20nXG4gICAgICAgIH0pKTtcbiAgICB9XG59ICAgIiwiLy8gR29vZ2xlIHN0eWxlIHBhbGV0dGUgKGh0dHA6Ly93d3cuZ29vZ2xlLmNvbS9kZXNpZ24vc3BlYy9zdHlsZS9jb2xvci5odG1sKVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgJ3JlZCc6IHtcbiAgICAgICAgJzUwJzogJyNGRkVCRUUnLFxuICAgICAgICAnMTAwJzogJyNGRkNERDInLFxuICAgICAgICAnMjAwJzogJyNFRjlBOUEnLFxuICAgICAgICAnMzAwJzogJyNFNTczNzMnLFxuICAgICAgICAnNDAwJzogJyNFRjUzNTAnLFxuICAgICAgICAnNTAwJzogJyNGNDQzMzYnLFxuICAgICAgICAnNjAwJzogJyNFNTM5MzUnLFxuICAgICAgICAnNzAwJzogJyNEMzJGMkYnLFxuICAgICAgICAnODAwJzogJyNDNjI4MjgnLFxuICAgICAgICAnOTAwJzogJyNCNzFDMUMnLFxuICAgICAgICAnQTEwMCc6ICcjRkY4QTgwJyxcbiAgICAgICAgJ0EyMDAnOiAnI0ZGNTI1MicsXG4gICAgICAgICdBNDAwJzogJyNGRjE3NDQnLFxuICAgICAgICAnQTcwMCc6ICcjRDUwMDAwJ1xuICAgIH0sXG4gICAgJ3BpbmsnOiB7XG4gICAgICAgICc1MCc6ICcjRkNFNEVDJyxcbiAgICAgICAgJzEwMCc6ICcjRjhCQkQwJyxcbiAgICAgICAgJzIwMCc6ICcjRjQ4RkIxJyxcbiAgICAgICAgJzMwMCc6ICcjRjA2MjkyJyxcbiAgICAgICAgJzQwMCc6ICcjRUM0MDdBJyxcbiAgICAgICAgJzUwMCc6ICcjRTkxRTYzJyxcbiAgICAgICAgJzYwMCc6ICcjRDgxQjYwJyxcbiAgICAgICAgJzcwMCc6ICcjQzIxODVCJyxcbiAgICAgICAgJzgwMCc6ICcjQUQxNDU3JyxcbiAgICAgICAgJzkwMCc6ICcjODgwRTRGJyxcbiAgICAgICAgJ0ExMDAnOiAnI0ZGODBBQicsXG4gICAgICAgICdBMjAwJzogJyNGRjQwODEnLFxuICAgICAgICAnQTQwMCc6ICcjRjUwMDU3JyxcbiAgICAgICAgJ0E3MDAnOiAnI0M1MTE2MidcbiAgICB9LFxuICAgICdwdXJwbGUnOiB7XG4gICAgICAgICc1MCc6ICcjRjNFNUY1JyxcbiAgICAgICAgJzEwMCc6ICcjRTFCRUU3JyxcbiAgICAgICAgJzIwMCc6ICcjQ0U5M0Q4JyxcbiAgICAgICAgJzMwMCc6ICcjQkE2OEM4JyxcbiAgICAgICAgJzQwMCc6ICcjQUI0N0JDJyxcbiAgICAgICAgJzUwMCc6ICcjOUMyN0IwJyxcbiAgICAgICAgJzYwMCc6ICcjOEUyNEFBJyxcbiAgICAgICAgJzcwMCc6ICcjN0IxRkEyJyxcbiAgICAgICAgJzgwMCc6ICcjNkExQjlBJyxcbiAgICAgICAgJzkwMCc6ICcjNEExNDhDJyxcbiAgICAgICAgJ0ExMDAnOiAnI0VBODBGQycsXG4gICAgICAgICdBMjAwJzogJyNFMDQwRkInLFxuICAgICAgICAnQTQwMCc6ICcjRDUwMEY5JyxcbiAgICAgICAgJ0E3MDAnOiAnI0FBMDBGRidcbiAgICB9LFxuICAgICdkZWVwUHVycGxlJzoge1xuICAgICAgICAnNTAnOiAnI0VERTdGNicsXG4gICAgICAgICcxMDAnOiAnI0QxQzRFOScsXG4gICAgICAgICcyMDAnOiAnI0IzOUREQicsXG4gICAgICAgICczMDAnOiAnIzk1NzVDRCcsXG4gICAgICAgICc0MDAnOiAnIzdFNTdDMicsXG4gICAgICAgICc1MDAnOiAnIzY3M0FCNycsXG4gICAgICAgICc2MDAnOiAnIzVFMzVCMScsXG4gICAgICAgICc3MDAnOiAnIzUxMkRBOCcsXG4gICAgICAgICc4MDAnOiAnIzQ1MjdBMCcsXG4gICAgICAgICc5MDAnOiAnIzMxMUI5MicsXG4gICAgICAgICdBMTAwJzogJyNCMzg4RkYnLFxuICAgICAgICAnQTIwMCc6ICcjN0M0REZGJyxcbiAgICAgICAgJ0E0MDAnOiAnIzY1MUZGRicsXG4gICAgICAgICdBNzAwJzogJyM2MjAwRUEnXG4gICAgfSxcbiAgICAnaW5kaWdvJzoge1xuICAgICAgICAnNTAnOiAnI0U4RUFGNicsXG4gICAgICAgICcxMDAnOiAnI0M1Q0FFOScsXG4gICAgICAgICcyMDAnOiAnIzlGQThEQScsXG4gICAgICAgICczMDAnOiAnIzc5ODZDQicsXG4gICAgICAgICc0MDAnOiAnIzVDNkJDMCcsXG4gICAgICAgICc1MDAnOiAnIzNGNTFCNScsXG4gICAgICAgICc2MDAnOiAnIzM5NDlBQicsXG4gICAgICAgICc3MDAnOiAnIzMwM0Y5RicsXG4gICAgICAgICc4MDAnOiAnIzI4MzU5MycsXG4gICAgICAgICc5MDAnOiAnIzFBMjM3RScsXG4gICAgICAgICdBMTAwJzogJyM4QzlFRkYnLFxuICAgICAgICAnQTIwMCc6ICcjNTM2REZFJyxcbiAgICAgICAgJ0E0MDAnOiAnIzNENUFGRScsXG4gICAgICAgICdBNzAwJzogJyMzMDRGRkUnXG4gICAgfSxcbiAgICAnYmx1ZSc6IHtcbiAgICAgICAgJzUwJzogJyNFM0YyRkQnLFxuICAgICAgICAnMTAwJzogJyNCQkRFRkInLFxuICAgICAgICAnMjAwJzogJyM5MENBRjknLFxuICAgICAgICAnMzAwJzogJyM2NEI1RjYnLFxuICAgICAgICAnNDAwJzogJyM0MkE1RjUnLFxuICAgICAgICAnNTAwJzogJyMyMTk2RjMnLFxuICAgICAgICAnNjAwJzogJyMxRTg4RTUnLFxuICAgICAgICAnNzAwJzogJyMxOTc2RDInLFxuICAgICAgICAnODAwJzogJyMxNTY1QzAnLFxuICAgICAgICAnOTAwJzogJyMwRDQ3QTEnLFxuICAgICAgICAnQTEwMCc6ICcjODJCMUZGJyxcbiAgICAgICAgJ0EyMDAnOiAnIzQ0OEFGRicsXG4gICAgICAgICdBNDAwJzogJyMyOTc5RkYnLFxuICAgICAgICAnQTcwMCc6ICcjMjk2MkZGJ1xuICAgIH0sXG4gICAgJ2xpZ2h0Qmx1ZSc6IHtcbiAgICAgICAgJzUwJzogJyNFMUY1RkUnLFxuICAgICAgICAnMTAwJzogJyNCM0U1RkMnLFxuICAgICAgICAnMjAwJzogJyM4MUQ0RkEnLFxuICAgICAgICAnMzAwJzogJyM0RkMzRjcnLFxuICAgICAgICAnNDAwJzogJyMyOUI2RjYnLFxuICAgICAgICAnNTAwJzogJyMwM0E5RjQnLFxuICAgICAgICAnNjAwJzogJyMwMzlCRTUnLFxuICAgICAgICAnNzAwJzogJyMwMjg4RDEnLFxuICAgICAgICAnODAwJzogJyMwMjc3QkQnLFxuICAgICAgICAnOTAwJzogJyMwMTU3OUInLFxuICAgICAgICAnQTEwMCc6ICcjODBEOEZGJyxcbiAgICAgICAgJ0EyMDAnOiAnIzQwQzRGRicsXG4gICAgICAgICdBNDAwJzogJyMwMEIwRkYnLFxuICAgICAgICAnQTcwMCc6ICcjMDA5MUVBJ1xuICAgIH0sXG4gICAgJ2N5YW4nOiB7XG4gICAgICAgICc1MCc6ICcjRTBGN0ZBJyxcbiAgICAgICAgJzEwMCc6ICcjQjJFQkYyJyxcbiAgICAgICAgJzIwMCc6ICcjODBERUVBJyxcbiAgICAgICAgJzMwMCc6ICcjNEREMEUxJyxcbiAgICAgICAgJzQwMCc6ICcjMjZDNkRBJyxcbiAgICAgICAgJzUwMCc6ICcjMDBCQ0Q0JyxcbiAgICAgICAgJzYwMCc6ICcjMDBBQ0MxJyxcbiAgICAgICAgJzcwMCc6ICcjMDA5N0E3JyxcbiAgICAgICAgJzgwMCc6ICcjMDA4MzhGJyxcbiAgICAgICAgJzkwMCc6ICcjMDA2MDY0JyxcbiAgICAgICAgJ0ExMDAnOiAnIzg0RkZGRicsXG4gICAgICAgICdBMjAwJzogJyMxOEZGRkYnLFxuICAgICAgICAnQTQwMCc6ICcjMDBFNUZGJyxcbiAgICAgICAgJ0E3MDAnOiAnIzAwQjhENCdcbiAgICB9LFxuICAgICd0ZWFsJzoge1xuICAgICAgICAnNTAnOiAnI0UwRjJGMScsXG4gICAgICAgICcxMDAnOiAnI0IyREZEQicsXG4gICAgICAgICcyMDAnOiAnIzgwQ0JDNCcsXG4gICAgICAgICczMDAnOiAnIzREQjZBQycsXG4gICAgICAgICc0MDAnOiAnIzI2QTY5QScsXG4gICAgICAgICc1MDAnOiAnIzAwOTY4OCcsXG4gICAgICAgICc2MDAnOiAnIzAwODk3QicsXG4gICAgICAgICc3MDAnOiAnIzAwNzk2QicsXG4gICAgICAgICc4MDAnOiAnIzAwNjk1QycsXG4gICAgICAgICc5MDAnOiAnIzAwNEQ0MCcsXG4gICAgICAgICdBMTAwJzogJyNBN0ZGRUInLFxuICAgICAgICAnQTIwMCc6ICcjNjRGRkRBJyxcbiAgICAgICAgJ0E0MDAnOiAnIzFERTlCNicsXG4gICAgICAgICdBNzAwJzogJyMwMEJGQTUnXG4gICAgfSxcbiAgICAnZ3JlZW4nOiB7XG4gICAgICAgICc1MCc6ICcjRThGNUU5JyxcbiAgICAgICAgJzEwMCc6ICcjQzhFNkM5JyxcbiAgICAgICAgJzIwMCc6ICcjQTVENkE3JyxcbiAgICAgICAgJzMwMCc6ICcjODFDNzg0JyxcbiAgICAgICAgJzQwMCc6ICcjNjZCQjZBJyxcbiAgICAgICAgJzUwMCc6ICcjNENBRjUwJyxcbiAgICAgICAgJzYwMCc6ICcjNDNBMDQ3JyxcbiAgICAgICAgJzcwMCc6ICcjMzg4RTNDJyxcbiAgICAgICAgJzgwMCc6ICcjMkU3RDMyJyxcbiAgICAgICAgJzkwMCc6ICcjMUI1RTIwJyxcbiAgICAgICAgJ0ExMDAnOiAnI0I5RjZDQScsXG4gICAgICAgICdBMjAwJzogJyM2OUYwQUUnLFxuICAgICAgICAnQTQwMCc6ICcjMDBFNjc2JyxcbiAgICAgICAgJ0E3MDAnOiAnIzAwQzg1MydcbiAgICB9LFxuICAgICdsaWdodEdyZWVuJzoge1xuICAgICAgICAnNTAnOiAnI0YxRjhFOScsXG4gICAgICAgICcxMDAnOiAnI0RDRURDOCcsXG4gICAgICAgICcyMDAnOiAnI0M1RTFBNScsXG4gICAgICAgICczMDAnOiAnI0FFRDU4MScsXG4gICAgICAgICc0MDAnOiAnIzlDQ0M2NScsXG4gICAgICAgICc1MDAnOiAnIzhCQzM0QScsXG4gICAgICAgICc2MDAnOiAnIzdDQjM0MicsXG4gICAgICAgICc3MDAnOiAnIzY4OUYzOCcsXG4gICAgICAgICc4MDAnOiAnIzU1OEIyRicsXG4gICAgICAgICc5MDAnOiAnIzMzNjkxRScsXG4gICAgICAgICdBMTAwJzogJyNDQ0ZGOTAnLFxuICAgICAgICAnQTIwMCc6ICcjQjJGRjU5JyxcbiAgICAgICAgJ0E0MDAnOiAnIzc2RkYwMycsXG4gICAgICAgICdBNzAwJzogJyM2NEREMTcnXG4gICAgfSxcbiAgICAnbGltZSc6IHtcbiAgICAgICAgJzUwJzogJyNGOUZCRTcnLFxuICAgICAgICAnMTAwJzogJyNGMEY0QzMnLFxuICAgICAgICAnMjAwJzogJyNFNkVFOUMnLFxuICAgICAgICAnMzAwJzogJyNEQ0U3NzUnLFxuICAgICAgICAnNDAwJzogJyNENEUxNTcnLFxuICAgICAgICAnNTAwJzogJyNDRERDMzknLFxuICAgICAgICAnNjAwJzogJyNDMENBMzMnLFxuICAgICAgICAnNzAwJzogJyNBRkI0MkInLFxuICAgICAgICAnODAwJzogJyM5RTlEMjQnLFxuICAgICAgICAnOTAwJzogJyM4Mjc3MTcnLFxuICAgICAgICAnQTEwMCc6ICcjRjRGRjgxJyxcbiAgICAgICAgJ0EyMDAnOiAnI0VFRkY0MScsXG4gICAgICAgICdBNDAwJzogJyNDNkZGMDAnLFxuICAgICAgICAnQTcwMCc6ICcjQUVFQTAwJ1xuICAgIH0sXG4gICAgJ3llbGxvdyc6IHtcbiAgICAgICAgJzUwJzogJyNGRkZERTcnLFxuICAgICAgICAnMTAwJzogJyNGRkY5QzQnLFxuICAgICAgICAnMjAwJzogJyNGRkY1OUQnLFxuICAgICAgICAnMzAwJzogJyNGRkYxNzYnLFxuICAgICAgICAnNDAwJzogJyNGRkVFNTgnLFxuICAgICAgICAnNTAwJzogJyNGRkVCM0InLFxuICAgICAgICAnNjAwJzogJyNGREQ4MzUnLFxuICAgICAgICAnNzAwJzogJyNGQkMwMkQnLFxuICAgICAgICAnODAwJzogJyNGOUE4MjUnLFxuICAgICAgICAnOTAwJzogJyNGNTdGMTcnLFxuICAgICAgICAnQTEwMCc6ICcjRkZGRjhEJyxcbiAgICAgICAgJ0EyMDAnOiAnI0ZGRkYwMCcsXG4gICAgICAgICdBNDAwJzogJyNGRkVBMDAnLFxuICAgICAgICAnQTcwMCc6ICcjRkZENjAwJ1xuICAgIH0sXG4gICAgJ2FtYmVyJzoge1xuICAgICAgICAnNTAnOiAnI0ZGRjhFMScsXG4gICAgICAgICcxMDAnOiAnI0ZGRUNCMycsXG4gICAgICAgICcyMDAnOiAnI0ZGRTA4MicsXG4gICAgICAgICczMDAnOiAnI0ZGRDU0RicsXG4gICAgICAgICc0MDAnOiAnI0ZGQ0EyOCcsXG4gICAgICAgICc1MDAnOiAnI0ZGQzEwNycsXG4gICAgICAgICc2MDAnOiAnI0ZGQjMwMCcsXG4gICAgICAgICc3MDAnOiAnI0ZGQTAwMCcsXG4gICAgICAgICc4MDAnOiAnI0ZGOEYwMCcsXG4gICAgICAgICc5MDAnOiAnI0ZGNkYwMCcsXG4gICAgICAgICdBMTAwJzogJyNGRkU1N0YnLFxuICAgICAgICAnQTIwMCc6ICcjRkZENzQwJyxcbiAgICAgICAgJ0E0MDAnOiAnI0ZGQzQwMCcsXG4gICAgICAgICdBNzAwJzogJyNGRkFCMDAnXG4gICAgfSxcbiAgICAnb3JhbmdlJzoge1xuICAgICAgICAnNTAnOiAnI0ZGRjNFMCcsXG4gICAgICAgICcxMDAnOiAnI0ZGRTBCMicsXG4gICAgICAgICcyMDAnOiAnI0ZGQ0M4MCcsXG4gICAgICAgICczMDAnOiAnI0ZGQjc0RCcsXG4gICAgICAgICc0MDAnOiAnI0ZGQTcyNicsXG4gICAgICAgICc1MDAnOiAnI0ZGOTgwMCcsXG4gICAgICAgICc2MDAnOiAnI0ZCOEMwMCcsXG4gICAgICAgICc3MDAnOiAnI0Y1N0MwMCcsXG4gICAgICAgICc4MDAnOiAnI0VGNkMwMCcsXG4gICAgICAgICc5MDAnOiAnI0U2NTEwMCcsXG4gICAgICAgICdBMTAwJzogJyNGRkQxODAnLFxuICAgICAgICAnQTIwMCc6ICcjRkZBQjQwJyxcbiAgICAgICAgJ0E0MDAnOiAnI0ZGOTEwMCcsXG4gICAgICAgICdBNzAwJzogJyNGRjZEMDAnXG4gICAgfSxcbiAgICAnZGVlcE9yYW5nZSc6IHtcbiAgICAgICAgJzUwJzogJyNGQkU5RTcnLFxuICAgICAgICAnMTAwJzogJyNGRkNDQkMnLFxuICAgICAgICAnMjAwJzogJyNGRkFCOTEnLFxuICAgICAgICAnMzAwJzogJyNGRjhBNjUnLFxuICAgICAgICAnNDAwJzogJyNGRjcwNDMnLFxuICAgICAgICAnNTAwJzogJyNGRjU3MjInLFxuICAgICAgICAnNjAwJzogJyNGNDUxMUUnLFxuICAgICAgICAnNzAwJzogJyNFNjRBMTknLFxuICAgICAgICAnODAwJzogJyNEODQzMTUnLFxuICAgICAgICAnOTAwJzogJyNCRjM2MEMnLFxuICAgICAgICAnQTEwMCc6ICcjRkY5RTgwJyxcbiAgICAgICAgJ0EyMDAnOiAnI0ZGNkU0MCcsXG4gICAgICAgICdBNDAwJzogJyNGRjNEMDAnLFxuICAgICAgICAnQTcwMCc6ICcjREQyQzAwJ1xuICAgIH0sXG4gICAgJ2Jyb3duJzoge1xuICAgICAgICAnNTAnOiAnI0VGRUJFOScsXG4gICAgICAgICcxMDAnOiAnI0Q3Q0NDOCcsXG4gICAgICAgICcyMDAnOiAnI0JDQUFBNCcsXG4gICAgICAgICczMDAnOiAnI0ExODg3RicsXG4gICAgICAgICc0MDAnOiAnIzhENkU2MycsXG4gICAgICAgICc1MDAnOiAnIzc5NTU0OCcsXG4gICAgICAgICc2MDAnOiAnIzZENEM0MScsXG4gICAgICAgICc3MDAnOiAnIzVENDAzNycsXG4gICAgICAgICc4MDAnOiAnIzRFMzQyRScsXG4gICAgICAgICc5MDAnOiAnIzNFMjcyMydcbiAgICB9LFxuICAgICdncmV5Jzoge1xuICAgICAgICAnNTAnOiAnI0ZBRkFGQScsXG4gICAgICAgICcxMDAnOiAnI0Y1RjVGNScsXG4gICAgICAgICcyMDAnOiAnI0VFRUVFRScsXG4gICAgICAgICczMDAnOiAnI0UwRTBFMCcsXG4gICAgICAgICc0MDAnOiAnI0JEQkRCRCcsXG4gICAgICAgICc1MDAnOiAnIzlFOUU5RScsXG4gICAgICAgICc2MDAnOiAnIzc1NzU3NScsXG4gICAgICAgICc3MDAnOiAnIzYxNjE2MScsXG4gICAgICAgICc4MDAnOiAnIzQyNDI0MicsXG4gICAgICAgICc5MDAnOiAnIzIxMjEyMSdcbiAgICB9LFxuICAgICdibHVlR3JleSc6IHtcbiAgICAgICAgJzUwJzogJyNFQ0VGRjEnLFxuICAgICAgICAnMTAwJzogJyNDRkQ4REMnLFxuICAgICAgICAnMjAwJzogJyNCMEJFQzUnLFxuICAgICAgICAnMzAwJzogJyM5MEE0QUUnLFxuICAgICAgICAnNDAwJzogJyM3ODkwOUMnLFxuICAgICAgICAnNTAwJzogJyM2MDdEOEInLFxuICAgICAgICAnNjAwJzogJyM1NDZFN0EnLFxuICAgICAgICAnNzAwJzogJyM0NTVBNjQnLFxuICAgICAgICAnODAwJzogJyMzNzQ3NEYnLFxuICAgICAgICAnOTAwJzogJyMyNjMyMzgnXG4gICAgfSxcbiAgICAnYmxhY2snOiB7XG4gICAgICAgICc1MDAnOiAnIzAwMDAwMCcsXG4gICAgICAgICd0ZXh0JzogJ3JnYmEoMCwwLDAsMC44NyknLFxuICAgICAgICAnc2Vjb25kYXJ5VGV4dCc6ICdyZ2JhKDAsMCwwLDAuNTQpJyxcbiAgICAgICAgJ2ljb25zJzogJ3JnYmEoMCwwLDAsMC41NCknLFxuICAgICAgICAnZGlzYWJsZWQnOiAncmdiYSgwLDAsMCwwLjI2KScsXG4gICAgICAgICdoaW50VGV4dCc6ICdyZ2JhKDAsMCwwLDAuMjYpJyxcbiAgICAgICAgJ2RpdmlkZXJzJzogJ3JnYmEoMCwwLDAsMC4xMiknXG4gICAgfSxcbiAgICAnd2hpdGUnOiB7XG4gICAgICAgICc1MDAnOiAnI2ZmZmZmZicsXG4gICAgICAgICd0ZXh0JzogJyNmZmZmZmYnLFxuICAgICAgICAnc2Vjb25kYXJ5VGV4dCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuNyknLFxuICAgICAgICAnaWNvbnMnOiAnI2ZmZmZmZicsXG4gICAgICAgICdkaXNhYmxlZCc6ICdyZ2JhKDI1NSwyNTUsMjU1LDAuMyknLFxuICAgICAgICAnaGludFRleHQnOiAncmdiYSgyNTUsMjU1LDI1NSwwLjMpJyxcbiAgICAgICAgJ2RpdmlkZXJzJzogJ3JnYmEoMjU1LDI1NSwyNTUsMC4xMiknXG4gICAgfSxcbiAgICBnZXRSYW5kb21Db2xvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGRvIHtcbiAgICAgICAgICAgIGtleSA9IGtleXNbTWF0aC5yYW5kb20oKSAqIGtleXMubGVuZ3RoIDw8IDBdO1xuICAgICAgICB9IHdoaWxlIChrZXkgIT09ICdnZXRSYW5kb21Db2xvcicpXG5cbiAgICAgICAgcmV0dXJuIHRoaXNba2V5XVs1MDBdO1xuICAgIH1cbn07XG5cbiIsImltcG9ydCBGYW1vdXNFbmdpbmUgZnJvbSAnZmFtb3VzL3NyYy9jb3JlL0ZhbW91c0VuZ2luZSc7XG5pbXBvcnQgRE9NRWxlbWVudCBmcm9tICdmYW1vdXMvc3JjL2RvbS1yZW5kZXJhYmxlcy9ET01FbGVtZW50JztcbmltcG9ydCB7QXBwfSBmcm9tICcuL0FwcC8nO1xuXG5GYW1vdXNFbmdpbmUuaW5pdCgpO1xudmFyIHNjZW5lID0gRmFtb3VzRW5naW5lLmNyZWF0ZVNjZW5lKClcbnNjZW5lLmFkZENoaWxkKG5ldyBBcHAoKSk7XG5cblxuLy8gdmFyIEpJVFRFUiA9IHNjZW5lLmFkZENoaWxkKCk7XG4vLyBKSVRURVIuc2V0U2l6ZU1vZGUoMSwgMSwgMSk7XG4vLyBKSVRURVIuc2V0QWJzb2x1dGVTaXplKDEsIDEsIDEpXG4vLyB2YXIgZWwgPSBuZXcgRE9NRWxlbWVudChKSVRURVIsIHtjb250ZW50OiAnICd9KTtcbi8vIHZhciBpZCA9IEpJVFRFUi5hZGRDb21wb25lbnQoe1xuLy8gICAgIG9uVXBkYXRlOiBmdW5jdGlvbih0aW1lKSB7XG4vLyAgICAgICAgIEpJVFRFUi5zZXRQb3NpdGlvbigzMDAwICsgdGltZSAlIDEwMCwgMCwgLTQwMDAwKTtcbi8vICAgICAgICAgaWYgKHRpbWUgPCAyMDAwKSBKSVRURVIucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2soaWQpO1xuXG4vLyAgICAgfVxuLy8gfSk7XG5cbi8vIEpJVFRFUi5yZXF1ZXN0VXBkYXRlKGlkKTtcbiIsImltcG9ydCBOb2RlIGZyb20gJ2ZhbW91cy9zcmMvY29yZS9Ob2RlJztcbmltcG9ydCBET01FbGVtZW50IGZyb20gJ2ZhbW91cy9zcmMvZG9tLXJlbmRlcmFibGVzL0RPTUVsZW1lbnQnO1xuXG5leHBvcnQgY2xhc3MgTGF5ZXIgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpXG4gICAgICAgIG5ldyBET01FbGVtZW50KHRoaXMsIHtcbiAgICAgICAgICAgIGlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogb3B0aW9ucy5iYWNrZ3JvdW5kQ29sb3IsXG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtU3R5bGU6ICdmbGF0JyxcbiAgICAgICAgICAgICAgICBvdmVyZmxvdzogJ2hpZGRlbicsXG4gICAgICAgICAgICAgICAgekluZGV4OiBvcHRpb25zLnpJbmRleCxcbiAgICAgICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5leHBvc2VkTm9kZSA9IE5vZGUucHJvdG90eXBlLmFkZENoaWxkLmNhbGwodGhpcyk7XG4gICAgICAgIG5ldyBET01FbGVtZW50KHRoaXMuZXhwb3NlZE5vZGUsIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHlsZTogJ3ByZXNlcnZlLTNkJyxcbiAgICAgICAgICAgICAgICBwZXJzcGVjdGl2ZTogb3B0aW9ucy5wZXJzcGVjdGl2ZSxcbiAgICAgICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWRkQ2hpbGQobm9kZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5leHBvc2VkTm9kZS5hZGRDaGlsZChub2RlKTtcbiAgICB9XG59XG5cbiIsInZhciBOb2RlID0gcmVxdWlyZSgnZmFtb3VzL3NyYy9jb3JlL05vZGUnKTtcblxuZnVuY3Rpb24gR3JpZChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmNyZWF0ZShHcmlkLkRFRkFVTFRfUFJPUEVSVElFUyk7XG4gICAgTm9kZS5hcHBseSh0aGlzLCBvcHRpb25zKTtcblxuICAgIHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblxuICAgIF9sYXlvdXQodGhpcyk7XG5cbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHRoaXMuYWRkQ29tcG9uZW50KHtcbiAgICAgICAgb25TaXplQ2hhbmdlOiBmdW5jdGlvbihzaXplKSB7XG4gICAgICAgICAgICBfbGF5b3V0KF90aGlzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5HcmlkLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoTm9kZS5wcm90b3R5cGUpO1xuR3JpZC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBHcmlkO1xuXG5HcmlkLkRFRkFVTFRfUFJPUEVSVElFUyA9IHtcbiAgICBkaW1lbnNpb25zOiBbMCwgMF0sXG4gICAgdmVydGljYWxTcGFjaW5nOiAwLFxuICAgIGhvcml6b250YWxTcGFjaW5nOiAwXG59O1xuXG5mdW5jdGlvbiBfbGF5b3V0KGdyaWQpIHtcbiAgICB2YXIgc2l6ZSA9IGdyaWQuZ2V0U2l6ZSgpO1xuICAgIHZhciB1c2FibGVTaXplID0gW1xuICAgICAgICBzaXplWzBdIC0gKGdyaWQub3B0aW9ucy52ZXJ0aWNhbFNwYWNpbmcgKiAoZ3JpZC5vcHRpb25zLmRpbWVuc2lvbnNbMF0gLSAxKSksXG4gICAgICAgIHNpemVbMV0gLSAoZ3JpZC5vcHRpb25zLmhvcml6b250YWxTcGFjaW5nICogKGdyaWQub3B0aW9ucy5kaW1lbnNpb25zWzFdIC0gMSkpXG4gICAgXTtcbiAgICB2YXIgaXRlbVNpemUgPSBbdXNhYmxlU2l6ZVswXSAvIGdyaWQub3B0aW9ucy5kaW1lbnNpb25zWzBdLCB1c2FibGVTaXplWzFdIC8gZ3JpZC5vcHRpb25zLmRpbWVuc2lvbnNbMV1dO1xuICAgIHZhciBvZmZzZXRYID0gMDtcbiAgICB2YXIgb2Zmc2V0WSA9IDA7XG4gICAgdmFyIGNoaWxkcmVuID0gTm9kZS5wcm90b3R5cGUuZ2V0Q2hpbGRyZW4uY2FsbChncmlkKTtcbiAgICB2YXIgbGF5b3V0Tm9kZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JpZC5vcHRpb25zLmRpbWVuc2lvbnNbMF07IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGdyaWQub3B0aW9ucy5kaW1lbnNpb25zWzFdOyBqKyspIHtcbiAgICAgICAgICAgIGxheW91dE5vZGUgPSBjaGlsZHJlbltpICogZ3JpZC5vcHRpb25zLmRpbWVuc2lvbnNbMV0gKyBqXTtcblxuICAgICAgICAgICAgaWYgKCFsYXlvdXROb2RlKSByZXR1cm47XG5cbiAgICAgICAgICAgIGxheW91dE5vZGUuc2V0QWJzb2x1dGVTaXplKGl0ZW1TaXplWzBdLCBpdGVtU2l6ZVsxXSk7XG4gICAgICAgICAgICBsYXlvdXROb2RlLnNldFBvc2l0aW9uKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgICAgICAgb2Zmc2V0WCArPSAoZ3JpZC5vcHRpb25zLnZlcnRpY2FsU3BhY2luZyArIGl0ZW1TaXplWzBdKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG9mZnNldFggPSAwO1xuICAgICAgICBvZmZzZXRZICs9IChncmlkLm9wdGlvbnMuaG9yaXpvbnRhbFNwYWNpbmcgKyBpdGVtU2l6ZVsxXSk7XG4gICAgfVxufVxuXG5HcmlkLnByb3RvdHlwZS5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldENoaWxkcmVuKCkge1xuICAgIHZhciBjaGlsZHJlbiA9IE5vZGUucHJvdG90eXBlLmdldENoaWxkcmVuLmNhbGwodGhpcyk7XG4gICAgdmFyIGxlbiA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSByZXN1bHQucHVzaChjaGlsZHJlbltpXS5nZXRDaGlsZHJlbigpWzBdKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5HcmlkLnByb3RvdHlwZS5hZGRDaGlsZCA9IGZ1bmN0aW9uIGFkZENoaWxkKCkge1xuICAgIHZhciBsYXlvdXROb2RlID0gTm9kZS5wcm90b3R5cGUuYWRkQ2hpbGQuY2FsbCh0aGlzKTtcbiAgICBsYXlvdXROb2RlLnNldFNpemVNb2RlKDEsIDEsIDApO1xuICAgIGxheW91dE5vZGUuYWRkQ2hpbGQoKTtcbiAgICBfbGF5b3V0KHRoaXMpO1xuXG4gICAgcmV0dXJuIGxheW91dE5vZGU7XG59O1xuXG5cbkdyaWQucHJvdG90eXBlLmdldENoaWxkQXRJbmRleCA9IGZ1bmN0aW9uIGdldENoaWxkQXRJbmRleChpbmRleCkge1xuICAgIHJldHVybiBOb2RlLnByb3RvdHlwZS5nZXRDaGlsZHJlbi5jYWxsKHRoaXMpW2luZGV4XS5nZXRDaGlsZHJlbigpWzBdO1xufTtcblxuR3JpZC5wcm90b3R5cGUuZ2V0Um93ID0gZnVuY3Rpb24gZ2V0Um93KGluZGV4KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IE5vZGUucHJvdG90eXBlLmdldENoaWxkcmVuLmNhbGwodGhpcyk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMuZGltZW5zaW9uc1sxXTsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkcmVuW3JvdyAqIHRoaXMub3B0aW9ucy5kaW1lbnNpb25zWzFdICsgaV0uZ2V0Q2hpbGRyZW4oKVswXSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuR3JpZC5wcm90b3R5cGUuZ2V0Q29sdW1uID0gZnVuY3Rpb24gZ2V0Q29sdW1uKGluZGV4KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBjaGlsZHJlbiA9IE5vZGUucHJvdG90eXBlLmdldENoaWxkcmVuLmNhbGwodGhpcyk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm9wdGlvbnMuZGltZW5zaW9uc1swXTsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGNoaWxkcmVuW2ldKVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5HcmlkLnByb3RvdHlwZS5nZXRDaGlsZEF0Um93Q29sdW1uID0gZnVuY3Rpb24gZ2V0Q2hpbGRBdFJvd0NvbHVtbihyb3csIGNvbCkge1xuICAgIHJldHVybiBOb2RlLnByb3RvdHlwZS5nZXRDaGlsZHJlbi5jYWxsKHRoaXMpW3JvdyAqIHRoaXMub3B0aW9ucy5kaW1lbnNpb25zWzFdICsgY29sXS5nZXRDaGlsZHJlbigpWzBdO1xufTtcblxuR3JpZC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmRpbWVuc2lvbnMpIHRoaXMuc2V0RGltZW5zaW9ucyhvcHRpb25zLmRpbWVuc2lvbnNbMF0sIG9wdGlvbnMuZGltZW5zaW9uc1sxXSk7XG4gICAgaWYgKG9wdGlvbnMudmVydGljYWxTcGFjaW5nKSB0aGlzLnNldFZlcnRpY2FsU3BhY2luZyhvcHRpb25zLnZlcnRpY2FsU3BhY2luZyk7XG4gICAgaWYgKG9wdGlvbnMuaG9yaXpvbnRhbFNwYWNpbmcpIHRoaXMuc2V0SG9yaXpvbnRhbFNwYWNpbmcob3B0aW9ucy5ob3Jpem9udGFsU3BhY2luZyk7XG59O1xuXG5HcmlkLnByb3RvdHlwZS5zZXRWZXJ0aWNhbFNwYWNpbmcgPSBmdW5jdGlvbiBzZXRWZXJ0aWNhbFNwYWNpbmcodmVydGljYWxTcGFjaW5nKSB7XG4gICAgdGhpcy5vcHRpb25zLnZlcnRpY2FsU3BhY2luZyA9IHZlcnRpY2FsU3BhY2luZztcbiAgICBfbGF5b3V0KHRoaXMpO1xufTtcblxuR3JpZC5wcm90b3R5cGUuZ2V0VmVydGljYWxTcGFjaW5nID0gZnVuY3Rpb24gZ2V0VmVydGljYWxTcGFjaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMudmVydGljYWxTcGFjaW5nO1xufTtcblxuR3JpZC5wcm90b3R5cGUuc2V0SG9yaXpvbnRhbFNwYWNpbmcgPSBmdW5jdGlvbiBzZXRIb3Jpem9udGFsU3BhY2luZyhob3Jpem9udGFsU3BhY2luZykge1xuICAgIHRoaXMub3B0aW9ucy5ob3Jpem9udGFsU3BhY2luZyA9IGhvcml6b250YWxTcGFjaW5nO1xuICAgIF9sYXlvdXQodGhpcyk7XG59O1xuXG5HcmlkLnByb3RvdHlwZS5nZXRIb3Jpem9udGFsU3BhY2luZyA9IGZ1bmN0aW9uIGdldEhvcml6b250YWxTcGFjaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuaG9yaXpvbnRhbFNwYWNpbmc7XG59O1xuXG5HcmlkLnByb3RvdHlwZS5zZXREaW1lbnNpb25zID0gZnVuY3Rpb24gc2V0RGltZW5zaW9ucyh4LCB5KSB7XG4gICAgdGhpcy5vcHRpb25zLmRpbWVuc2lvbnNbMF0gPSB4O1xuICAgIHRoaXMub3B0aW9ucy5kaW1lbnNpb25zWzFdID0geTtcbn07XG5cbkdyaWQucHJvdG90eXBlLmdldERpbWVuc2lvbnMgPSBmdW5jdGlvbiBnZXREaW1lbnNpb25zKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnMuZGltZW5zaW9ucztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gR3JpZDtcbiIsImltcG9ydCBOb2RlIGZyb20gJ2ZhbW91cy9zcmMvY29yZS9Ob2RlJztcbmltcG9ydCBNb3VudFBvaW50IGZyb20gJ2ZhbW91cy9zcmMvY29tcG9uZW50cy9Nb3VudFBvaW50JztcbmltcG9ydCBBbGlnbiBmcm9tICdmYW1vdXMvc3JjL2NvbXBvbmVudHMvQWxpZ24nO1xuaW1wb3J0IFNpemUgZnJvbSAnZmFtb3VzL3NyYy9jb21wb25lbnRzL1NpemUnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnZmFtb3VzL3NyYy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudCc7XG5pbXBvcnQgVHJhbnNpdGlvbmFibGUgZnJvbSAnZmFtb3VzL3NyYy90cmFuc2l0aW9ucy9UcmFuc2l0aW9uYWJsZSc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4uL2hlbHBlcnMvY29sb3JzJztcblxuZXhwb3J0IGNsYXNzIExvZ28gZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuYWRkQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5yb290LnNldE9yaWdpbiguNSwgLjUpO1xuICAgICAgICB2YXIgbG9nb0FsaWduID0gbmV3IEFsaWduKHRoaXMucm9vdCk7XG4gICAgICAgIGxvZ29BbGlnbi5zZXQoLjUsIC41KTtcbiAgICAgICAgdmFyIGxvZ29Nb3VudFBvaW50ID0gbmV3IE1vdW50UG9pbnQodGhpcy5yb290KTtcbiAgICAgICAgbG9nb01vdW50UG9pbnQuc2V0KC41LCAuNSk7XG4gICAgICAgIHZhciBsb2dvU2l6ZSA9IG5ldyBTaXplKHRoaXMucm9vdCk7XG4gICAgICAgIGxvZ29TaXplLnNldEFic29sdXRlKDMwMCwgNzAsIDApO1xuICAgICAgICB0aGlzLnJvb3Quc2V0U2l6ZU1vZGUoMSwgMSwgMSk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxvZ29BbGlnbi5zZXQoLjA1LCAuMDUsIDAsIHtjdXJ2ZTogJ2Vhc2VPdXQnLCBkdXJhdGlvbjogMH0pO1xuICAgICAgICAgICAgbG9nb01vdW50UG9pbnQuc2V0KDAsIDAsIDAsIHtjdXJ2ZTogJ2Vhc2VPdXQnLCBkdXJhdGlvbjogMH0pO1xuICAgICAgICAgICAgbG9nb1NpemUuc2V0QWJzb2x1dGUoNTAsIDcwLCAwLCB7Y3VydmU6ICdlYXNlT3V0JywgZHVyYXRpb246IDB9KTtcbiAgICAgICAgfSwgMSk7XG5cbiAgICAgICAgdGhpcy5lbCA9IG5ldyBET01FbGVtZW50KHRoaXMucm9vdCwge1xuICAgICAgICAgICAgY29udGVudDogJ00nLFxuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiAnNDhweCcsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogJ2Z1dHVyYScsXG4gICAgICAgICAgICAgICAgbGluZUhlaWdodDogJzYwcHgnLFxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2NlbnRlcicsXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcidcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ib3R0b20gPSB0aGlzLnJvb3QuYWRkQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc2V0QWJzb2x1dGVTaXplKG51bGwsIDgsIG51bGwpO1xuICAgICAgICB0aGlzLmJvdHRvbS5zZXRTaXplTW9kZSgwLCAxLCAwKTtcbiAgICAgICAgdGhpcy5ib3R0b20uc2V0QWxpZ24oMCwgMSwgMCk7XG4gICAgICAgIHRoaXMuYm90dG9tLnNldE1vdW50UG9pbnQoMCwgMSwgMCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQmFyKCk7XG5cbiAgICAgICAgdGhpcy5hbmltYXRlT3V0KCk7XG4gICAgfVxuXG4gICAgY3JlYXRlQmFyKCkge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgdmFyIGJhckNvbG9ycyA9IFsncGluaycsICdvcmFuZ2UnLCAneWVsbG93JywgJ2dyZWVuJywgJ2xpZ2h0Qmx1ZScsICdwdXJwbGUnXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuYm90dG9tLmFkZENoaWxkKCk7XG4gICAgICAgICAgICBub2RlLnNldEFsaWduKGkvNiwgMCwgMCk7XG4gICAgICAgICAgICBub2RlLnNldFByb3BvcnRpb25hbFNpemUoMS82LCAxLCAxKTtcbiAgICAgICAgICAgIG5ldyBET01FbGVtZW50KG5vZGUsIHtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzW2JhckNvbG9yc1tpXV1bNTAwXVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYW5pbWF0ZU91dCgpIHtcblxuICAgIH1cbn1cbiIsImltcG9ydCBOb2RlIGZyb20gJ2ZhbW91cy9zcmMvY29yZS9Ob2RlJztcbmltcG9ydCBPcGFjaXR5IGZyb20gJ2ZhbW91cy9zcmMvY29tcG9uZW50cy9PcGFjaXR5JztcbmltcG9ydCBET01FbGVtZW50IGZyb20gJ2ZhbW91cy9zcmMvZG9tLXJlbmRlcmFibGVzL0RPTUVsZW1lbnQnO1xuaW1wb3J0IFRyYW5zaXRpb25hYmxlIGZyb20gJ2ZhbW91cy9zcmMvdHJhbnNpdGlvbnMvVHJhbnNpdGlvbmFibGUnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuLi9oZWxwZXJzL2NvbG9ycyc7XG5pbXBvcnQge1NhbmRib3h9IGZyb20gJy4uL3NhbmRib3gvJztcbmltcG9ydCB7QWJvdXR9IGZyb20gJy4uL2Fib3V0Lyc7XG5cbmV4cG9ydCBjbGFzcyBNYWluQ29udHJvbGxlciBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG15VXBkYXRlckNvbXBvbmVudElEID0gdGhpcy5hZGRDb21wb25lbnQoe1xuICAgICAgICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgICAgICAvL0RvIGxvZ2ljXG5cbiAgICAgICAgICAgICAgICAvLyBSZXBlYXQgbmV4dCBmcmFtZVxuICAgICAgICAgICAgICAgIF90aGlzLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrKG15VXBkYXRlckNvbXBvbmVudElEKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yZXF1ZXN0VXBkYXRlKG15VXBkYXRlckNvbXBvbmVudElEKTtcblxuICAgICAgICB0aGlzLmN1cnJlbnRTZWN0aW9uO1xuICAgICAgICB0aGlzLmN1cnJOb2RlID0gdGhpcy5hZGRDaGlsZCgpO1xuICAgICAgICB0aGlzLm5leHROb2RlID0gdGhpcy5hZGRDaGlsZCgpO1xuICAgICAgICB0aGlzLm5leHROb2RlT3BhY2l0eSA9IG5ldyBPcGFjaXR5KHRoaXMubmV4dE5vZGUpO1xuICAgICAgICB0aGlzLm5leHROb2RlT3BhY2l0eS5zZXQoMCk7XG4gICAgICAgIHRoaXMuY3Vyck5vZGVPcGFjaXR5ID0gbmV3IE9wYWNpdHkodGhpcy5jdXJyTm9kZSk7XG5cbiAgICAgICAgdGhpcy5zZWN0aW9ucyA9IHtcbiAgICAgICAgICAgIGFib3V0OiBBYm91dCxcbiAgICAgICAgICAgIHNhbmRib3g6IFNhbmRib3hcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNob3coJ3NhbmRib3gnKTtcbiAgICB9XG5cbiAgICBzaG93KHNlY3Rpb24sIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgICBpZiAoc2VjdGlvbiAhPT0gdGhpcy5jdXJyZW50U2VjdGlvbikgIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFNlY3Rpb24gPSBzZWN0aW9uO1xuXG4gICAgICAgICAgICB0aGlzLm5leHROb2RlLmFkZENoaWxkKG5ldyAodGhpcy5zZWN0aW9uc1tzZWN0aW9uXSkoKSk7XG5cbiAgICAgICAgICAgIHRoaXMubmV4dE5vZGVPcGFjaXR5LnNldCgxLCB7Y3VydmU6ICdlYXNlSW5PdXQnLCBkdXJhdGlvbjogMTAwMH0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIHZhciB0ZW1wID0gX3RoaXMuY3Vyck5vZGU7XG4gICAgICAgICAgICAgICAgLy8gX3RoaXMuY3Vyck5vZGUgPSBfdGhpcy5uZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICAvLyBfdGhpcy5uZXh0Tm9kZSA9IHRlbXA7XG4gICAgICAgICAgICAgICAgLy8gX3RoaXMubmV4dE5vZGUucmVtb3ZlQWxsQ2hpbGRyZW4oKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB0aGlzLmN1cnJOb2RlT3BhY2l0eS5zZXQoMCwge2N1cnZlOiAnZWFzZUluT3V0JywgZHVyYXRpb246IDEwMDB9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuIiwiaW1wb3J0IE5vZGUgZnJvbSAnZmFtb3VzL3NyYy9jb3JlL05vZGUnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnZmFtb3VzL3NyYy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudCc7XG5pbXBvcnQgVHJhbnNpdGlvbmFibGUgZnJvbSAnZmFtb3VzL3NyYy90cmFuc2l0aW9ucy9UcmFuc2l0aW9uYWJsZSc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4uL2hlbHBlcnMvY29sb3JzJztcbmltcG9ydCB7TGF5ZXJ9IGZyb20gJy4uL2xheWVycy8nO1xuXG5leHBvcnQgY2xhc3MgTW9kYWwgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuYWRkQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5yb290LnNldE9wYWNpdHkoMCk7XG5cbiAgICAgICAgdGhpcy5iYWNrZ3JvdW5kID0gdGhpcy5yb290LmFkZENoaWxkKG5ldyBMYXllcih7IFxuICAgICAgICAgICAgaWQ6ICdtb2RhbEJhY2tncm91bmQnLFxuICAgICAgICAgICAgekluZGV4OiAxXG4gICAgICAgIH0pKTtcblxuICAgICAgICB0aGlzLmJhY2tncm91bmQuc2V0T3BhY2l0eSguOCk7XG4gICAgICAgIHRoaXMuYmFja2dyb3VuZEVsID0gbmV3IERPTUVsZW1lbnQodGhpcy5iYWNrZ3JvdW5kLCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJyMyMTIxMjEnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZm9yZWdyb3VuZCA9IHRoaXMucm9vdC5hZGRDaGlsZChuZXcgTGF5ZXIoeyBcbiAgICAgICAgICAgIHpJbmRleDogMixcbiAgICAgICAgICAgIHBlcnNwZWN0aXZlOiAnMjAwMHB4J1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgdGhpcy5zcXVhcmUgPSB0aGlzLmZvcmVncm91bmQuYWRkQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5zcXVhcmUuc2V0U2l6ZU1vZGUoMSwgMSwgMCk7XG4gICAgICAgIHRoaXMuc3F1YXJlLnNldEFic29sdXRlU2l6ZSg1MDAsIDUwMCk7XG4gICAgICAgIHRoaXMuc3F1YXJlLnNldEFsaWduKC41LCAuNSk7XG4gICAgICAgIHRoaXMuc3F1YXJlLnNldE1vdW50UG9pbnQoLjUsIC41KTtcbiAgICAgICAgbmV3IERPTUVsZW1lbnQodGhpcy5zcXVhcmUsIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAncG9pbnRlci1ldmVudHMnOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBjb2xvcnMubGlnaHRCbHVlWzUwMF0sXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMjBweCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5leGl0ID0gdGhpcy5zcXVhcmUuYWRkQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5leGl0LnNldEFsaWduKDEsIDApO1xuICAgICAgICB0aGlzLmV4aXQuc2V0TW91bnRQb2ludCguNSwgLjUpO1xuICAgICAgICB0aGlzLmV4aXQuc2V0U2l6ZU1vZGUoMSwgMSwgMCk7XG4gICAgICAgIHRoaXMuZXhpdC5zZXRBYnNvbHV0ZVNpemUoNTAsIDUwKTtcbiAgICAgICAgbmV3IERPTUVsZW1lbnQodGhpcy5leGl0LCB7XG4gICAgICAgICAgICBjb250ZW50OiAnWCcsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgJ3BvaW50ZXItZXZlbnRzJzogJ25vbmUnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnd2hpdGUnLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzLmRlZXBPcmFuZ2VbNTAwXSxcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAnNTBweCcsXG4gICAgICAgICAgICAgICAgYm9yZGVyUmFkaXVzOiAnMjVweCcsXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnZnV0dXJhJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzI0cHgnLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBzaG93KCkge1xuICAgICAgICB0aGlzLnJvb3Quc2V0T3BhY2l0eSgxKTtcbiAgICB9XG5cbiAgICBoaWRlKCkge1xuICAgICAgICB0aGlzLnJvb3Quc2V0T3BhY2l0eSgwKTtcbiAgICB9XG59IiwiaW1wb3J0IE5vZGUgZnJvbSAnZmFtb3VzL3NyYy9jb3JlL05vZGUnO1xuaW1wb3J0IHtCb3h9IGZyb20gJy4uLy4uL2hlbHBlcnMvYm94L0JveCc7XG5pbXBvcnQge01pZGRsZUJveH0gZnJvbSAnLi4vLi4vaGVscGVycy9ib3gvTWlkZGxlQm94JztcblxuZXhwb3J0IGNsYXNzIFRlbnRhY2xlcyBleHRlbmRzIE5vZGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuXG4gICAgICAgIHRoaXMuc2V0QWJzb2x1dGVTaXplKDEyMCwgMTIwLCAxMjApO1xuICAgICAgICB0aGlzLnNldE9yaWdpbiguNSwgLjUsIC41KTtcbiAgICAgICAgdGhpcy5zZXRNb3VudFBvaW50KC41LCAuNSwgLjUpO1xuICAgICAgICB0aGlzLnNldEFsaWduKC41LCAuNSwgLjUpO1xuICAgICAgICB0aGlzLnNldFNpemVNb2RlKDEsIDEsIDEpO1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGlkID0gdGhpcy5hZGRDb21wb25lbnQoe1xuICAgICAgICAgICAgb25VcGRhdGU6IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldFJvdGF0aW9uKHRpbWUvMTAwMCwgdGltZS82MDAsIDApO1xuICAgICAgICAgICAgICAgIHNlbGYucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2soaWQpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZWxmLnJlcXVlc3RVcGRhdGUoaWQpO1xuXG4gICAgICAgIHRoaXMuYWRkQ2hpbGQobmV3IEJveCh7XG4gICAgICAgICAgICBjb2xvcnM6IFtdLFxuICAgICAgICAgICAgdHlwZTogJ2RvbSdcbiAgICAgICAgfSkpO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZU1pZGRsZUJveGVzKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZU1pZGRsZUJveGVzKCkge1xuICAgICAgICB2YXIgZGlyZWN0aW9ucyA9IFsnK3onLCAnLXonLCAnLXgnLCAnK3gnLCAnLXknLCAnK3knXTtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbnVtRGlyZWN0aW9ucyA9IGRpcmVjdGlvbnMubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMubWlkZGxlUm90YXRpb25Ob2RlID0gdGhpcy5hZGRDaGlsZCgpO1xuICAgICAgICB0aGlzLm1pZGRsZVJvdGF0aW9uTm9kZS5zZXRBYnNvbHV0ZVNpemUoNjAsIDYwLCA2MCk7XG4gICAgICAgIHRoaXMubWlkZGxlUm90YXRpb25Ob2RlLnNldE9yaWdpbiguNSwgLjUsIC41KTtcbiAgICAgICAgdGhpcy5taWRkbGVSb3RhdGlvbk5vZGUuc2V0TW91bnRQb2ludCguNSwgLjUsIC41KTtcbiAgICAgICAgdGhpcy5taWRkbGVSb3RhdGlvbk5vZGUuc2V0QWxpZ24oLjUsIC41LCAuNSk7XG4gICAgICAgIHRoaXMubWlkZGxlUm90YXRpb25Ob2RlLnNldFNpemVNb2RlKDEsIDEsIDEpO1xuXG4gICAgICAgIGZvciAoOyBpIDwgbnVtRGlyZWN0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLm1pZGRsZVJvdGF0aW9uTm9kZS5hZGRDaGlsZChuZXcgTWlkZGxlQm94KHsgZGlyZWN0aW9uOiBkaXJlY3Rpb25zW2ldIH0pKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImltcG9ydCBOb2RlIGZyb20gJ2ZhbW91cy9zcmMvY29yZS9Ob2RlJztcbmltcG9ydCBET01FbGVtZW50IGZyb20gJ2ZhbW91cy9zcmMvZG9tLXJlbmRlcmFibGVzL0RPTUVsZW1lbnQnO1xuaW1wb3J0IFRyYW5zaXRpb25hYmxlIGZyb20gJ2ZhbW91cy9zcmMvdHJhbnNpdGlvbnMvVHJhbnNpdGlvbmFibGUnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuLi8uLi9oZWxwZXJzL2NvbG9ycyc7XG5cbmV4cG9ydCBjbGFzcyBUdW5uZWxzIGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlV2luZG93ID0gdGhpcy5hZGRDaGlsZCgpO1xuICAgICAgICBuZXcgRE9NRWxlbWVudCh0aGlzLnBlcnNwZWN0aXZlV2luZG93LCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgcGVyc3BlY3RpdmU6ICc1MDAwcHgnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMucGVyc3BlY3RpdmVXaW5kb3cuYWRkQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5yb290LnNldEFic29sdXRlU2l6ZSg0MDAsIDQwMCwgMCk7XG4gICAgICAgIHRoaXMucm9vdC5zZXRPcmlnaW4oLjUsIC41LCAuNSk7XG4gICAgICAgIHRoaXMucm9vdC5zZXRNb3VudFBvaW50KC41LCAuNSwgLjUpO1xuICAgICAgICB0aGlzLnJvb3Quc2V0QWxpZ24oLjUsIC41LCAuNSk7XG4gICAgICAgIHRoaXMucm9vdC5zZXRTaXplTW9kZSgxLCAxLCAxKTtcblxuICAgICAgICB0aGlzLm1pblNwYWNpbmcgPSAyMDtcbiAgICAgICAgdGhpcy5tYXhTcGFjaW5nID0gNDA7XG4gICAgICAgIHRoaXMuYm9yZGVyUmFkaXVzID0gNTA7XG4gICAgICAgIHRoaXMuc3BhY2luZyA9IG5ldyBUcmFuc2l0aW9uYWJsZSgwKTtcbiAgICAgICAgdGhpcy50b3JxdWUgPSBuZXcgVHJhbnNpdGlvbmFibGUoMCk7IFxuXG4gICAgICAgIHRoaXMuc2xpY2VzID0gW107XG5cbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGlkID0gdGhpcy5yb290LmFkZENvbXBvbmVudCh7XG4gICAgICAgICAgICBvblVwZGF0ZTogZnVuY3Rpb24odGltZSkge1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBfdGhpcy5zbGljZXMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciB0b3JxdWUgPSBfdGhpcy50b3JxdWUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgdmFyIHNwYWNpbmcgPSBfdGhpcy5zcGFjaW5nLmdldCgpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2xpY2VzW2ldLnNldFBvc2l0aW9uKDAsIDAsIChpICogc3BhY2luZykgLSAobGVuLzIpICogc3BhY2luZyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIF90aGlzLnNsaWNlc1tpXS5zZXRSb3RhdGlvbigwLCAwLCB0b3JxdWUgKiAyICogTWF0aC5QSSAqIC0oaSAtIGxlbi8yICkgLyBsZW4pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zbGljZXNbaV0uc2V0Um90YXRpb24oMCwgMCwgKGkgLSBsZW4vMikgLyAobGVuLzIpICogdG9ycXVlICogMiAqIE1hdGguUEkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF90aGlzLnJvb3Quc2V0Um90YXRpb24odGltZS8yMDAwLCB0aW1lLzIwMDAsIDApO1xuICAgICAgICAgICAgICAgIF90aGlzLnJvb3QucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2soaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5yb290LnJlcXVlc3RVcGRhdGUoaWQpO1xuXG4gICAgICAgIHRoaXMuX2NyZWF0ZVRyZWUoKTtcbiAgICAgICAgdGhpcy5zdGFydEJyZWF0aCgpO1xuICAgICAgICB0aGlzLnN0YXJ0VG9ycXVlQW5pbWF0aW9uKCk7XG4gICAgfVxuXG4gICAgX2NyZWF0ZVRyZWUoKSB7XG4gICAgICAgIHZhciBub2RlO1xuICAgICAgICB2YXIgbXlDb2xvcnMgPSBbJ2dyZWVuJywgJ3llbGxvdycsICdwdXJwbGUnXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDMwOyBpKyspIHtcbiAgICAgICAgICAgIG5vZGUgPSB0aGlzLnJvb3QuYWRkQ2hpbGQoKTtcbiAgICAgICAgICAgIG5vZGUuc2V0UG9zaXRpb24oMCwgMCwgKC0xMCAqIGkpICsgMjUwKTtcbiAgICAgICAgICAgIG5vZGUuc2V0T3JpZ2luKC41LCAuNSwgLjUpO1xuICAgICAgICAgICAgbmV3IERPTUVsZW1lbnQobm9kZSwge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyOiAnMTBweCBzb2xpZCAnICsgY29sb3JzW215Q29sb3JzW2kgJSAzXV1bJzUwMCddLFxuICAgICAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHRoaXMuYm9yZGVyUmFkaXVzICsgJ3B4J1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAvLyBub2RlLnNldE9wYWNpdHkoLjUpXG4gICAgICAgICAgICB0aGlzLnNsaWNlcy5wdXNoKG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3RhcnRUb3JxdWVBbmltYXRpb24oKSB7XG4gICAgICAgIHRoaXMudG9ycXVlLnNldCgxLCB7XG4gICAgICAgICAgICBjdXJ2ZTogJ2Vhc2VJbk91dCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogNTAwMFxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudG9ycXVlLnNldCgwLCB7XG4gICAgICAgICAgICAgICAgY3VydmU6ICdlYXNlSW5PdXQnLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA1MDAwXG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0VG9ycXVlQW5pbWF0aW9uKClcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgfVxuICAgIFxuXG4gICAgc3RhcnRCcmVhdGgoKSB7XG4gICAgICAgIHRoaXMuc3BhY2luZy5zZXQodGhpcy5tYXhTcGFjaW5nLCB7XG4gICAgICAgICAgICBjdXJ2ZTogJ2Vhc2VJbk91dCcsXG4gICAgICAgICAgICBkdXJhdGlvbjogNzAwMFxuICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuc3BhY2luZy5zZXQodGhpcy5taW5TcGFjaW5nLCB7XG4gICAgICAgICAgICAgICAgY3VydmU6ICdlYXNlSW5PdXQnLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiA3MDAwXG4gICAgICAgICAgICB9LCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0QnJlYXRoKCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH1cblxuICAgIGdldFNpZGViYXIoKSB7XG5cbiAgICB9XG59XG4iLCJpbXBvcnQgTm9kZSBmcm9tICdmYW1vdXMvc3JjL2NvcmUvTm9kZSc7XG5pbXBvcnQgTW91bnRQb2ludCBmcm9tICdmYW1vdXMvc3JjL2NvbXBvbmVudHMvTW91bnRQb2ludCc7XG5pbXBvcnQgQWxpZ24gZnJvbSAnZmFtb3VzL3NyYy9jb21wb25lbnRzL0FsaWduJztcbmltcG9ydCBTaXplIGZyb20gJ2ZhbW91cy9zcmMvY29tcG9uZW50cy9TaXplJztcbmltcG9ydCBET01FbGVtZW50IGZyb20gJ2ZhbW91cy9zcmMvZG9tLXJlbmRlcmFibGVzL0RPTUVsZW1lbnQnO1xuaW1wb3J0IFRyYW5zaXRpb25hYmxlIGZyb20gJ2ZhbW91cy9zcmMvdHJhbnNpdGlvbnMvVHJhbnNpdGlvbmFibGUnO1xuaW1wb3J0IGNvbG9ycyBmcm9tICcuLi9oZWxwZXJzL2NvbG9ycyc7XG5pbXBvcnQge1RlbnRhY2xlc30gZnJvbSAnLi4vc2FuZGJveC9UZW50YWNsZXMnO1xuaW1wb3J0IHtUdW5uZWxzfSBmcm9tICcuLi9zYW5kYm94L1R1bm5lbHMnO1xuaW1wb3J0IHtTbGlkaW5nR3JpZH0gZnJvbSAnLi4vc2FuZGJveC9zbGlkaW5nR3JpZCc7XG5cbmV4cG9ydCBjbGFzcyBTYW5kYm94IGV4dGVuZHMgTm9kZSB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcblxuICAgICAgICB0aGlzLmFkZENoaWxkKG5ldyBUdW5uZWxzKCkpO1xuICAgICAgICAvLyB0aGlzLmFkZENoaWxkKG5ldyBUZW50YWNsZXMoKSk7XG4gICAgICAgIC8vIHRoaXMuYWRkQ2hpbGQobmV3IFNsaWRpbmdHcmlkKCkpO1xuICAgIH1cbn0iLCJpbXBvcnQgTm9kZSBmcm9tICdmYW1vdXMvc3JjL2NvcmUvTm9kZSc7XG5pbXBvcnQgRE9NRWxlbWVudCBmcm9tICdmYW1vdXMvc3JjL2RvbS1yZW5kZXJhYmxlcy9ET01FbGVtZW50JztcbmltcG9ydCBUcmFuc2l0aW9uYWJsZSBmcm9tICdmYW1vdXMvc3JjL3RyYW5zaXRpb25zL1RyYW5zaXRpb25hYmxlJztcbmltcG9ydCBjb2xvcnMgZnJvbSAnLi4vLi4vaGVscGVycy9jb2xvcnMnO1xuXG5leHBvcnQgY2xhc3MgU2xpZGluZ0dyaWQgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVXaW5kb3cgPSB0aGlzLmFkZENoaWxkKCk7XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVXaW5kb3cuc2V0UHJvcG9ydGlvbmFsU2l6ZSgxLDEsIDApXG4gICAgICAgIG5ldyBET01FbGVtZW50KHRoaXMucGVyc3BlY3RpdmVXaW5kb3csIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBwZXJzcGVjdGl2ZTogJzEwMDBweCdcbiAgICAgICAgICAgICAgICAvLyBiYWNrZ3JvdW5kOiAncmdiYSgyNTUsIDAsIDAsIC41KSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgICAgICB0aGlzLnJvb3QgPSB0aGlzLnBlcnNwZWN0aXZlV2luZG93LmFkZENoaWxkKCk7XG4gICAgICAgIHRoaXMucm9vdC5zZXRBYnNvbHV0ZVNpemUoNDAwMCwgMTAwMDAsIDApO1xuICAgICAgICB0aGlzLnJvb3Quc2V0U2l6ZU1vZGUoMSwgMSwgMSk7IFxuICAgICAgICB0aGlzLnJvb3Quc2V0T3JpZ2luKC41LCAxLCAwKTtcbiAgICAgICAgdGhpcy5yb290LnNldEFsaWduKC41LCAxLCAwKTtcbiAgICAgICAgdGhpcy5yb290LnNldE1vdW50UG9pbnQoLjUsIDEsIDApO1xuICAgICAgICB0aGlzLnJvb3Quc2V0Um90YXRpb24oTWF0aC5QSS8yLCAwLCAwKVxuICAgICAgICBuZXcgRE9NRWxlbWVudCh0aGlzLnJvb3QsIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiAnZ3JlZW4nXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLnJvb3QuZ2V0U2l6ZSgpKVxuICAgICAgICB9LmJpbmQodGhpcyksIDEwMClcbiAgICB9XG5cbiAgICBfY3JlYXRlVHJlZSgpIHtcblxuICAgIH1cblxuICAgIGdldFNpZGViYXIoKSB7XG5cbiAgICB9XG59XG4iLCJpbXBvcnQgTm9kZSBmcm9tICdmYW1vdXMvc3JjL2NvcmUvTm9kZSc7XG5pbXBvcnQgTW91bnRQb2ludCBmcm9tICdmYW1vdXMvc3JjL2NvbXBvbmVudHMvTW91bnRQb2ludCc7XG5pbXBvcnQgUG9zaXRpb24gZnJvbSAnZmFtb3VzL3NyYy9jb21wb25lbnRzL1Bvc2l0aW9uJztcbmltcG9ydCBBbGlnbiBmcm9tICdmYW1vdXMvc3JjL2NvbXBvbmVudHMvQWxpZ24nO1xuaW1wb3J0IFNpemUgZnJvbSAnZmFtb3VzL3NyYy9jb21wb25lbnRzL1NpemUnO1xuaW1wb3J0IERPTUVsZW1lbnQgZnJvbSAnZmFtb3VzL3NyYy9kb20tcmVuZGVyYWJsZXMvRE9NRWxlbWVudCc7XG5pbXBvcnQgVHJhbnNpdGlvbmFibGUgZnJvbSAnZmFtb3VzL3NyYy90cmFuc2l0aW9ucy9UcmFuc2l0aW9uYWJsZSc7XG5pbXBvcnQgY29sb3JzIGZyb20gJy4uL2hlbHBlcnMvY29sb3JzJztcblxuZXhwb3J0IGNsYXNzIFNpZGViYXIgZXh0ZW5kcyBOb2RlIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMpO1xuXG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMuYWRkQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5yb290LnNldEFsaWduKDEsIDAsIDApO1xuICAgICAgICB0aGlzLnJvb3Quc2V0UG9zaXRpb24oLTQwLCAwLCAwKTtcbiAgICAgICAgdGhpcy5yb290LnNldEFic29sdXRlU2l6ZSgzMDAsIG51bGwsIG51bGwpO1xuICAgICAgICB0aGlzLnJvb3Quc2V0U2l6ZU1vZGUoMSwgMCwgMCk7XG5cbiAgICAgICAgdGhpcy5jb250YWluZXJFbCA9IG5ldyBET01FbGVtZW50KHRoaXMucm9vdCwge1xuICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgIGJveFNoYWRvdzogJzVweCAwcHggOHB4IHJnYmEoMCwwLDAsMC4yNiknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMucm9vdC5hZGRVSUV2ZW50KCdtb3VzZWVudGVyJyk7XG4gICAgICAgIHRoaXMucm9vdC5hZGRVSUV2ZW50KCdtb3VzZWxlYXZlJyk7XG4gICAgICAgIHRoaXMucm9vdC5hZGRVSUV2ZW50KCd0b3VjaHN0YXJ0Jyk7XG4gICAgICAgIHRoaXMucm9vdC5hZGRVSUV2ZW50KCdjbGljaycpO1xuICAgICAgICB0aGlzLnJvb3QuYWRkQ29tcG9uZW50KHtcbiAgICAgICAgICAgIG9uUmVjZWl2ZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIGlmIChlID09PSAnbW91c2VlbnRlcicpIHBvcy5zZXQoLTI2MCwgMCwgMCwge2N1cnZlOiAnbGluZWFyJywgZHVyYXRpb246IDMwMH0pO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGUgPT09ICdtb3VzZWxlYXZlJykgcG9zLnNldCg0MCwgMCwgMCwge2N1cnZlOiAnbGluZWFyJywgZHVyYXRpb246IDMwMH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnBhbmVsTm9kZSA9IHRoaXMucm9vdC5hZGRDaGlsZCgpO1xuICAgICAgICB0aGlzLnBhbmVsTm9kZS5zZXRQb3NpdGlvbig0MCwgMCwgMCk7XG4gICAgICAgIHZhciBwb3MgPSBuZXcgUG9zaXRpb24odGhpcy5wYW5lbE5vZGUpO1xuICAgICAgICBwb3Muc2V0KDQwKTtcbiAgICAgICAgbmV3IERPTUVsZW1lbnQodGhpcy5wYW5lbE5vZGUsIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICcjMzAzMDMwJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLnBhbmVsSGVhZGVyID0gdGhpcy5wYW5lbE5vZGUuYWRkQ2hpbGQoKTtcbiAgICAgICAgdGhpcy5wYW5lbEhlYWRlci5zZXRBYnNvbHV0ZVNpemUobnVsbCwgMjAwLCBudWxsKTtcbiAgICAgICAgdGhpcy5wYW5lbEhlYWRlci5zZXRTaXplTW9kZSgwLCAxLCAwKTtcbiAgICAgICAgbmV3IERPTUVsZW1lbnQodGhpcy5wYW5lbEhlYWRlciwge1xuICAgICAgICAgICAgY29udGVudDogJ1RlbnRhY2xlcycsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgcGFkZGluZ0xlZnQ6ICcyMHB4JyxcbiAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnZnV0dXJhJyxcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogJzQwcHgnLFxuICAgICAgICAgICAgICAgIGNvbG9yOiAnYmxhY2snLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogY29sb3JzLnllbGxvd1s1MDBdLFxuICAgICAgICAgICAgICAgIGxpbmVIZWlnaHQ6ICcyMDBweCcsXG4gICAgICAgICAgICAgICAgYm94U2hhZG93OiAnMHB4IDJweCA1cHggcmdiYSgwLDAsMCwwLjI2KSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICB0aGlzLnBhbmVsQm9keSA9IHRoaXMucGFuZWxOb2RlLmFkZENoaWxkKCk7XG4gICAgICAgIHRoaXMucGFuZWxCb2R5LnNldE9wYWNpdHkoLjUpXG4gICAgICAgIHRoaXMucGFuZWxCb2R5LnNldERpZmZlcmVudGlhbFNpemUoMCwgLTMwMCwgMCk7XG4gICAgICAgIHRoaXMucGFuZWxCb2R5LnNldFBvc2l0aW9uKDAsIDMwMCwgMCk7XG4gICAgICAgIG5ldyBET01FbGVtZW50KHRoaXMucGFuZWxOb2RlLCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnIzMwMzAzMCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICB9XG59IiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvc2l0aW9uID0gcmVxdWlyZSgnLi9Qb3NpdGlvbicpO1xuXG4vKipcbiAqIEFsaWduIGlzIGEgY29tcG9uZW50IGRlc2lnbmVkIHRvIGFsbG93IGZvciBzbW9vdGggdHdlZW5pbmdcbiAqIG9mIHRoZSBhbGlnbm1lbnQgb2YgYSBub2RlIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQuXG4gKlxuICogQGNsYXNzIEFsaWduXG4gKiBAYXVnbWVudHMgUG9zaXRpb25cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0aGF0IHRoZSBBbGlnbiBjb21wb25lbnQgd2lsbCBiZSBhdHRhY2hlZCB0b1xuICovXG5mdW5jdGlvbiBBbGlnbihub2RlKSB7XG4gICAgUG9zaXRpb24uY2FsbCh0aGlzLCBub2RlKTtcblxuICAgIHZhciBpbml0aWFsID0gbm9kZS5nZXRBbGlnbigpO1xuXG4gICAgdGhpcy5feC5zZXQoaW5pdGlhbFswXSk7XG4gICAgdGhpcy5feS5zZXQoaW5pdGlhbFsxXSk7XG4gICAgdGhpcy5fei5zZXQoaW5pdGlhbFsyXSk7XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBBbGlnbiBjb21wb25lbnRcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHRoZSBjb21wb25lbnRcbiAqL1xuQWxpZ24ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuICdBbGlnbic7XG59O1xuXG5BbGlnbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBvc2l0aW9uLnByb3RvdHlwZSk7XG5BbGlnbi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBBbGlnbjtcblxuLyoqXG4gKiBXaGVuIHRoZSBub2RlIHRoaXMgY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvIHVwZGF0ZXMsIHVwZGF0ZSB0aGUgdmFsdWVcbiAqIG9mIHRoZSBOb2RlJ3MgYWxpZ24uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkFsaWduLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRBbGlnbih0aGlzLl94LmdldCgpLCB0aGlzLl95LmdldCgpLCB0aGlzLl96LmdldCgpKTtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZSgpO1xufTtcblxuQWxpZ24ucHJvdG90eXBlLm9uVXBkYXRlID0gQWxpZ24ucHJvdG90eXBlLnVwZGF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBBbGlnbjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENvbW1hbmRzID0gcmVxdWlyZSgnLi4vY29yZS9Db21tYW5kcycpO1xuXG4vKipcbiAqIENhbWVyYSBpcyBhIGNvbXBvbmVudCB0aGF0IGlzIHJlc3BvbnNpYmxlIGZvciBzZW5kaW5nIGluZm9ybWF0aW9uIHRvIHRoZSByZW5kZXJlciBhYm91dCB3aGVyZVxuICogdGhlIGNhbWVyYSBpcyBpbiB0aGUgc2NlbmUuICBUaGlzIGFsbG93cyB0aGUgdXNlciB0byBzZXQgdGhlIHR5cGUgb2YgcHJvamVjdGlvbiwgdGhlIGZvY2FsIGRlcHRoLFxuICogYW5kIG90aGVyIHByb3BlcnRpZXMgdG8gYWRqdXN0IHRoZSB3YXkgdGhlIHNjZW5lcyBhcmUgcmVuZGVyZWQuXG4gKlxuICogQGNsYXNzIENhbWVyYVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0byB3aGljaCB0aGUgaW5zdGFuY2Ugb2YgQ2FtZXJhIHdpbGwgYmUgYSBjb21wb25lbnQgb2ZcbiAqL1xuZnVuY3Rpb24gQ2FtZXJhKG5vZGUpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTjtcbiAgICB0aGlzLl9mb2NhbERlcHRoID0gMDtcbiAgICB0aGlzLl9uZWFyID0gMDtcbiAgICB0aGlzLl9mYXIgPSAwO1xuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICB0aGlzLl9pZCA9IG5vZGUuYWRkQ29tcG9uZW50KHRoaXMpO1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm0gPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSk7XG4gICAgdGhpcy5fdmlld0RpcnR5ID0gZmFsc2U7XG4gICAgdGhpcy5fcGVyc3BlY3RpdmVEaXJ0eSA9IGZhbHNlO1xuICAgIHRoaXMuc2V0RmxhdCgpO1xufVxuXG5DYW1lcmEuRlJVU1RVTV9QUk9KRUNUSU9OID0gMDtcbkNhbWVyYS5QSU5IT0xFX1BST0pFQ1RJT04gPSAxO1xuQ2FtZXJhLk9SVEhPR1JBUEhJQ19QUk9KRUNUSU9OID0gMjtcblxuLyoqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHRoZSBjb21wb25lbnRcbiAqL1xuQ2FtZXJhLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnQ2FtZXJhJztcbn07XG5cbi8qKlxuICogR2V0cyBvYmplY3QgY29udGFpbmluZyBzZXJpYWxpemVkIGRhdGEgZm9yIHRoZSBjb21wb25lbnRcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgc3RhdGUgb2YgdGhlIGNvbXBvbmVudFxuICovXG5DYW1lcmEucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29tcG9uZW50OiB0aGlzLnRvU3RyaW5nKCksXG4gICAgICAgIHByb2plY3Rpb25UeXBlOiB0aGlzLl9wcm9qZWN0aW9uVHlwZSxcbiAgICAgICAgZm9jYWxEZXB0aDogdGhpcy5fZm9jYWxEZXB0aCxcbiAgICAgICAgbmVhcjogdGhpcy5fbmVhcixcbiAgICAgICAgZmFyOiB0aGlzLl9mYXJcbiAgICB9O1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNvbXBvbmVudHMgc3RhdGUgYmFzZWQgb24gc29tZSBzZXJpYWxpemVkIGRhdGFcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIGFuIG9iamVjdCBkZWZpbmluZyB3aGF0IHRoZSBzdGF0ZSBvZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHN0YXR1cyBvZiB0aGUgc2V0XG4gKi9cbkNhbWVyYS5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbiBzZXRWYWx1ZShzdGF0ZSkge1xuICAgIGlmICh0aGlzLnRvU3RyaW5nKCkgPT09IHN0YXRlLmNvbXBvbmVudCkge1xuICAgICAgICB0aGlzLnNldChzdGF0ZS5wcm9qZWN0aW9uVHlwZSwgc3RhdGUuZm9jYWxEZXB0aCwgc3RhdGUubmVhciwgc3RhdGUuZmFyKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBpbnRlcm5hbHMgb2YgdGhlIGNvbXBvbmVudFxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdHlwZSBhbiBpZCBjb3JyZXNwb25kaW5nIHRvIHRoZSB0eXBlIG9mIHByb2plY3Rpb24gdG8gdXNlXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggdGhlIGRlcHRoIGZvciB0aGUgcGluaG9sZSBwcm9qZWN0aW9uIG1vZGVsXG4gKiBAcGFyYW0ge051bWJlcn0gbmVhciB0aGUgZGlzdGFuY2Ugb2YgdGhlIG5lYXIgY2xpcHBpbmcgcGxhbmUgZm9yIGEgZnJ1c3R1bSBwcm9qZWN0aW9uXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIHRoZSBkaXN0YW5jZSBvZiB0aGUgZmFyIGNsaXBwaW5nIHBsYW5lIGZvciBhIGZydXN0dW0gcHJvamVjdGlvblxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHN0YXR1cyBvZiB0aGUgc2V0XG4gKi9cbkNhbWVyYS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gc2V0KHR5cGUsIGRlcHRoLCBuZWFyLCBmYXIpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3Byb2plY3Rpb25UeXBlID0gdHlwZTtcbiAgICB0aGlzLl9mb2NhbERlcHRoID0gZGVwdGg7XG4gICAgdGhpcy5fbmVhciA9IG5lYXI7XG4gICAgdGhpcy5fZmFyID0gZmFyO1xufTtcblxuLyoqXG4gKiBTZXQgdGhlIGNhbWVyYSBkZXB0aCBmb3IgYSBwaW5ob2xlIHByb2plY3Rpb24gbW9kZWxcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBDYW1lcmEgYW5kIHRoZSBvcmlnaW5cbiAqXG4gKiBAcmV0dXJuIHtDYW1lcmF9IHRoaXNcbiAqL1xuQ2FtZXJhLnByb3RvdHlwZS5zZXREZXB0aCA9IGZ1bmN0aW9uIHNldERlcHRoKGRlcHRoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICB0aGlzLl9wcm9qZWN0aW9uVHlwZSA9IENhbWVyYS5QSU5IT0xFX1BST0pFQ1RJT047XG4gICAgdGhpcy5fZm9jYWxEZXB0aCA9IGRlcHRoO1xuICAgIHRoaXMuX25lYXIgPSAwO1xuICAgIHRoaXMuX2ZhciA9IDA7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogR2V0cyBvYmplY3QgY29udGFpbmluZyBzZXJpYWxpemVkIGRhdGEgZm9yIHRoZSBjb21wb25lbnRcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG5lYXIgZGlzdGFuY2UgZnJvbSB0aGUgbmVhciBjbGlwcGluZyBwbGFuZSB0byB0aGUgY2FtZXJhXG4gKiBAcGFyYW0ge051bWJlcn0gZmFyIGRpc3RhbmNlIGZyb20gdGhlIGZhciBjbGlwcGluZyBwbGFuZSB0byB0aGUgY2FtZXJhXG4gKlxuICogQHJldHVybiB7Q2FtZXJhfSB0aGlzXG4gKi9cbkNhbWVyYS5wcm90b3R5cGUuc2V0RnJ1c3R1bSA9IGZ1bmN0aW9uIHNldEZydXN0dW0obmVhciwgZmFyKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3BlcnNwZWN0aXZlRGlydHkgPSB0cnVlO1xuICAgIHRoaXMuX3Byb2plY3Rpb25UeXBlID0gQ2FtZXJhLkZSVVNUVU1fUFJPSkVDVElPTjtcbiAgICB0aGlzLl9mb2NhbERlcHRoID0gMDtcbiAgICB0aGlzLl9uZWFyID0gbmVhcjtcbiAgICB0aGlzLl9mYXIgPSBmYXI7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0IHRoZSBDYW1lcmEgdG8gaGF2ZSBvcnRob2dyYXBoaWMgcHJvamVjdGlvblxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtDYW1lcmF9IHRoaXNcbiAqL1xuQ2FtZXJhLnByb3RvdHlwZS5zZXRGbGF0ID0gZnVuY3Rpb24gc2V0RmxhdCgpIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fcGVyc3BlY3RpdmVEaXJ0eSA9IHRydWU7XG4gICAgdGhpcy5fcHJvamVjdGlvblR5cGUgPSBDYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT047XG4gICAgdGhpcy5fZm9jYWxEZXB0aCA9IDA7XG4gICAgdGhpcy5fbmVhciA9IDA7XG4gICAgdGhpcy5fZmFyID0gMDtcblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBXaGVuIHRoZSBub2RlIHRoaXMgY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvIHVwZGF0ZXMsIHRoZSBDYW1lcmEgd2lsbFxuICogc2VuZCBuZXcgY2FtZXJhIGluZm9ybWF0aW9uIHRvIHRoZSBDb21wb3NpdG9yIHRvIHVwZGF0ZSB0aGUgcmVuZGVyaW5nXG4gKiBvZiB0aGUgc2NlbmUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNhbWVyYS5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZSgpIHtcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMuX25vZGUuZ2V0TG9jYXRpb24oKTtcblxuICAgIHRoaXMuX25vZGVcbiAgICAgICAgLnNlbmREcmF3Q29tbWFuZChDb21tYW5kcy5XSVRIKVxuICAgICAgICAuc2VuZERyYXdDb21tYW5kKHBhdGgpO1xuXG4gICAgaWYgKHRoaXMuX3BlcnNwZWN0aXZlRGlydHkpIHtcbiAgICAgICAgdGhpcy5fcGVyc3BlY3RpdmVEaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIHN3aXRjaCAodGhpcy5fcHJvamVjdGlvblR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ2FtZXJhLkZSVVNUVU1fUFJPSkVDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZChDb21tYW5kcy5GUlVTVFJVTV9QUk9KRUNUSU9OKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl9uZWFyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl9mYXIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDYW1lcmEuUElOSE9MRV9QUk9KRUNUSU9OOlxuICAgICAgICAgICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKENvbW1hbmRzLlBJTkhPTEVfUFJPSkVDVElPTik7XG4gICAgICAgICAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fZm9jYWxEZXB0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENhbWVyYS5PUlRIT0dSQVBISUNfUFJPSkVDVElPTjpcbiAgICAgICAgICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZChDb21tYW5kcy5PUlRIT0dSQVBISUNfUFJPSkVDVElPTik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdmlld0RpcnR5KSB7XG4gICAgICAgIHRoaXMuX3ZpZXdEaXJ0eSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKENvbW1hbmRzLkNIQU5HRV9WSUVXX1RSQU5TRk9STSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMF0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzFdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsyXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bM10pO1xuXG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bNF0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzVdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVs2XSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bN10pO1xuXG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bOF0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzldKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxMF0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzExXSk7XG5cbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxMl0pO1xuICAgICAgICB0aGlzLl9ub2RlLnNlbmREcmF3Q29tbWFuZCh0aGlzLl92aWV3VHJhbnNmb3JtWzEzXSk7XG4gICAgICAgIHRoaXMuX25vZGUuc2VuZERyYXdDb21tYW5kKHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTRdKTtcbiAgICAgICAgdGhpcy5fbm9kZS5zZW5kRHJhd0NvbW1hbmQodGhpcy5fdmlld1RyYW5zZm9ybVsxNV0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogV2hlbiB0aGUgdHJhbnNmb3JtIG9mIHRoZSBub2RlIHRoaXMgY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvXG4gKiBjaGFuZ2VzLCBoYXZlIHRoZSBDYW1lcmEgdXBkYXRlIGl0cyBwcm9qZWN0aW9uIG1hdHJpeCBhbmRcbiAqIGlmIG5lZWRlZCwgZmxhZyB0byBub2RlIHRvIHVwZGF0ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtIGFuIGFycmF5IGRlbm90aW5nIHRoZSB0cmFuc2Zvcm0gbWF0cml4IG9mIHRoZSBub2RlXG4gKlxuICogQHJldHVybiB7Q2FtZXJhfSB0aGlzXG4gKi9cbkNhbWVyYS5wcm90b3R5cGUub25UcmFuc2Zvcm1DaGFuZ2UgPSBmdW5jdGlvbiBvblRyYW5zZm9ybUNoYW5nZSh0cmFuc2Zvcm0pIHtcbiAgICB2YXIgYSA9IHRyYW5zZm9ybTtcbiAgICB0aGlzLl92aWV3RGlydHkgPSB0cnVlO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHZhciBhMDAgPSBhWzBdLCBhMDEgPSBhWzFdLCBhMDIgPSBhWzJdLCBhMDMgPSBhWzNdLFxuICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sIGExMyA9IGFbN10sXG4gICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgIGEzMCA9IGFbMTJdLCBhMzEgPSBhWzEzXSwgYTMyID0gYVsxNF0sIGEzMyA9IGFbMTVdLFxuXG4gICAgYjAwID0gYTAwICogYTExIC0gYTAxICogYTEwLFxuICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICBiMDIgPSBhMDAgKiBhMTMgLSBhMDMgKiBhMTAsXG4gICAgYjAzID0gYTAxICogYTEyIC0gYTAyICogYTExLFxuICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICBiMDUgPSBhMDIgKiBhMTMgLSBhMDMgKiBhMTIsXG4gICAgYjA2ID0gYTIwICogYTMxIC0gYTIxICogYTMwLFxuICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICBiMDggPSBhMjAgKiBhMzMgLSBhMjMgKiBhMzAsXG4gICAgYjA5ID0gYTIxICogYTMyIC0gYTIyICogYTMxLFxuICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICBiMTEgPSBhMjIgKiBhMzMgLSBhMjMgKiBhMzIsXG5cbiAgICBkZXQgPSAxLyhiMDAgKiBiMTEgLSBiMDEgKiBiMTAgKyBiMDIgKiBiMDkgKyBiMDMgKiBiMDggLSBiMDQgKiBiMDcgKyBiMDUgKiBiMDYpO1xuXG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzJdID0gKGEzMSAqIGIwNSAtIGEzMiAqIGIwNCArIGEzMyAqIGIwMykgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzVdID0gKGEwMCAqIGIxMSAtIGEwMiAqIGIwOCArIGEwMyAqIGIwNykgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzhdID0gKGExMCAqIGIxMCAtIGExMSAqIGIwOCArIGExMyAqIGIwNikgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsxMV0gPSAoYTIxICogYjAyIC0gYTIwICogYjA0IC0gYTIzICogYjAwKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIHRoaXMuX3ZpZXdUcmFuc2Zvcm1bMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgdGhpcy5fdmlld1RyYW5zZm9ybVsxNF0gPSAoYTMxICogYjAxIC0gYTMwICogYjAzIC0gYTMyICogYjAwKSAqIGRldDtcbiAgICB0aGlzLl92aWV3VHJhbnNmb3JtWzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW1lcmE7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb3NpdGlvbiA9IHJlcXVpcmUoJy4vUG9zaXRpb24nKTtcblxuLyoqXG4gKiBNb3VudFBvaW50IGlzIGEgY29tcG9uZW50IGRlc2lnbmVkIHRvIGFsbG93IGZvciBzbW9vdGggdHdlZW5pbmdcbiAqIG9mIHdoZXJlIG9uIHRoZSBOb2RlIGl0IGlzIGF0dGFjaGVkIHRvIHRoZSBwYXJlbnQuXG4gKlxuICogQGNsYXNzIE1vdW50UG9pbnRcbiAqIEBhdWdtZW50cyBQb3NpdGlvblxuICpcbiogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdGhhdCB0aGUgTW91bnRQb2ludCBjb21wb25lbnQgd2lsbCBiZSBhdHRhY2hlZCB0b1xuICovXG5mdW5jdGlvbiBNb3VudFBvaW50KG5vZGUpIHtcbiAgICBQb3NpdGlvbi5jYWxsKHRoaXMsIG5vZGUpO1xuXG4gICAgdmFyIGluaXRpYWwgPSBub2RlLmdldE1vdW50UG9pbnQoKTtcblxuICAgIHRoaXMuX3guc2V0KGluaXRpYWxbMF0pO1xuICAgIHRoaXMuX3kuc2V0KGluaXRpYWxbMV0pO1xuICAgIHRoaXMuX3ouc2V0KGluaXRpYWxbMl0pO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgTW91bnRQb2ludCBjb21wb25lbnRcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHRoZSBjb21wb25lbnRcbiAqL1xuTW91bnRQb2ludC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ01vdW50UG9pbnQnO1xufTtcblxuTW91bnRQb2ludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFBvc2l0aW9uLnByb3RvdHlwZSk7XG5Nb3VudFBvaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE1vdW50UG9pbnQ7XG5cbi8qKlxuICogV2hlbiB0aGUgbm9kZSB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0byB1cGRhdGVzLCB1cGRhdGUgdGhlIHZhbHVlXG4gKiBvZiB0aGUgTm9kZSdzIG1vdW50IHBvaW50LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Nb3VudFBvaW50LnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRNb3VudFBvaW50KHRoaXMuX3guZ2V0KCksIHRoaXMuX3kuZ2V0KCksIHRoaXMuX3ouZ2V0KCkpO1xuICAgIHRoaXMuX2NoZWNrVXBkYXRlKCk7XG59O1xuXG5Nb3VudFBvaW50LnByb3RvdHlwZS5vblVwZGF0ZSA9IE1vdW50UG9pbnQucHJvdG90eXBlLnVwZGF0ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBNb3VudFBvaW50O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqIFxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqIFxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICogXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKiBcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFRyYW5zaXRpb25hYmxlID0gcmVxdWlyZSgnLi4vdHJhbnNpdGlvbnMvVHJhbnNpdGlvbmFibGUnKTtcblxuXG4vKipcbiAqIE9wYWNpdHkgaXMgYSBjb21wb25lbnQgZGVzaWduZWQgdG8gYWxsb3cgZm9yIHNtb290aCB0d2VlbmluZ1xuICogb2YgdGhlIE5vZGUncyBvcGFjaXR5XG4gKlxuICogQGNsYXNzIE9wYWNpdHlcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0aGF0IHRoZSBPcGFjaXR5IGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0b1xuICovXG5mdW5jdGlvbiBPcGFjaXR5KG5vZGUpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9pZCA9IG5vZGUuYWRkQ29tcG9uZW50KHRoaXMpO1xuICAgIHRoaXMuX3ZhbHVlID0gbmV3IFRyYW5zaXRpb25hYmxlKDEpO1xuXG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgT3BhY2l0eSBjb21wb25lbnRcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHRoZSBjb21wb25lbnRcbiAqL1xuT3BhY2l0eS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ09wYWNpdHknO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgaW50ZXJuYWwgc3RhdGUgb2YgT3BhY2l0eSBjb21wb25lbnRcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBjb250YWlucyBjb21wb25lbnQga2V5IHdoaWNoIGhvbGRzIHRoZSBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciBcbiAqIGFuZCB2YWx1ZSBrZXkgd2hpY2ggY29udGFpbnMgdGhlIG51bWVyaWMgdmFsdWVcbiAqL1xuT3BhY2l0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnQ6IHRoaXMudG9TdHJpbmcoKSxcbiAgICAgICAgdmFsdWU6IHRoaXMuX3ZhbHVlLmdldCgpXG4gICAgfTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBpbnRlcm5hbCBzdGF0ZSBvZiB0aGUgT3BhY2l0eSBjb21wb25lbnRcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIE9iamVjdCBjb250YWluaW5nIHRoZSBjb21wb25lbnQga2V5LCB3aGljaCBob2xkcyBzdHJpbmdpZmllZCBjb25zdHJ1Y3RvciwgYW5kIGEgdmFsdWUga2V5LCB3aGljaCBjb250YWlucyBhIG51bWVyaWMgdmFsdWUgdXNlZCB0byBzZXQgb3BhY2l0eSBpZiB0aGUgY29uc3RydWN0b3IgdmFsdWUgbWF0Y2hlc1xuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHRydWUgaWYgc2V0IGlzIHN1Y2Nlc3NmdWwsIGZhbHNlIG90aGVyd2lzZVxuICovXG5PcGFjaXR5LnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMudG9TdHJpbmcoKSA9PT0gdmFsdWUuY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuc2V0KHZhbHVlLnZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0IHRoZSBvcGFjaXR5IG9mIHRoZSBOb2RlXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSB2YWx1ZSB1c2VkIHRvIHNldCBPcGFjaXR5XG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBvcHRpb25zIGZvciB0aGUgdHJhbnNpdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgdG8gYmUgY2FsbGVkIGZvbGxvd2luZyBPcGFjaXR5IHNldCBjb21wbGV0aW9uXG4gKlxuICogQHJldHVybiB7T3BhY2l0eX0gdGhpc1xuICovXG5PcGFjaXR5LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiBzZXQodmFsdWUsIHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB7XG4gICAgICAgIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZSh0aGlzLl9pZCk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRoaXMuX3ZhbHVlLnNldCh2YWx1ZSwgdHJhbnNpdGlvbiwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXQgdGhlIGN1cnJlbnQgb3BhY2l0eSBmb3IgdGhlIGNvbXBvbmVudFxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IG9wYWNpdHkgYXMga25vd24gYnkgdGhlIGNvbXBvbmVudFxuICovXG5PcGFjaXR5LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ZhbHVlLmdldCgpO1xufTtcblxuLyoqXG4gKiBTdG9wcyBPcGFjaXR5IHRyYW5zaXRpb25cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7T3BhY2l0eX0gdGhpc1xuICovXG5PcGFjaXR5LnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICB0aGlzLl92YWx1ZS5oYWx0KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFRlbGxzIHdoZXRoZXIgb3Igbm90IHRoZSBvcGFjaXR5IGlzIGluIGEgdHJhbnNpdGlvblxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgb3BhY2l0eSBpcyB0cmFuc2l0aW9uaW5nXG4gKi9cbk9wYWNpdHkucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKXtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWUuaXNBY3RpdmUoKTtcbn07XG5cbi8qKlxuICogV2hlbiB0aGUgbm9kZSB0aGlzIGNvbXBvbmVudCBpcyBhdHRhY2hlZCB0byB1cGRhdGVzLCB1cGRhdGUgdGhlIHZhbHVlXG4gKiBvZiB0aGUgTm9kZSdzIG9wYWNpdHkuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbk9wYWNpdHkucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAoKSB7XG4gICAgdGhpcy5fbm9kZS5zZXRPcGFjaXR5KHRoaXMuX3ZhbHVlLmdldCgpKTtcbiAgICBcbiAgICBpZiAodGhpcy5fdmFsdWUuaXNBY3RpdmUoKSkge1xuICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzLl9pZCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIH1cbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLm9uVXBkYXRlID0gT3BhY2l0eS5wcm90b3R5cGUudXBkYXRlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wYWNpdHk7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNpdGlvbmFibGUgPSByZXF1aXJlKCcuLi90cmFuc2l0aW9ucy9UcmFuc2l0aW9uYWJsZScpO1xuXG4vKipcbiAqIFRoZSBQb3NpdGlvbiBjb21wb25lbnQgc2VydmVzIGFzIGEgd2F5IHRvIHR3ZWVuIHRvIHRyYW5zbGF0aW9uIG9mIGEgTm9kZS5cbiAqICBJdCBpcyBhbHNvIHRoZSBiYXNlIGNsYXNzIGZvciB0aGUgb3RoZXIgY29yZSBjb21wb25lbnRzIHRoYXQgaW50ZXJhY3RcbiAqIHdpdGggdGhlIFZlYzMgcHJvcGVydGllcyBvbiB0aGUgTm9kZVxuICpcbiAqIEBjbGFzcyBQb3NpdGlvblxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRoYXQgdGhlIFBvc2l0aW9uIGNvbXBvbmVudCB3aWxsIGJlIGF0dGFjaGVkIHRvXG4gKi9cbmZ1bmN0aW9uIFBvc2l0aW9uKG5vZGUpIHtcbiAgICB0aGlzLl9ub2RlID0gbm9kZTtcbiAgICB0aGlzLl9pZCA9IG5vZGUuYWRkQ29tcG9uZW50KHRoaXMpO1xuICBcbiAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG4gICAgXG4gICAgdmFyIGluaXRpYWxQb3NpdGlvbiA9IG5vZGUuZ2V0UG9zaXRpb24oKTtcblxuICAgIHRoaXMuX3ggPSBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFBvc2l0aW9uWzBdKTtcbiAgICB0aGlzLl95ID0gbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxQb3NpdGlvblsxXSk7XG4gICAgdGhpcy5feiA9IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsUG9zaXRpb25bMl0pO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgUG9zaXRpb24gY29tcG9uZW50XG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gTmFtZSBvZiB0aGUgY29tcG9uZW50XG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiAnUG9zaXRpb24nO1xufTtcblxuLyoqXG4gKiBHZXRzIG9iamVjdCBjb250YWluaW5nIHN0cmluZ2lmaWVkIGNvbnN0cnVjdG9yLCBhbmQgY29ycmVzcG9uZGluZyBkaW1lbnNpb25hbCB2YWx1ZXNcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB0aGUgaW50ZXJuYWwgc3RhdGUgb2YgdGhlIGNvbXBvbmVudFxuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb21wb25lbnQ6IHRoaXMudG9TdHJpbmcoKSxcbiAgICAgICAgeDogdGhpcy5feC5nZXQoKSxcbiAgICAgICAgeTogdGhpcy5feS5nZXQoKSxcbiAgICAgICAgejogdGhpcy5fei5nZXQoKVxuICAgIH07XG59O1xuXG4vKipcbiAqIFNldCB0aGUgdHJhbnNsYXRpb24gb2YgdGhlIE5vZGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIE9iamVjdCAtLSBjb21wb25lbnQ6IHN0cmluZ2lmaWVkIGNvbnN0cnVjdG9yLCB4OiBudW1iZXIsIHk6IG51bWJlciwgejogbnVtYmVyXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gc3RhdHVzIG9mIHRoZSBzZXRcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLnNldFZhbHVlID0gZnVuY3Rpb24gc2V0VmFsdWUoc3RhdGUpIHtcbiAgICBpZiAodGhpcy50b1N0cmluZygpID09PSBzdGF0ZS5jb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5zZXQoc3RhdGUueCwgc3RhdGUueSwgc3RhdGUueik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgWCB0cmFuc2xhdGlvblxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBOb2RlJ3MgdHJhbnNsYXRpb24gYWxvbmcgaXRzIHgtYXhpc1xuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0WCA9IGZ1bmN0aW9uIGdldFgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3guZ2V0KCk7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgWSB0cmFuc2xhdGlvblxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBOb2RlJ3MgdHJhbnNsYXRpb24gYWxvbmcgaXRzIFktYXhpc1xuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0WSA9IGZ1bmN0aW9uIGdldFkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3kuZ2V0KCk7XG59O1xuXG4vKipcbiAqIEdldHRlciBmb3IgeiB0cmFuc2xhdGlvblxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBOb2RlJ3MgdHJhbnNsYXRpb24gYWxvbmcgaXRzIHotYXhpc1xuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUuZ2V0WiA9IGZ1bmN0aW9uIGdldFooKSB7XG4gICAgcmV0dXJuIHRoaXMuX3ouZ2V0KCk7XG59O1xuXG4vKipcbiAqIFdoZXRoZXIgb3Igbm90IHRoZSBQb3NpdGlvbiBpcyBjdXJyZW50bHkgY2hhbmdpbmdcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIFBvc2l0aW9uIGlzIGNoYW5naW5nIHRoZSBOb2RlJ3MgcG9zaXRpb25cbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3guaXNBY3RpdmUoKSB8fCB0aGlzLl95LmlzQWN0aXZlKCkgfHwgdGhpcy5fei5pc0FjdGl2ZSgpO1xufTtcblxuLyoqXG4gKiBEZWNpZGUgd2hldGhlciB0aGUgY29tcG9uZW50IG5lZWRzIHRvIGJlIHVwZGF0ZWQgb24gdGhlIG5leHQgdGljay5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5fY2hlY2tVcGRhdGUgPSBmdW5jdGlvbiBfY2hlY2tVcGRhdGUoKSB7XG4gICAgaWYgKHRoaXMuaXNBY3RpdmUoKSkgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzLl9pZCk7XG4gICAgZWxzZSB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIFdoZW4gdGhlIG5vZGUgdGhpcyBjb21wb25lbnQgaXMgYXR0YWNoZWQgdG8gdXBkYXRlcywgdXBkYXRlIHRoZSB2YWx1ZVxuICogb2YgdGhlIE5vZGUncyBwb3NpdGlvblxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Qb3NpdGlvbi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgICB0aGlzLl9jaGVja1VwZGF0ZSgpO1xuICAgIHRoaXMuX25vZGUuc2V0UG9zaXRpb24odGhpcy5feC5nZXQoKSwgdGhpcy5feS5nZXQoKSwgdGhpcy5fei5nZXQoKSk7XG59O1xuXG5Qb3NpdGlvbi5wcm90b3R5cGUub25VcGRhdGUgPSBQb3NpdGlvbi5wcm90b3R5cGUudXBkYXRlO1xuXG4vKiogXG4gKiBTZXR0ZXIgZm9yIFggcG9zaXRpb25cbiAqXG4gKiBAbWV0aG9kXG4gKiBcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgdXNlZCB0byBzZXQgeCBjb29yZGluYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBvcHRpb25zIGZvciB0aGUgdHJhbnNpdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBzZXR0aW5nIFggXG4gKlxuICogQHJldHVybiB7UG9zaXRpb259IHRoaXNcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLnNldFggPSBmdW5jdGlvbiBzZXRYKHZhbCwgdHJhbnNpdGlvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5feC5zZXQodmFsLCB0cmFuc2l0aW9uLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogXG4gKiBTZXR0ZXIgZm9yIFkgcG9zaXRpb25cbiAqXG4gKiBAbWV0aG9kXG4gKiBcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgdXNlZCB0byBzZXQgeSBjb29yZGluYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBvcHRpb25zIGZvciB0aGUgdHJhbnNpdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBzZXR0aW5nIFkgXG4gKlxuICogQHJldHVybiB7UG9zaXRpb259IHRoaXNcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLnNldFkgPSBmdW5jdGlvbiBzZXRZKHZhbCwgdHJhbnNpdGlvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5feS5zZXQodmFsLCB0cmFuc2l0aW9uLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKiogXG4gKiBTZXR0ZXIgZm9yIFogcG9zaXRpb25cbiAqXG4gKiBAbWV0aG9kXG4gKiBcbiAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgdXNlZCB0byBzZXQgeiBjb29yZGluYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBvcHRpb25zIGZvciB0aGUgdHJhbnNpdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBzZXR0aW5nIFogXG4gKlxuICogQHJldHVybiB7UG9zaXRpb259IHRoaXNcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLnNldFogPSBmdW5jdGlvbiBzZXRaKHZhbCwgdHJhbnNpdGlvbiwgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5fei5zZXQodmFsLCB0cmFuc2l0aW9uLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKiBcbiAqIFNldHRlciBmb3IgWCwgWSwgYW5kIFogcG9zaXRpb25zXG4gKlxuICogQG1ldGhvZFxuICogXG4gKiBAcGFyYW0ge051bWJlcn0geCB1c2VkIHRvIHNldCB4IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IHVzZWQgdG8gc2V0IHkgY29vcmRpbmF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHogdXNlZCB0byBzZXQgeiBjb29yZGluYXRlXG4gKiBAcGFyYW0ge09iamVjdH0gdHJhbnNpdGlvbiBvcHRpb25zIGZvciB0aGUgdHJhbnNpdGlvblxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdG8gZXhlY3V0ZSBhZnRlciBzZXR0aW5nIFggXG4gKlxuICogQHJldHVybiB7UG9zaXRpb259IHRoaXNcbiAqL1xuUG9zaXRpb24ucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIHNldCh4LCB5LCB6LCB0cmFuc2l0aW9uLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgeENhbGxiYWNrO1xuICAgIHZhciB5Q2FsbGJhY2s7XG4gICAgdmFyIHpDYWxsYmFjaztcblxuICAgIGlmICh6ICE9IG51bGwpIHtcbiAgICAgICAgekNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICB5Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgIHhDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIGlmICh4ICE9IG51bGwpIHRoaXMuX3guc2V0KHgsIHRyYW5zaXRpb24sIHhDYWxsYmFjayk7XG4gICAgaWYgKHkgIT0gbnVsbCkgdGhpcy5feS5zZXQoeSwgdHJhbnNpdGlvbiwgeUNhbGxiYWNrKTtcbiAgICBpZiAoeiAhPSBudWxsKSB0aGlzLl96LnNldCh6LCB0cmFuc2l0aW9uLCB6Q2FsbGJhY2spO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN0b3BzIHRyYW5zaXRpb24gb2YgUG9zaXRpb24gY29tcG9uZW50XG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1Bvc2l0aW9ufSB0aGlzXG4gKi9cblBvc2l0aW9uLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICB0aGlzLl94LmhhbHQoKTtcbiAgICB0aGlzLl95LmhhbHQoKTtcbiAgICB0aGlzLl96LmhhbHQoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9zaXRpb247XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICogXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICogXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKiBcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqIFxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgVHJhbnNpdGlvbmFibGUgPSByZXF1aXJlKCcuLi90cmFuc2l0aW9ucy9UcmFuc2l0aW9uYWJsZScpO1xudmFyIFNpemVTeXN0ZW0gPSByZXF1aXJlKCcuLi9jb3JlL1NpemVTeXN0ZW0nKTtcblxuLyoqXG4gKiBTaXplIGNvbXBvbmVudCB1c2VkIGZvciBtYW5hZ2luZyB0aGUgc2l6ZSBvZiB0aGUgTm9kZSBpdCBpcyBhdHRhY2hlZCB0by5cbiAqIFN1cHBvcnRzIGFic29sdXRlIGFuZCByZWxhdGl2ZSAocHJvcG9ydGlvbmFsIGFuZCBkaWZmZXJlbnRpYWwpIHNpemluZy5cbiAqXG4gKiBAY2xhc3MgU2l6ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRoYXQgdGhlIFNpemUgY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvXG4gKi9cbmZ1bmN0aW9uIFNpemUobm9kZSkge1xuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdmFyIGluaXRpYWxQcm9wb3J0aW9uYWxTaXplID0gbm9kZS5nZXRQcm9wb3J0aW9uYWxTaXplKCk7XG4gICAgdmFyIGluaXRpYWxEaWZmZXJlbnRpYWxTaXplID0gbm9kZS5nZXREaWZmZXJlbnRpYWxTaXplKCk7XG4gICAgdmFyIGluaXRpYWxBYnNvbHV0ZVNpemUgPSBub2RlLmdldEFic29sdXRlU2l6ZSgpO1xuXG4gICAgdGhpcy5fcHJvcG9ydGlvbmFsID0ge1xuICAgICAgICB4OiBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFByb3BvcnRpb25hbFNpemVbMF0pLFxuICAgICAgICB5OiBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFByb3BvcnRpb25hbFNpemVbMV0pLFxuICAgICAgICB6OiBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbFByb3BvcnRpb25hbFNpemVbMl0pXG4gICAgfTtcbiAgICB0aGlzLl9kaWZmZXJlbnRpYWwgPSB7XG4gICAgICAgIHg6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsRGlmZmVyZW50aWFsU2l6ZVswXSksXG4gICAgICAgIHk6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsRGlmZmVyZW50aWFsU2l6ZVsxXSksXG4gICAgICAgIHo6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsRGlmZmVyZW50aWFsU2l6ZVsyXSlcbiAgICB9O1xuICAgIHRoaXMuX2Fic29sdXRlID0ge1xuICAgICAgICB4OiBuZXcgVHJhbnNpdGlvbmFibGUoaW5pdGlhbEFic29sdXRlU2l6ZVswXSksXG4gICAgICAgIHk6IG5ldyBUcmFuc2l0aW9uYWJsZShpbml0aWFsQWJzb2x1dGVTaXplWzFdKSxcbiAgICAgICAgejogbmV3IFRyYW5zaXRpb25hYmxlKGluaXRpYWxBYnNvbHV0ZVNpemVbMl0pXG4gICAgfTtcbn1cblxuU2l6ZS5SRUxBVElWRSA9IDA7XG5TaXplLkFCU09MVVRFID0gMTtcblNpemUuUkVOREVSID0gMjtcblNpemUuREVGQVVMVCA9IFNpemUuUkVMQVRJVkU7XG5cbi8qKlxuICogU2V0IHdoaWNoIG1vZGUgZWFjaCBheGlzIG9mIFNpemUgd2lsbCBoYXZlIGl0cyBkaW1lbnNpb25zXG4gKiBjYWxjdWxhdGVkIGJ5LiAgU2l6ZSBjYW4gYmUgY2FsY3VsYXRlZCBieSBhYnNvbHV0ZSBwaXhlbCBkZWZpbml0aW9ucyxcbiAqIHJlbGF0aXZlIHRvIGl0cyBwYXJlbnQsIG9yIGJ5IHRoZSBzaXplIG9mIGl0cyByZW5kZXJhYmxlc1xuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCB0aGUgbW9kZSBvZiBzaXplIGZvciB0aGUgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSBtb2RlIG9mIHNpemUgZm9yIHRoZSBoZWlnaHRcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IHRoZSBtb2RlIG9mIHNpemUgZm9yIHRoZSBkZXB0aFxuICpcbiAqIEByZXR1cm4ge1NpemV9IHRoaXNcbiAqL1xuU2l6ZS5wcm90b3R5cGUuc2V0TW9kZSA9IGZ1bmN0aW9uIHNldE1vZGUoeCwgeSwgeikge1xuICAgIHRoaXMuX25vZGUuc2V0U2l6ZU1vZGUoeCwgeSwgeik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgU2l6ZSBjb21wb25lbnRcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHRoZSBjb21wb25lbnRcbiAqL1xuU2l6ZS5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gJ1NpemUnO1xufTtcblxuLyoqXG4gKiBAdHlwZWRlZiBhYnNvbHV0ZVNpemVWYWx1ZVxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIGN1cnJlbnQgdHlwZSBvZiBzaXppbmcgYmVpbmcgYXBwbGllZCAoJ2Fic29sdXRlJylcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBjb21wb25lbnQgY29tcG9uZW50IG5hbWUgKCdTaXplJylcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSB4XG4gKiBAcHJvcGVydHkge251bWJlcn0geVxuICogQHByb3BlcnR5IHtudW1iZXJ9IHpcbiAqL1xuXG4vKipcbiAqIEB0eXBlZGVmIHJlbGF0aXZlU2l6ZVZhbHVlXG4gKiBAdHlwZSB7T2JqZWN0fVxuICogQHByb3BlcnR5IHtTdHJpbmd9IHR5cGUgY3VycmVudCB0eXBlIG9mIHNpemluZyBiZWluZyBhcHBsaWVkICgncmVsYXRpdmUnKVxuICogQHByb3BlcnR5IHtTdHJpbmd9IGNvbXBvbmVudCBjb21wb25lbnQgbmFtZSAoJ1NpemUnKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRpZmZlcmVudGlhbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IGRpZmZlcmVudGlhbC54XG4gKiBAcHJvcGVydHkge251bWJlcn0gZGlmZmVyZW50aWFsLnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkaWZmZXJlbnRpYWwuelxuICogQHByb3BlcnR5IHtPYmplY3R9IHByb3BvcnRpb25hbFxuICogQHByb3BlcnR5IHtudW1iZXJ9IHByb3BvcnRpb25hbC54XG4gKiBAcHJvcGVydHkge251bWJlcn0gcHJvcG9ydGlvbmFsLnlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwcm9wb3J0aW9uYWwuelxuICovXG5cbi8qKlxuICogUmV0dXJucyBzZXJpYWxpemVkIHN0YXRlIG9mIHRoZSBjb21wb25lbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBjb21wb25lbnRcbiAqL1xuU2l6ZS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBzaXplTW9kZTogU2l6ZVN5c3RlbS5nZXQodGhpcy5fbm9kZS5nZXRMb2NhdGlvbigpKS5nZXRTaXplTW9kZSgpLFxuICAgICAgICBhYnNvbHV0ZToge1xuICAgICAgICAgICAgeDogdGhpcy5fYWJzb2x1dGUueC5nZXQoKSxcbiAgICAgICAgICAgIHk6IHRoaXMuX2Fic29sdXRlLnkuZ2V0KCksXG4gICAgICAgICAgICB6OiB0aGlzLl9hYnNvbHV0ZS56LmdldCgpXG4gICAgICAgIH0sXG4gICAgICAgIGRpZmZlcmVudGlhbDoge1xuICAgICAgICAgICAgeDogdGhpcy5fZGlmZmVyZW50aWFsLnguZ2V0KCksXG4gICAgICAgICAgICB5OiB0aGlzLl9kaWZmZXJlbnRpYWwueS5nZXQoKSxcbiAgICAgICAgICAgIHo6IHRoaXMuX2RpZmZlcmVudGlhbC56LmdldCgpXG4gICAgICAgIH0sXG4gICAgICAgIHByb3BvcnRpb25hbDoge1xuICAgICAgICAgICAgeDogdGhpcy5fcHJvcG9ydGlvbmFsLnguZ2V0KCksXG4gICAgICAgICAgICB5OiB0aGlzLl9wcm9wb3J0aW9uYWwueS5nZXQoKSxcbiAgICAgICAgICAgIHo6IHRoaXMuX3Byb3BvcnRpb25hbC56LmdldCgpXG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHN0YXRlIG9mIGNvbXBvbmVudC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlIHN0YXRlIGVuY29kZWQgaW4gc2FtZSBmb3JtYXQgYXMgc3RhdGUgcmV0cmlldmVkIHRocm91Z2ggYGdldFZhbHVlYFxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBuZXcgc3RhdGUgaGFzIGJlZW4gYXBwbGllZFxuICovXG5TaXplLnByb3RvdHlwZS5zZXRWYWx1ZSA9IGZ1bmN0aW9uIHNldFZhbHVlKHN0YXRlKSB7XG4gICAgaWYgKHRoaXMudG9TdHJpbmcoKSA9PT0gc3RhdGUuY29tcG9uZW50KSB7XG4gICAgICAgIHRoaXMuc2V0TW9kZS5hcHBseSh0aGlzLCBzdGF0ZS5zaXplTW9kZSk7XG4gICAgICAgIGlmIChzdGF0ZS5hYnNvbHV0ZSkge1xuICAgICAgICAgICAgdGhpcy5zZXRBYnNvbHV0ZShzdGF0ZS5hYnNvbHV0ZS54LCBzdGF0ZS5hYnNvbHV0ZS55LCBzdGF0ZS5hYnNvbHV0ZS56KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZGlmZmVyZW50aWFsKSB7XG4gICAgICAgICAgICB0aGlzLnNldEFic29sdXRlKHN0YXRlLmRpZmZlcmVudGlhbC54LCBzdGF0ZS5kaWZmZXJlbnRpYWwueSwgc3RhdGUuZGlmZmVyZW50aWFsLnopO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5wcm9wb3J0aW9uYWwpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QWJzb2x1dGUoc3RhdGUucHJvcG9ydGlvbmFsLngsIHN0YXRlLnByb3BvcnRpb25hbC55LCBzdGF0ZS5wcm9wb3J0aW9uYWwueik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBncmFicyB0aGUgYWN0aXZpdHkgb2YgYSBjZXJ0YWluIHR5cGUgb2Ygc2l6ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB0eXBlIFJlcHJlc2VudGF0aW9uIG9mIGEgdHlwZSBvZiB0aGUgc2l6aW5nIG1vZGVsXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIG5ldyBzdGF0ZSBoYXMgYmVlbiBhcHBsaWVkXG4gKi9cblNpemUucHJvdG90eXBlLl9pc0FjdGl2ZSA9IGZ1bmN0aW9uIF9pc0FjdGl2ZSh0eXBlKSB7XG4gICAgcmV0dXJuIHR5cGUueC5pc0FjdGl2ZSgpIHx8IHR5cGUueS5pc0FjdGl2ZSgpIHx8IHR5cGUuei5pc0FjdGl2ZSgpO1xufTtcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdGhhdCBncmFicyB0aGUgYWN0aXZpdHkgb2YgYSBjZXJ0YWluIHR5cGUgb2Ygc2l6ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgVHlwZSBvZiBzaXplXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIG5ldyBzdGF0ZSBoYXMgYmVlbiBhcHBsaWVkXG4gKi9cblxuU2l6ZS5wcm90b3R5cGUuaXNBY3RpdmUgPSBmdW5jdGlvbiBpc0FjdGl2ZSgpe1xuICAgIHJldHVybiAoXG4gICAgICAgIHRoaXMuX2lzQWN0aXZlKHRoaXMuX2Fic29sdXRlKSB8fFxuICAgICAgICB0aGlzLl9pc0FjdGl2ZSh0aGlzLl9wcm9wb3J0aW9uYWwpIHx8XG4gICAgICAgIHRoaXMuX2lzQWN0aXZlKHRoaXMuX2RpZmZlcmVudGlhbClcbiAgICApO1xufTtcblxuLyoqXG4gKiBXaGVuIHRoZSBub2RlIHRoaXMgY29tcG9uZW50IGlzIGF0dGFjaGVkIHRvIHVwZGF0ZXMsIHVwZGF0ZSB0aGUgdmFsdWVcbiAqIG9mIHRoZSBOb2RlJ3Mgc2l6ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuU2l6ZS5wcm90b3R5cGUub25VcGRhdGUgPSBmdW5jdGlvbiBvblVwZGF0ZSgpIHtcbiAgICB2YXIgYWJzID0gdGhpcy5fYWJzb2x1dGU7XG4gICAgdGhpcy5fbm9kZS5zZXRBYnNvbHV0ZVNpemUoXG4gICAgICAgIGFicy54LmdldCgpLFxuICAgICAgICBhYnMueS5nZXQoKSxcbiAgICAgICAgYWJzLnouZ2V0KClcbiAgICApO1xuICAgIHZhciBwcm9wID0gdGhpcy5fcHJvcG9ydGlvbmFsO1xuICAgIHZhciBkaWZmID0gdGhpcy5fZGlmZmVyZW50aWFsO1xuICAgIHRoaXMuX25vZGUuc2V0UHJvcG9ydGlvbmFsU2l6ZShcbiAgICAgICAgcHJvcC54LmdldCgpLFxuICAgICAgICBwcm9wLnkuZ2V0KCksXG4gICAgICAgIHByb3Auei5nZXQoKVxuICAgICk7XG4gICAgdGhpcy5fbm9kZS5zZXREaWZmZXJlbnRpYWxTaXplKFxuICAgICAgICBkaWZmLnguZ2V0KCksXG4gICAgICAgIGRpZmYueS5nZXQoKSxcbiAgICAgICAgZGlmZi56LmdldCgpXG4gICAgKTtcblxuICAgIGlmICh0aGlzLmlzQWN0aXZlKCkpIHRoaXMuX25vZGUucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sodGhpcy5faWQpO1xuICAgIGVsc2UgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuXG4vKipcbiogQXBwbGllcyBhYnNvbHV0ZSBzaXplLlxuKlxuKiBAbWV0aG9kXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IHVzZWQgdG8gc2V0IGFic29sdXRlIHNpemUgaW4geC1kaXJlY3Rpb24gKHdpZHRoKVxuKiBAcGFyYW0ge051bWJlcn0geSB1c2VkIHRvIHNldCBhYnNvbHV0ZSBzaXplIGluIHktZGlyZWN0aW9uIChoZWlnaHQpXG4qIEBwYXJhbSB7TnVtYmVyfSB6IHVzZWQgdG8gc2V0IGFic29sdXRlIHNpemUgaW4gei1kaXJlY3Rpb24gKGRlcHRoKVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zIGhhdmUgYmVlbiBjb21wbGV0ZWRcbiogQHJldHVybiB7U2l6ZX0gdGhpc1xuKi9cblNpemUucHJvdG90eXBlLnNldEFic29sdXRlID0gZnVuY3Rpb24gc2V0QWJzb2x1dGUoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHhDYWxsYmFjaztcbiAgICB2YXIgeUNhbGxiYWNrO1xuICAgIHZhciB6Q2FsbGJhY2s7XG5cbiAgICBpZiAoeiAhPSBudWxsKSB7XG4gICAgICAgIHpDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgeUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICB4Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgYWJzID0gdGhpcy5fYWJzb2x1dGU7XG4gICAgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICBhYnMueC5zZXQoeCwgb3B0aW9ucywgeENhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICBhYnMueS5zZXQoeSwgb3B0aW9ucywgeUNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHogIT0gbnVsbCkge1xuICAgICAgICBhYnMuei5zZXQoeiwgb3B0aW9ucywgekNhbGxiYWNrKTtcbiAgICB9XG59O1xuXG4vKipcbiogQXBwbGllcyBwcm9wb3J0aW9uYWwgc2l6ZS5cbipcbiogQG1ldGhvZFxuKlxuKiBAcGFyYW0ge051bWJlcn0geCB1c2VkIHRvIHNldCBwcm9wb3J0aW9uYWwgc2l6ZSBpbiB4LWRpcmVjdGlvbiAod2lkdGgpXG4qIEBwYXJhbSB7TnVtYmVyfSB5IHVzZWQgdG8gc2V0IHByb3BvcnRpb25hbCBzaXplIGluIHktZGlyZWN0aW9uIChoZWlnaHQpXG4qIEBwYXJhbSB7TnVtYmVyfSB6IHVzZWQgdG8gc2V0IHByb3BvcnRpb25hbCBzaXplIGluIHotZGlyZWN0aW9uIChkZXB0aClcbiogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyBoYXNoXG4qIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIHRoZVxuKiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9ucyBoYXZlIGJlZW4gY29tcGxldGVkXG4qIEByZXR1cm4ge1NpemV9IHRoaXNcbiovXG5TaXplLnByb3RvdHlwZS5zZXRQcm9wb3J0aW9uYWwgPSBmdW5jdGlvbiBzZXRQcm9wb3J0aW9uYWwoeCwgeSwgeiwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdmFyIHhDYWxsYmFjaztcbiAgICB2YXIgeUNhbGxiYWNrO1xuICAgIHZhciB6Q2FsbGJhY2s7XG5cbiAgICBpZiAoeiAhPSBudWxsKSB7XG4gICAgICAgIHpDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cbiAgICBlbHNlIGlmICh5ICE9IG51bGwpIHtcbiAgICAgICAgeUNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHggIT0gbnVsbCkge1xuICAgICAgICB4Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgcHJvcCA9IHRoaXMuX3Byb3BvcnRpb25hbDtcbiAgICBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgIHByb3AueC5zZXQoeCwgb3B0aW9ucywgeENhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICBwcm9wLnkuc2V0KHksIG9wdGlvbnMsIHlDYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICh6ICE9IG51bGwpIHtcbiAgICAgICAgcHJvcC56LnNldCh6LCBvcHRpb25zLCB6Q2FsbGJhY2spO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuKiBBcHBsaWVzIGRpZmZlcmVudGlhbCBzaXplIHRvIFNpemUgY29tcG9uZW50LlxuKlxuKiBAbWV0aG9kXG4qXG4qIEBwYXJhbSB7TnVtYmVyfSB4IHVzZWQgdG8gc2V0IGRpZmZlcmVudGlhbCBzaXplIGluIHgtZGlyZWN0aW9uICh3aWR0aClcbiogQHBhcmFtIHtOdW1iZXJ9IHkgdXNlZCB0byBzZXQgZGlmZmVyZW50aWFsIHNpemUgaW4geS1kaXJlY3Rpb24gKGhlaWdodClcbiogQHBhcmFtIHtOdW1iZXJ9IHogdXNlZCB0byBzZXQgZGlmZmVyZW50aWFsIHNpemUgaW4gei1kaXJlY3Rpb24gKGRlcHRoKVxuKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBvcHRpb25zIGhhc2hcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgYWZ0ZXIgdGhlXG4qICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zIGhhdmUgYmVlbiBjb21wbGV0ZWRcbiogQHJldHVybiB7U2l6ZX0gdGhpc1xuKi9cblNpemUucHJvdG90eXBlLnNldERpZmZlcmVudGlhbCA9IGZ1bmN0aW9uIHNldERpZmZlcmVudGlhbCh4LCB5LCB6LCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkge1xuICAgICAgICB0aGlzLl9ub2RlLnJlcXVlc3RVcGRhdGUodGhpcy5faWQpO1xuICAgICAgICB0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgeENhbGxiYWNrO1xuICAgIHZhciB5Q2FsbGJhY2s7XG4gICAgdmFyIHpDYWxsYmFjaztcblxuICAgIGlmICh6ICE9IG51bGwpIHtcbiAgICAgICAgekNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuICAgIGVsc2UgaWYgKHkgIT0gbnVsbCkge1xuICAgICAgICB5Q2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG4gICAgZWxzZSBpZiAoeCAhPSBudWxsKSB7XG4gICAgICAgIHhDYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIHZhciBkaWZmID0gdGhpcy5fZGlmZmVyZW50aWFsO1xuICAgIGlmICh4ICE9IG51bGwpIHtcbiAgICAgICAgZGlmZi54LnNldCh4LCBvcHRpb25zLCB4Q2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAoeSAhPSBudWxsKSB7XG4gICAgICAgIGRpZmYueS5zZXQoeSwgb3B0aW9ucywgeUNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHogIT0gbnVsbCkge1xuICAgICAgICBkaWZmLnouc2V0KHosIG9wdGlvbnMsIHpDYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXRyaWV2ZXMgdGhlIGNvbXB1dGVkIHNpemUgYXBwbGllZCB0byB0aGUgdW5kZXJseWluZyBOb2RlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gc2l6ZSB0aHJlZSBkaW1lbnNpb25hbCBjb21wdXRlZCBzaXplXG4gKi9cblNpemUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX25vZGUuZ2V0U2l6ZSgpO1xufTtcblxuLyoqXG4gKiBIYWx0cyBhbGwgY3VycmVudGx5IGFjdGl2ZSBzaXplIHRyYW5zaXRpb25zLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTaXplfSB0aGlzXG4gKi9cblNpemUucHJvdG90eXBlLmhhbHQgPSBmdW5jdGlvbiBoYWx0ICgpIHtcbiAgICB0aGlzLl9wcm9wb3J0aW9uYWwueC5oYWx0KCk7XG4gICAgdGhpcy5fcHJvcG9ydGlvbmFsLnkuaGFsdCgpO1xuICAgIHRoaXMuX3Byb3BvcnRpb25hbC56LmhhbHQoKTtcbiAgICB0aGlzLl9kaWZmZXJlbnRpYWwueC5oYWx0KCk7XG4gICAgdGhpcy5fZGlmZmVyZW50aWFsLnkuaGFsdCgpO1xuICAgIHRoaXMuX2RpZmZlcmVudGlhbC56LmhhbHQoKTtcbiAgICB0aGlzLl9hYnNvbHV0ZS54LmhhbHQoKTtcbiAgICB0aGlzLl9hYnNvbHV0ZS55LmhhbHQoKTtcbiAgICB0aGlzLl9hYnNvbHV0ZS56LmhhbHQoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU2l6ZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGFubmVscyBhcmUgYmVpbmcgdXNlZCBmb3IgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgVUkgVGhyZWFkIHdoZW4gcnVubmluZyBpblxuICogYSBXZWIgV29ya2VyIG9yIHdpdGggdGhlIFVJTWFuYWdlci8gQ29tcG9zaXRvciB3aGVuIHJ1bm5pbmcgaW4gc2luZ2xlXG4gKiB0aHJlYWRlZCBtb2RlIChubyBXZWIgV29ya2VyKS5cbiAqXG4gKiBAY2xhc3MgQ2hhbm5lbFxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIENoYW5uZWwoKSB7XG4gICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyAmJiBzZWxmLndpbmRvdyAhPT0gc2VsZikge1xuICAgICAgICB0aGlzLl9lbnRlcldvcmtlck1vZGUoKTtcbiAgICB9XG59XG5cblxuLyoqXG4gKiBDYWxsZWQgZHVyaW5nIGNvbnN0cnVjdGlvbi4gU3Vic2NyaWJlcyBmb3IgYG1lc3NhZ2VgIGV2ZW50IGFuZCByb3V0ZXMgYWxsXG4gKiBmdXR1cmUgYHNlbmRNZXNzYWdlYCBtZXNzYWdlcyB0byB0aGUgTWFpbiBUaHJlYWQgKFwiVUkgVGhyZWFkXCIpLlxuICpcbiAqIFByaW1hcmlseSB1c2VkIGZvciB0ZXN0aW5nLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5DaGFubmVsLnByb3RvdHlwZS5fZW50ZXJXb3JrZXJNb2RlID0gZnVuY3Rpb24gX2VudGVyV29ya2VyTW9kZSgpIHtcbiAgICB0aGlzLl93b3JrZXJNb2RlID0gdHJ1ZTtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGZ1bmN0aW9uIG9ubWVzc2FnZShldikge1xuICAgICAgICBfdGhpcy5vbk1lc3NhZ2UoZXYuZGF0YSk7XG4gICAgfSk7XG59O1xuXG4vKipcbiAqIE1lYW50IHRvIGJlIG92ZXJyaWRkZW4gYnkgYEZhbW91c2AuXG4gKiBBc3NpZ25lZCBtZXRob2Qgd2lsbCBiZSBpbnZva2VkIGZvciBldmVyeSByZWNlaXZlZCBtZXNzYWdlLlxuICpcbiAqIEB0eXBlIHtGdW5jdGlvbn1cbiAqIEBvdmVycmlkZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNoYW5uZWwucHJvdG90eXBlLm9uTWVzc2FnZSA9IG51bGw7XG5cbi8qKlxuICogU2VuZHMgYSBtZXNzYWdlIHRvIHRoZSBVSU1hbmFnZXIuXG4gKlxuICogQHBhcmFtICB7QW55fSAgICBtZXNzYWdlIEFyYml0cmFyeSBtZXNzYWdlIG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5DaGFubmVsLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uIHNlbmRNZXNzYWdlIChtZXNzYWdlKSB7XG4gICAgaWYgKHRoaXMuX3dvcmtlck1vZGUpIHtcbiAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShtZXNzYWdlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMub25tZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH1cbn07XG5cbi8qKlxuICogTWVhbnQgdG8gYmUgb3ZlcnJpZGVuIGJ5IHRoZSBVSU1hbmFnZXIgd2hlbiBydW5uaW5nIGluIHRoZSBVSSBUaHJlYWQuXG4gKiBVc2VkIGZvciBwcmVzZXJ2aW5nIEFQSSBjb21wYXRpYmlsaXR5IHdpdGggV2ViIFdvcmtlcnMuXG4gKiBXaGVuIHJ1bm5pbmcgaW4gV2ViIFdvcmtlciBtb2RlLCB0aGlzIHByb3BlcnR5IHdvbid0IGJlIG11dGF0ZWQuXG4gKlxuICogQXNzaWduZWQgbWV0aG9kIHdpbGwgYmUgaW52b2tlZCBmb3IgZXZlcnkgbWVzc2FnZSBwb3N0ZWQgYnkgYGZhbW91cy1jb3JlYC5cbiAqXG4gKiBAdHlwZSB7RnVuY3Rpb259XG4gKiBAb3ZlcnJpZGVcbiAqL1xuQ2hhbm5lbC5wcm90b3R5cGUub25tZXNzYWdlID0gbnVsbDtcblxuLyoqXG4gKiBTZW5kcyBhIG1lc3NhZ2UgdG8gdGhlIG1hbmFnZXIgb2YgdGhpcyBjaGFubmVsICh0aGUgYEZhbW91c2Agc2luZ2xldG9uKSBieVxuICogaW52b2tpbmcgYG9uTWVzc2FnZWAuXG4gKiBVc2VkIGZvciBwcmVzZXJ2aW5nIEFQSSBjb21wYXRpYmlsaXR5IHdpdGggV2ViIFdvcmtlcnMuXG4gKlxuICogQHByaXZhdGVcbiAqIEBhbGlhcyBvbk1lc3NhZ2VcbiAqXG4gKiBAcGFyYW0ge0FueX0gbWVzc2FnZSBhIG1lc3NhZ2UgdG8gc2VuZCBvdmVyIHRoZSBjaGFubmVsXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ2hhbm5lbC5wcm90b3R5cGUucG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiBwb3N0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMub25NZXNzYWdlKG1lc3NhZ2UpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaGFubmVsO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2Fzc2VydCcpO1xuXG4vKipcbiAqIEVxdWl2YWxlbnQgb2YgYW4gRW5naW5lIGluIHRoZSBXb3JrZXIgVGhyZWFkLiBVc2VkIHRvIHN5bmNocm9uaXplIGFuZCBtYW5hZ2VcbiAqIHRpbWUgYWNyb3NzIGRpZmZlcmVudCBUaHJlYWRzLlxuICpcbiAqIEBjbGFzcyAgQ2xvY2tcbiAqIEBjb25zdHJ1Y3RvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gQ2xvY2sgKCkge1xuICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgIHRoaXMuX2ZyYW1lID0gMDtcbiAgICB0aGlzLl90aW1lclF1ZXVlID0gW107XG4gICAgdGhpcy5fdXBkYXRpbmdJbmRleCA9IDA7XG5cbiAgICB0aGlzLl9zY2FsZSA9IDE7XG4gICAgdGhpcy5fc2NhbGVkVGltZSA9IHRoaXMuX3RpbWU7XG59XG5cbi8qKlxuICogU2V0cyB0aGUgc2NhbGUgYXQgd2hpY2ggdGhlIGNsb2NrIHRpbWUgaXMgcGFzc2luZy5cbiAqIFVzZWZ1bCBmb3Igc2xvdy1tb3Rpb24gb3IgZmFzdC1mb3J3YXJkIGVmZmVjdHMuXG4gKlxuICogYDFgIG1lYW5zIG5vIHRpbWUgc2NhbGluZyAoXCJyZWFsdGltZVwiKSxcbiAqIGAyYCBtZWFucyB0aGUgY2xvY2sgdGltZSBpcyBwYXNzaW5nIHR3aWNlIGFzIGZhc3QsXG4gKiBgMC41YCBtZWFucyB0aGUgY2xvY2sgdGltZSBpcyBwYXNzaW5nIHR3byB0aW1lcyBzbG93ZXIgdGhhbiB0aGUgXCJhY3R1YWxcIlxuICogdGltZSBhdCB3aGljaCB0aGUgQ2xvY2sgaXMgYmVpbmcgdXBkYXRlZCB2aWEgYC5zdGVwYC5cbiAqXG4gKiBJbml0YWxseSB0aGUgY2xvY2sgdGltZSBpcyBub3QgYmVpbmcgc2NhbGVkIChmYWN0b3IgYDFgKS5cbiAqXG4gKiBAbWV0aG9kICBzZXRTY2FsZVxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSAgICBUaGUgc2NhbGUgYXQgd2hpY2ggdGhlIGNsb2NrIHRpbWUgaXMgcGFzc2luZy5cbiAqXG4gKiBAcmV0dXJuIHtDbG9ja30gdGhpc1xuICovXG5DbG9jay5wcm90b3R5cGUuc2V0U2NhbGUgPSBmdW5jdGlvbiBzZXRTY2FsZSAoc2NhbGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydCh0eXBlb2Ygc2NhbGUgPT09ICdudW1iZXInLCAnc2NhbGUgbmVlZHMgdG8gYmUgYSBudW1iZXInKTtcblxuICAgIHRoaXMuX3NjYWxlID0gc2NhbGU7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBtZXRob2QgIGdldFNjYWxlXG4gKlxuICogQHJldHVybiB7TnVtYmVyfSBzY2FsZSAgICBUaGUgc2NhbGUgYXQgd2hpY2ggdGhlIGNsb2NrIHRpbWUgaXMgcGFzc2luZy5cbiAqL1xuQ2xvY2sucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUgKCkge1xuICAgIHJldHVybiB0aGlzLl9zY2FsZTtcbn07XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgaW50ZXJuYWwgY2xvY2sgdGltZS5cbiAqXG4gKiBAbWV0aG9kICBzdGVwXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lIGhpZ2ggcmVzb2x1dGlvbiB0aW1lc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgYHVwZGF0ZWAgbWV0aG9kIG9uIGFsbCByZWdpc3RlcmVkIG9iamVjdHNcbiAqIEByZXR1cm4ge0Nsb2NrfSAgICAgICB0aGlzXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5zdGVwID0gZnVuY3Rpb24gc3RlcCAodGltZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB0aW1lID09PSAnbnVtYmVyJywgJ3RpbWUgbmVlZHMgdG8gYmUgYSBudW1iZXInKTtcblxuICAgIHRoaXMuX2ZyYW1lKys7XG5cbiAgICB0aGlzLl9zY2FsZWRUaW1lID0gdGhpcy5fc2NhbGVkVGltZSArICh0aW1lIC0gdGhpcy5fdGltZSkqdGhpcy5fc2NhbGU7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuX3RpbWVyUXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVyUXVldWVbaV0odGhpcy5fc2NhbGVkVGltZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbWVyUXVldWUuc3BsaWNlKGksIDEpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpbnRlcm5hbCBjbG9jayB0aW1lLlxuICpcbiAqIEBtZXRob2QgIG5vd1xuICpcbiAqIEByZXR1cm4gIHtOdW1iZXJ9IHRpbWUgaGlnaCByZXNvbHV0aW9uIHRpbWVzdGFtcCB1c2VkIGZvciBpbnZva2luZyB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICBgdXBkYXRlYCBtZXRob2Qgb24gYWxsIHJlZ2lzdGVyZWQgb2JqZWN0c1xuICovXG5DbG9jay5wcm90b3R5cGUubm93ID0gZnVuY3Rpb24gbm93ICgpIHtcbiAgICByZXR1cm4gdGhpcy5fc2NhbGVkVGltZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW50ZXJuYWwgY2xvY2sgdGltZS5cbiAqXG4gKiBAbWV0aG9kICBnZXRUaW1lXG4gKiBAZGVwcmVjYXRlZCBVc2UgI25vdyBpbnN0ZWFkXG4gKlxuICogQHJldHVybiAge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltZXN0YW1wIHVzZWQgZm9yIGludm9raW5nIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgIGB1cGRhdGVgIG1ldGhvZCBvbiBhbGwgcmVnaXN0ZXJlZCBvYmplY3RzXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5nZXRUaW1lID0gQ2xvY2sucHJvdG90eXBlLm5vdztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBudW1iZXIgb2YgZnJhbWVzIGVsYXBzZWQgc28gZmFyLlxuICpcbiAqIEBtZXRob2QgZ2V0RnJhbWVcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGZyYW1lc1xuICovXG5DbG9jay5wcm90b3R5cGUuZ2V0RnJhbWUgPSBmdW5jdGlvbiBnZXRGcmFtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZyYW1lO1xufTtcblxuLyoqXG4gKiBXcmFwcyBhIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYWZ0ZXIgYSBjZXJ0YWluIGFtb3VudCBvZiB0aW1lLlxuICogQWZ0ZXIgYSBzZXQgZHVyYXRpb24gaGFzIHBhc3NlZCwgaXQgZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIGFuZFxuICogcmVtb3ZlcyBpdCBhcyBhIGxpc3RlbmVyIHRvICdwcmVyZW5kZXInLlxuICpcbiAqIEBtZXRob2Qgc2V0VGltZW91dFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIHJ1biBhZnRlciBhIHNwZWNpZmllZCBkdXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IG1pbGxpc2Vjb25kcyBmcm9tIG5vdyB0byBleGVjdXRlIHRoZSBmdW5jdGlvblxuICpcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufSB0aW1lciBmdW5jdGlvbiB1c2VkIGZvciBDbG9jayNjbGVhclRpbWVyXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBkZWxheSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBhc3NlcnQodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nLCAnY2FsbGJhY2sgbmVlZHMgdG8gYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICBhc3NlcnQodHlwZW9mIGRlbGF5ID09PSAnbnVtYmVyJywgJ2RlbGF5IG5lZWRzIHRvIGJlIGEgbnVtYmVyJyk7XG4gICAgfVxuXG4gICAgdmFyIHBhcmFtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIHN0YXJ0ZWRBdCA9IHRoaXMuX3RpbWU7XG4gICAgdmFyIHRpbWVyID0gZnVuY3Rpb24odGltZSkge1xuICAgICAgICBpZiAodGltZSAtIHN0YXJ0ZWRBdCA+PSBkZWxheSkge1xuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkobnVsbCwgcGFyYW1zKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuX3RpbWVyUXVldWUucHVzaCh0aW1lcik7XG4gICAgcmV0dXJuIHRpbWVyO1xufTtcblxuXG4vKipcbiAqIFdyYXBzIGEgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhZnRlciBhIGNlcnRhaW4gYW1vdW50IG9mIHRpbWUuXG4gKiAgQWZ0ZXIgYSBzZXQgZHVyYXRpb24gaGFzIHBhc3NlZCwgaXQgZXhlY3V0ZXMgdGhlIGZ1bmN0aW9uIGFuZFxuICogIHJlc2V0cyB0aGUgZXhlY3V0aW9uIHRpbWUuXG4gKlxuICogQG1ldGhvZCBzZXRJbnRlcnZhbFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIHJ1biBhZnRlciBhIHNwZWNpZmllZCBkdXJhdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IGRlbGF5IGludGVydmFsIHRvIGV4ZWN1dGUgZnVuY3Rpb24gaW4gbWlsbGlzZWNvbmRzXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IHRpbWVyIGZ1bmN0aW9uIHVzZWQgZm9yIENsb2NrI2NsZWFyVGltZXJcbiAqL1xuQ2xvY2sucHJvdG90eXBlLnNldEludGVydmFsID0gZnVuY3Rpb24gc2V0SW50ZXJ2YWwoY2FsbGJhY2ssIGRlbGF5KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicsICdjYWxsYmFjayBuZWVkcyB0byBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgZGVsYXkgPT09ICdudW1iZXInLCAnZGVsYXkgbmVlZHMgdG8gYmUgYSBudW1iZXInKTtcbiAgICB9XG5cbiAgICB2YXIgcGFyYW1zID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgc3RhcnRlZEF0ID0gdGhpcy5fdGltZTtcbiAgICB2YXIgdGltZXIgPSBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgIGlmICh0aW1lIC0gc3RhcnRlZEF0ID49IGRlbGF5KSB7XG4gICAgICAgICAgICBjYWxsYmFjay5hcHBseShudWxsLCBwYXJhbXMpO1xuICAgICAgICAgICAgc3RhcnRlZEF0ID0gdGltZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLl90aW1lclF1ZXVlLnB1c2godGltZXIpO1xuICAgIHJldHVybiB0aW1lcjtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBwcmV2aW91c2x5IHZpYSBgQ2xvY2sjc2V0VGltZW91dGAgb3IgYENsb2NrI3NldEludGVydmFsYFxuICogcmVnaXN0ZXJlZCBjYWxsYmFjayBmdW5jdGlvblxuICpcbiAqIEBtZXRob2QgY2xlYXJUaW1lclxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSB0aW1lciAgcHJldmlvdXNseSBieSBgQ2xvY2sjc2V0VGltZW91dGAgb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYENsb2NrI3NldEludGVydmFsYCByZXR1cm5lZCBjYWxsYmFjayBmdW5jdGlvblxuICogQHJldHVybiB7Q2xvY2t9ICAgICAgICAgICAgICB0aGlzXG4gKi9cbkNsb2NrLnByb3RvdHlwZS5jbGVhclRpbWVyID0gZnVuY3Rpb24gKHRpbWVyKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodHlwZW9mIHRpbWVyID09PSAnZnVuY3Rpb24nLCAndGltZXIgbmVlZHMgdG8gYmUgYSBmdW5jdGlvbicpO1xuXG4gICAgdmFyIGluZGV4ID0gdGhpcy5fdGltZXJRdWV1ZS5pbmRleE9mKHRpbWVyKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3RpbWVyUXVldWUuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENsb2NrO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIHRoZSBjb21tYW5kcyBpbiBvdXIgY29tbWFuZCBxdWV1ZS5cbiAqL1xudmFyIENvbW1hbmRzID0ge1xuICAgIElOSVRfRE9NOiAwLFxuICAgIERPTV9SRU5ERVJfU0laRTogMSxcbiAgICBDSEFOR0VfVFJBTlNGT1JNOiAyLFxuICAgIENIQU5HRV9TSVpFOiAzLFxuICAgIENIQU5HRV9TVFlMRTogNCxcbiAgICBDSEFOR0VfQ09OVEVOVDogNSxcbiAgICBDSEFOR0VfQVRUUklCVVRFOiA2LFxuICAgIEFERF9DTEFTUzogNyxcbiAgICBSRU1PVkVfQ0xBU1M6IDgsXG4gICAgU1VCU0NSSUJFOiA5LFxuICAgIEdMX1NFVF9EUkFXX09QVElPTlM6IDEwLFxuICAgIEdMX0FNQklFTlRfTElHSFQ6IDExLFxuICAgIEdMX0xJR0hUX1BPU0lUSU9OOiAxMixcbiAgICBHTF9MSUdIVF9DT0xPUjogMTMsXG4gICAgTUFURVJJQUxfSU5QVVQ6IDE0LFxuICAgIEdMX1NFVF9HRU9NRVRSWTogMTUsXG4gICAgR0xfVU5JRk9STVM6IDE2LFxuICAgIEdMX0JVRkZFUl9EQVRBOiAxNyxcbiAgICBHTF9DVVRPVVRfU1RBVEU6IDE4LFxuICAgIEdMX01FU0hfVklTSUJJTElUWTogMTksXG4gICAgR0xfUkVNT1ZFX01FU0g6IDIwLFxuICAgIFBJTkhPTEVfUFJPSkVDVElPTjogMjEsXG4gICAgT1JUSE9HUkFQSElDX1BST0pFQ1RJT046IDIyLFxuICAgIENIQU5HRV9WSUVXX1RSQU5TRk9STTogMjMsXG4gICAgV0lUSDogMjQsXG4gICAgRlJBTUU6IDI1LFxuICAgIEVOR0lORTogMjYsXG4gICAgU1RBUlQ6IDI3LFxuICAgIFNUT1A6IDI4LFxuICAgIFRJTUU6IDI5LFxuICAgIFRSSUdHRVI6IDMwLFxuICAgIE5FRURfU0laRV9GT1I6IDMxLFxuICAgIERPTTogMzIsXG4gICAgUkVBRFk6IDMzLFxuICAgIEFMTE9XX0RFRkFVTFQ6IDM0LFxuICAgIFBSRVZFTlRfREVGQVVMVDogMzUsXG4gICAgVU5TVUJTQ1JJQkU6IDM2LFxuICAgIFJFTU9WRV9TQ0VORTogMzcsXG4gICAgcHJldHR5UHJpbnQ6IGZ1bmN0aW9uIChidWZmZXIsIHN0YXJ0LCBjb3VudCkge1xuICAgICAgICB2YXIgY2FsbGJhY2s7XG4gICAgICAgIHN0YXJ0ID0gc3RhcnQgPyBzdGFydCA6IDA7XG4gICAgICAgIHZhciBkYXRhID0ge1xuICAgICAgICAgICAgaTogc3RhcnQsXG4gICAgICAgICAgICByZXN1bHQ6ICcnXG4gICAgICAgIH07XG4gICAgICAgIGZvciAodmFyIGxlbiA9IGNvdW50ID8gY291bnQgKyBzdGFydCA6IGJ1ZmZlci5sZW5ndGggOyBkYXRhLmkgPCBsZW4gOyBkYXRhLmkrKykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBjb21tYW5kUHJpbnRlcnNbYnVmZmVyW2RhdGEuaV1dO1xuICAgICAgICAgICAgaWYgKCFjYWxsYmFjaykgdGhyb3cgbmV3IEVycm9yKCdQQVJTRSBFUlJPUjogbm8gY29tbWFuZCByZWdpc3RlcmVkIGZvcjogJyArIGJ1ZmZlcltkYXRhLmldKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKGJ1ZmZlciwgZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRhdGEucmVzdWx0O1xuICAgIH1cbn07XG5cbnZhciBjb21tYW5kUHJpbnRlcnMgPSBbXTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLklOSVRfRE9NXSA9IGZ1bmN0aW9uIGluaXRfZG9tIChidWZmZXIsIGRhdGEpIHtcbiAgICBkYXRhLnJlc3VsdCArPSBkYXRhLmkgKyAnLiBJTklUX0RPTVxcbiAgICB0YWdOYW1lOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLkRPTV9SRU5ERVJfU0laRV0gPSBmdW5jdGlvbiBkb21fcmVuZGVyX3NpemUgKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIERPTV9SRU5ERVJfU0laRVxcbiAgICBzZWxlY3RvcjogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnXFxuXFxuJztcbn07XG5cbmNvbW1hbmRQcmludGVyc1tDb21tYW5kcy5DSEFOR0VfVFJBTlNGT1JNXSA9IGZ1bmN0aW9uIGNoYW5nZV90cmFuc2Zvcm0gKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIENIQU5HRV9UUkFOU0ZPUk1cXG4gICAgdmFsOiBbJztcbiAgICBmb3IgKHZhciBqID0gMCA7IGogPCAxNiA7IGorKykgZGF0YS5yZXN1bHQgKz0gYnVmZmVyWysrZGF0YS5pXSArIChqIDwgMTUgPyAnLCAnIDogJycpO1xuICAgIGRhdGEucmVzdWx0ICs9ICddXFxuXFxuJztcbn07XG5cbmNvbW1hbmRQcmludGVyc1tDb21tYW5kcy5DSEFOR0VfU0laRV0gPSBmdW5jdGlvbiBjaGFuZ2Vfc2l6ZSAoYnVmZmVyLCBkYXRhKSB7XG4gICAgZGF0YS5yZXN1bHQgKz0gZGF0YS5pICsgJy4gQ0hBTkdFX1NJWkVcXG4gICAgeDogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnLCB5OiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLkNIQU5HRV9TVFlMRV0gPSBmdW5jdGlvbiBDSEFOR0VfU1RZTEUgKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIENIQU5HRV9TVFlMRVxcbiAgICBrZXk6ICcgKyBidWZmZXJbKytkYXRhLmldICsgJywgdmFsdWU6ICcgKyBidWZmZXJbKytkYXRhLmldICsgJ1xcblxcbic7XG59O1xuXG5jb21tYW5kUHJpbnRlcnNbQ29tbWFuZHMuQ0hBTkdFX0NPTlRFTlRdID0gZnVuY3Rpb24gY2hhbmdlX2NvbnRlbnQgKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIENIQU5HRV9DT05URU5UXFxuICAgIGNvbnRlbnQ6ICcgKyBidWZmZXJbKytkYXRhLmldICsgJ1xcblxcbic7XG59O1xuXG5jb21tYW5kUHJpbnRlcnNbQ29tbWFuZHMuQ0hBTkdFX0FUVFJJQlVURV0gPSBmdW5jdGlvbiBjaGFuZ2VfYXR0cmlidXRlIChidWZmZXIsIGRhdGEpIHtcbiAgICBkYXRhLnJlc3VsdCArPSBkYXRhLmkgKyAnLiBDSEFOR0VfQVRUUklCVVRFXFxuICAgIGtleTogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnLCB2YWx1ZTogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnXFxuXFxuJztcbn07XG5cbmNvbW1hbmRQcmludGVyc1tDb21tYW5kcy5BRERfQ0xBU1NdID0gZnVuY3Rpb24gYWRkX2NsYXNzIChidWZmZXIsIGRhdGEpIHtcbiAgICBkYXRhLnJlc3VsdCArPSBkYXRhLmkgKyAnLiBBRERfQ0xBU1NcXG4gICAgY2xhc3NOYW1lOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLlJFTU9WRV9DTEFTU10gPSBmdW5jdGlvbiByZW1vdmVfY2xhc3MgKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIFJFTU9WRV9DTEFTU1xcbiAgICBjbGFzc05hbWU6ICcgKyBidWZmZXJbKytkYXRhLmldICsgJ1xcblxcbic7XG59O1xuXG5jb21tYW5kUHJpbnRlcnNbQ29tbWFuZHMuU1VCU0NSSUJFXSA9IGZ1bmN0aW9uIHN1YnNjcmliZSAoYnVmZmVyLCBkYXRhKSB7XG4gICAgZGF0YS5yZXN1bHQgKz0gZGF0YS5pICsgJy4gU1VCU0NSSUJFXFxuICAgIGV2ZW50OiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLkdMX1NFVF9EUkFXX09QVElPTlNdID0gZnVuY3Rpb24gZ2xfc2V0X2RyYXdfb3B0aW9ucyAoYnVmZmVyLCBkYXRhKSB7XG4gICAgZGF0YS5yZXN1bHQgKz0gZGF0YS5pICsgJy4gR0xfU0VUX0RSQVdfT1BUSU9OU1xcbiAgICBvcHRpb25zOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLkdMX0FNQklFTlRfTElHSFRdID0gZnVuY3Rpb24gZ2xfYW1iaWVudF9saWdodCAoYnVmZmVyLCBkYXRhKSB7XG4gICAgZGF0YS5yZXN1bHQgKz0gZGF0YS5pICsgJy4gR0xfQU1CSUVOVF9MSUdIVFxcbiAgICByOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdnOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdiOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLkdMX0xJR0hUX1BPU0lUSU9OXSA9IGZ1bmN0aW9uIGdsX2xpZ2h0X3Bvc2l0aW9uIChidWZmZXIsIGRhdGEpIHtcbiAgICBkYXRhLnJlc3VsdCArPSBkYXRhLmkgKyAnLiBHTF9MSUdIVF9QT1NJVElPTlxcbiAgICB4OiAnICsgYnVmZmVyWysrZGF0YS5pXSArICd5OiAnICsgYnVmZmVyWysrZGF0YS5pXSArICd6OiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLkdMX0xJR0hUX0NPTE9SXSA9IGZ1bmN0aW9uIGdsX2xpZ2h0X2NvbG9yIChidWZmZXIsIGRhdGEpIHtcbiAgICBkYXRhLnJlc3VsdCArPSBkYXRhLmkgKyAnLiBHTF9MSUdIVF9DT0xPUlxcbiAgICByOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdnOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdiOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLk1BVEVSSUFMX0lOUFVUXSA9IGZ1bmN0aW9uIG1hdGVyaWFsX2lucHV0IChidWZmZXIsIGRhdGEpIHtcbiAgICBkYXRhLnJlc3VsdCArPSBkYXRhLmkgKyAnLiBNQVRFUklBTF9JTlBVVFxcbiAgICBrZXk6ICcgKyBidWZmZXJbKytkYXRhLmldICsgJywgdmFsdWU6ICcgKyBidWZmZXJbKytkYXRhLmldICsgJ1xcblxcbic7XG59O1xuXG5jb21tYW5kUHJpbnRlcnNbQ29tbWFuZHMuR0xfU0VUX0dFT01FVFJZXSA9IGZ1bmN0aW9uIGdsX3NldF9nZW9tZXRyeSAoYnVmZmVyLCBkYXRhKSB7XG4gICAgZGF0YS5yZXN1bHQgKz0gZGF0YS5pICsgJy4gR0xfU0VUX0dFT01FVFJZXFxuICAgeDogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnLCB5OiAnICsgYnVmZmVyWysrZGF0YS5pXSArICcsIHo6ICcgKyBidWZmZXJbKytkYXRhLmldICsgJ1xcblxcbic7XG59O1xuXG5jb21tYW5kUHJpbnRlcnNbQ29tbWFuZHMuR0xfVU5JRk9STVNdID0gZnVuY3Rpb24gZ2xfdW5pZm9ybXMgKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIEdMX1VOSUZPUk1TXFxuICAgIGtleTogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnLCB2YWx1ZTogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnXFxuXFxuJztcbn07XG5cbmNvbW1hbmRQcmludGVyc1tDb21tYW5kcy5HTF9CVUZGRVJfREFUQV0gPSBmdW5jdGlvbiBnbF9idWZmZXJfZGF0YSAoYnVmZmVyLCBkYXRhKSB7XG4gICAgZGF0YS5yZXN1bHQgKz0gZGF0YS5pICsgJy4gR0xfQlVGRkVSX0RBVEFcXG4gICAgZGF0YTogJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDUgOyBpKyspIGRhdGEucmVzdWx0ICs9IGJ1ZmZlclsrK2RhdGEuaV0gKyAnLCAnO1xuICAgIGRhdGEucmVzdWx0ICs9ICdcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLkdMX0NVVE9VVF9TVEFURV0gPSBmdW5jdGlvbiBnbF9jdXRvdXRfc3RhdGUgKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIEdMX0NVVE9VVF9TVEFURVxcbiAgICBzdGF0ZTogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnXFxuXFxuJztcbn07XG5cbmNvbW1hbmRQcmludGVyc1tDb21tYW5kcy5HTF9NRVNIX1ZJU0lCSUxJVFldID0gZnVuY3Rpb24gZ2xfbWVzaF92aXNpYmlsaXR5IChidWZmZXIsIGRhdGEpIHtcbiAgICBkYXRhLnJlc3VsdCArPSBkYXRhLmkgKyAnLiBHTF9NRVNIX1ZJU0lCSUxJVFlcXG4gICAgdmlzaWJpbGl0eTogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnXFxuXFxuJztcbn07XG5cbmNvbW1hbmRQcmludGVyc1tDb21tYW5kcy5HTF9SRU1PVkVfTUVTSF0gPSBmdW5jdGlvbiBnbF9yZW1vdmVfbWVzaCAoYnVmZmVyLCBkYXRhKSB7XG4gICAgZGF0YS5yZXN1bHQgKz0gZGF0YS5pICsgJy4gR0xfUkVNT1ZFX01FU0hcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLlBJTkhPTEVfUFJPSkVDVElPTl0gPSBmdW5jdGlvbiBwaW5ob2xlX3Byb2plY3Rpb24gKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIFBJTkhPTEVfUFJPSkVDVElPTlxcbiAgICBkZXB0aDogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnXFxuXFxuJztcbn07XG5cbmNvbW1hbmRQcmludGVyc1tDb21tYW5kcy5PUlRIT0dSQVBISUNfUFJPSkVDVElPTl0gPSBmdW5jdGlvbiBvcnRob2dyYXBoaWNfcHJvamVjdGlvbiAoYnVmZmVyLCBkYXRhKSB7XG4gICAgZGF0YS5yZXN1bHQgKz0gZGF0YS5pICsgJy4gT1JUSE9HUkFQSElDX1BST0pFQ1RJT05cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLkNIQU5HRV9WSUVXX1RSQU5TRk9STV0gPSBmdW5jdGlvbiBjaGFuZ2Vfdmlld190cmFuc2Zvcm0gKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIENIQU5HRV9WSUVXX1RSQU5TRk9STVxcbiAgIHZhbHVlOiBbJztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDE2IDsgaSsrKSBkYXRhLnJlc3VsdCArPSBidWZmZXJbKytkYXRhLmldICsgKGkgPCAxNSA/ICcsICcgOiAnJyk7XG4gICAgZGF0YS5yZXN1bHQgKz0gJ11cXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLlBSRVZFTlRfREVGQVVMVF0gPSBmdW5jdGlvbiBwcmV2ZW50X2RlZmF1bHQgKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIFBSRVZFTlRfREVGQVVMVFxcbiAgICB2YWx1ZTogJyArIGJ1ZmZlclsrK2RhdGEuaV0gKyAnXFxuXFxuJztcbn07XG5cbmNvbW1hbmRQcmludGVyc1tDb21tYW5kcy5BTExPV19ERUZBVUxUXSA9IGZ1bmN0aW9uIGFsbG93X2RlZmF1bHQgKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIEFMTE9XX0RFRkFVTFRcXG4gICAgdmFsdWU6ICcgKyBidWZmZXJbKytkYXRhLmldICsgJ1xcblxcbic7XG59O1xuXG5jb21tYW5kUHJpbnRlcnNbQ29tbWFuZHMuUkVBRFldID0gZnVuY3Rpb24gcmVhZHkgKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuIFJFQURZXFxuXFxuJztcbn07XG5cbmNvbW1hbmRQcmludGVyc1tDb21tYW5kcy5XSVRIXSA9IGZ1bmN0aW9uIHcgKGJ1ZmZlciwgZGF0YSkge1xuICAgIGRhdGEucmVzdWx0ICs9IGRhdGEuaSArICcuICoqV0lUSCoqXFxuICAgICBwYXRoOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdcXG5cXG4nO1xufTtcblxuY29tbWFuZFByaW50ZXJzW0NvbW1hbmRzLlRJTUVdID0gZnVuY3Rpb24gdGltZSAoYnVmZmVyLCBkYXRhKSB7XG4gICAgZGF0YS5yZXN1bHQgKz0gZGF0YS5pICsgJy4gVElNRVxcbiAgICAgbXM6ICcgKyBidWZmZXJbKytkYXRhLmldICsgJ1xcblxcbic7XG59O1xuXG5jb21tYW5kUHJpbnRlcnNbQ29tbWFuZHMuTkVFRF9TSVpFX0ZPUl0gPSBmdW5jdGlvbiBuZWVkX3NpemVfZm9yIChidWZmZXIsIGRhdGEpIHtcbiAgICBkYXRhLnJlc3VsdCArPSBkYXRhLmkgKyAnLiBORUVEX1NJWkVfRk9SXFxuICAgIHNlbGVjdG9yOiAnICsgYnVmZmVyWysrZGF0YS5pXSArICdcXG5cXG4nO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb21tYW5kcztcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xudmFyIFBhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aCcpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9hc3NlcnQnKTtcblxuLyoqXG4gKiBUaGUgRGlzcGF0Y2ggY2xhc3MgaXMgdXNlZCB0byBwcm9wb2dhdGUgZXZlbnRzIGRvd24gdGhlXG4gKiBzY2VuZSBncmFwaC5cbiAqXG4gKiBAY2xhc3MgRGlzcGF0Y2hcbiAqIEBwYXJhbSB7U2NlbmV9IGNvbnRleHQgVGhlIGNvbnRleHQgb24gd2hpY2ggaXQgb3BlcmF0ZXNcbiAqL1xuZnVuY3Rpb24gRGlzcGF0Y2ggKCkge1xuICAgIHRoaXMuX25vZGVzID0ge307IC8vIGEgY29udGFpbmVyIGZvciBjb25zdGFudCB0aW1lIGxvb2t1cCBvZiBub2Rlc1xufVxuXG4vKipcbiAqIFByb3RlY3RlZCBtZXRob2QgdGhhdCBzZXRzIHRoZSB1cGRhdGVyIGZvciB0aGUgZGlzcGF0Y2guIFRoZSB1cGRhdGVyIHdpbGxcbiAqIGFsbW9zdCBjZXJ0YWlubHkgYmUgdGhlIEZhbW91c0VuZ2luZSBjbGFzcy5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJvdGVjdGVkXG4gKlxuICogQHBhcmFtIHtGYW1vdXNFbmdpbmV9IHVwZGF0ZXIgVGhlIHVwZGF0ZXIgd2hpY2ggd2lsbCBiZSBwYXNzZWQgdGhyb3VnaCB0aGUgc2NlbmUgZ3JhcGhcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5EaXNwYXRjaC5wcm90b3R5cGUuX3NldFVwZGF0ZXIgPSBmdW5jdGlvbiBfc2V0VXBkYXRlciAodXBkYXRlcikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiB1cGRhdGVyID09PSAnb2JqZWN0JywgJ3VwZGF0ZXIgbmVlZHMgdG8gYmUgYW4gb2JqZWN0Jyk7XG5cbiAgICB0aGlzLl91cGRhdGVyID0gdXBkYXRlcjtcblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9ub2RlcykgdGhpcy5fbm9kZXNba2V5XS5fc2V0VXBkYXRlcih1cGRhdGVyKTtcbn07XG5cbi8qKlxuICogQ2FsbHMgdGhlIG9uTW91bnQgbWV0aG9kIGZvciB0aGUgbm9kZSBhdCBhIGdpdmVuIHBhdGggYW5kXG4gKiBwcm9wZXJseSByZWdpc3RlcnMgYWxsIG9mIHRoYXQgbm9kZXMgY2hpbGRyZW4gdG8gdGhlaXIgcHJvcGVyXG4gKiBwYXRocy4gVGhyb3dzIGlmIHRoYXQgcGF0aCBkb2Vzbid0IGhhdmUgYSBub2RlIHJlZ2lzdGVyZWQgYXNcbiAqIGEgcGFyZW50IG9yIGlmIHRoZXJlIGlzIG5vIG5vZGUgcmVnaXN0ZXJlZCBhdCB0aGF0IHBhdGguXG4gKlxuICogQG1ldGhvZCBtb3VudFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGF0IHdoaWNoIHRvIGJlZ2luIG1vdW50aW5nXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdGhlIG5vZGUgdGhhdCB3YXMgbW91bnRlZFxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoZSBub2RlIHRoYXQgaGFzIGJlZW4gbW91bnRlZFxuICovXG5EaXNwYXRjaC5wcm90b3R5cGUubW91bnQgPSBmdW5jdGlvbiBtb3VudCAocGF0aCwgbm9kZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICBhc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuICAgICAgICBhc3NlcnQodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnLCAnbm9kZSBuZWVkcyB0byBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLl9ub2Rlc1twYXRoXSwgJ25vZGUgYWxyZWFkeSByZWdpc3RlcmVkIGF0IHBhdGggJyArIHBhdGgpO1xuICAgIH1cblxuICAgIG5vZGUuX3NldFVwZGF0ZXIodGhpcy5fdXBkYXRlcik7XG4gICAgdGhpcy5fbm9kZXNbcGF0aF0gPSBub2RlO1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aFV0aWxzLnBhcmVudChwYXRoKTtcblxuICAgIC8vIHNjZW5lcyBhcmUgdGhlaXIgb3duIHBhcmVudHNcbiAgICB2YXIgcGFyZW50ID0gcGFyZW50UGF0aCA/IHRoaXMuX25vZGVzW3BhcmVudFBhdGhdIDogbm9kZTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHBhcmVudCwgJ25vIHBhcmVudCByZWdpc3RlcmVkIGF0IHBhdGggJyArIHBhcmVudFBhdGgpO1xuXG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIHZhciBjb21wb25lbnRzID0gbm9kZS5nZXRDb21wb25lbnRzKCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIGlmIChwYXJlbnQuaXNNb3VudGVkKCkpIG5vZGUuX3NldE1vdW50ZWQodHJ1ZSwgcGF0aCk7XG4gICAgaWYgKHBhcmVudC5pc1Nob3duKCkpIG5vZGUuX3NldFNob3duKHRydWUpO1xuXG4gICAgaWYgKHBhcmVudC5pc01vdW50ZWQoKSkge1xuICAgICAgICBub2RlLl9zZXRQYXJlbnQocGFyZW50KTtcbiAgICAgICAgaWYgKG5vZGUub25Nb3VudCkgbm9kZS5vbk1vdW50KHBhdGgpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25Nb3VudClcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uTW91bnQobm9kZSwgaSk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgICAgIGlmIChjaGlsZHJlbltpXSAmJiBjaGlsZHJlbltpXS5tb3VudCkgY2hpbGRyZW5baV0ubW91bnQocGF0aCArICcvJyArIGkpO1xuICAgICAgICAgICAgZWxzZSBpZiAoY2hpbGRyZW5baV0pIHRoaXMubW91bnQocGF0aCArICcvJyArIGksIGNoaWxkcmVuW2ldKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50LmlzU2hvd24oKSkge1xuICAgICAgICBpZiAobm9kZS5vblNob3cpIG5vZGUub25TaG93KCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25TaG93KVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25TaG93KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIENhbGxzIHRoZSBvbkRpc21vdW50IG1ldGhvZCBmb3IgdGhlIG5vZGUgYXQgYSBnaXZlbiBwYXRoXG4gKiBhbmQgZGVyZWdpc3RlcnMgYWxsIG9mIHRoYXQgbm9kZXMgY2hpbGRyZW4uIFRocm93cyBpZiB0aGVyZVxuICogaXMgbm8gbm9kZSByZWdpc3RlcmVkIGF0IHRoYXQgcGF0aC5cbiAqXG4gKiBAbWV0aG9kIGRpc21vdW50XG4gKiBAcmV0dXJuIHt2b2lkfVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGF0IHdoaWNoIHRvIGJlZ2luIGRpc21vdW50aW5nXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGUgbm9kZSB0aGF0IGhhcyBiZWVuIGRpc21vdW50ZWRcbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLmRpc21vdW50ID0gZnVuY3Rpb24gZGlzbW91bnQgKHBhdGgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydCh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycsICdwYXRoIG5lZWRzIHRvIGJlIGEgc3RyaW5nJyk7XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGVzW3BhdGhdO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQobm9kZSwgJ05vIG5vZGUgcmVnaXN0ZXJlZCBhdCBwYXRoICcgKyBwYXRoKTtcblxuICAgIHZhciBjaGlsZHJlbiA9IG5vZGUuZ2V0Q2hpbGRyZW4oKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IG5vZGUuZ2V0Q29tcG9uZW50cygpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBpZiAobm9kZS5pc1Nob3duKCkpIHtcbiAgICAgICAgbm9kZS5fc2V0U2hvd24oZmFsc2UpO1xuICAgICAgICBpZiAobm9kZS5vbkhpZGUpIG5vZGUub25IaWRlKCk7XG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25IaWRlKVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25IaWRlKCk7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUuaXNNb3VudGVkKCkpIHtcbiAgICAgICAgaWYgKG5vZGUub25EaXNtb3VudCkgbm9kZS5vbkRpc21vdW50KHBhdGgpO1xuXG4gICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IGNoaWxkcmVuLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgICAgICBpZiAoY2hpbGRyZW5baV0gJiYgY2hpbGRyZW5baV0uZGlzbW91bnQpIGNoaWxkcmVuW2ldLmRpc21vdW50KCk7XG4gICAgICAgICAgICBlbHNlIGlmIChjaGlsZHJlbltpXSkgdGhpcy5kaXNtb3VudChwYXRoICsgJy8nICsgaSk7XG5cbiAgICAgICAgZm9yIChpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vbkRpc21vdW50KVxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25EaXNtb3VudCgpO1xuXG4gICAgICAgIG5vZGUuX3NldE1vdW50ZWQoZmFsc2UpO1xuICAgICAgICBub2RlLl9zZXRQYXJlbnQobnVsbCk7XG4gICAgfVxuXG4gICAgdGhpcy5fbm9kZXNbcGF0aF0gPSBudWxsO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSB0aGUgbm9kZSByZWdpc3RlcmVkIHRvIHRoZSBnaXZlbiBwYXRoLCBvciBub25lXG4gKiBpZiBubyBub2RlIGV4aXN0cyBhdCB0aGF0IHBhdGguXG4gKlxuICogQG1ldGhvZCBnZXROb2RlXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggYXQgd2hpY2ggdG8gbG9vayB1cCB0aGUgbm9kZVxuICogQHJldHVybiB7Tm9kZSB8IHZvaWR9IG5vZGUgYXQgdGhlIGdpdmVuIHBhdGhcbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLmdldE5vZGUgPSBmdW5jdGlvbiBnZXROb2RlIChwYXRoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuXG4gICAgcmV0dXJuIHRoaXMuX25vZGVzW3BhdGhdO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgdGhlIG9uU2hvdyBtZXRob2QgdG8gdGhlIG5vZGUgcmVnaXN0ZXJlZCBhdCB0aGUgZ2l2ZW4gcGF0aCxcbiAqIGFuZCBzaG93cyB0aGUgZW50aXJlIHN1YnRyZWUgYmVsb3cgdGhhdCBub2RlLiBUaHJvd3MgaWYgbm8gbm9kZVxuICogaXMgcmVnaXN0ZXJlZCB0byB0aGlzIHBhdGguXG4gKlxuICogQG1ldGhvZCBzaG93XG4gKiBAcmV0dXJuIHt2b2lkfVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIG9mIHRoZSBub2RlIHRvIHNob3dcbiAqIEByZXR1cm4ge05vZGV9IFRoZSBub2RlIHRoYXQgaGFzIGJlZW4gc2hvd25cbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiBzaG93IChwYXRoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuXG4gICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1twYXRoXTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KG5vZGUsICdObyBub2RlIHJlZ2lzdGVyZWQgYXQgcGF0aCAnICsgcGF0aCk7XG5cbiAgICBpZiAobm9kZS5vblNob3cpIG5vZGUub25TaG93KCk7XG5cbiAgICB2YXIgY29tcG9uZW50cyA9IG5vZGUuZ2V0Q29tcG9uZW50cygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25TaG93KVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vblNob3coKTtcblxuICAgIHZhciBxdWV1ZSA9IGFsbG9jUXVldWUoKTtcblxuICAgIGFkZENoaWxkcmVuVG9RdWV1ZShub2RlLCBxdWV1ZSk7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgd2hpbGUgKChjaGlsZCA9IGJyZWFkdGhGaXJzdE5leHQocXVldWUpKSlcbiAgICAgICAgdGhpcy5zaG93KGNoaWxkLmdldExvY2F0aW9uKCkpO1xuXG4gICAgbm9kZS5fc2V0U2hvd24odHJ1ZSk7XG5cbiAgICBkZWFsbG9jUXVldWUocXVldWUpO1xuXG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG4vKipcbiAqIElzc3VlcyB0aGUgb25IaWRlIG1ldGhvZCB0byB0aGUgbm9kZSByZWdpc3RlcmVkIGF0IHRoZSBnaXZlbiBwYXRoLFxuICogYW5kIGhpZGVzIHRoZSBlbnRpcmUgc3VidHJlZSBiZWxvdyB0aGF0IG5vZGUuIFRocm93cyBpZiBubyBub2RlXG4gKiBpcyByZWdpc3RlcmVkIHRvIHRoaXMgcGF0aC5cbiAqXG4gKiBAbWV0aG9kIGhpZGVcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggdGhlIHBhdGggb2YgdGhlIG5vZGUgdG8gaGlkZVxuICogQHJldHVybiB7Tm9kZX0gVGhlIG5vZGUgdGhhdCBoYXMgYmVlbiBoaWRkZW5cbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlIChwYXRoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuXG4gICAgdmFyIG5vZGUgPSB0aGlzLl9ub2Rlc1twYXRoXTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KG5vZGUsICdObyBub2RlIHJlZ2lzdGVyZWQgYXQgcGF0aCAnICsgcGF0aCk7XG5cbiAgICBpZiAobm9kZS5vbkhpZGUpIG5vZGUub25IaWRlKCk7XG5cbiAgICB2YXIgY29tcG9uZW50cyA9IG5vZGUuZ2V0Q29tcG9uZW50cygpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25IaWRlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbkhpZGUoKTtcblxuICAgIHZhciBxdWV1ZSA9IGFsbG9jUXVldWUoKTtcblxuICAgIGFkZENoaWxkcmVuVG9RdWV1ZShub2RlLCBxdWV1ZSk7XG4gICAgdmFyIGNoaWxkO1xuXG4gICAgd2hpbGUgKChjaGlsZCA9IGJyZWFkdGhGaXJzdE5leHQocXVldWUpKSlcbiAgICAgICAgdGhpcy5oaWRlKGNoaWxkLmdldExvY2F0aW9uKCkpO1xuXG4gICAgbm9kZS5fc2V0U2hvd24oZmFsc2UpO1xuICAgIGRlYWxsb2NRdWV1ZShxdWV1ZSk7XG5cbiAgICByZXR1cm4gbm9kZTtcbn07XG5cbi8qKlxuICogbG9va3VwTm9kZSB0YWtlcyBhIHBhdGggYW5kIHJldHVybnMgdGhlIG5vZGUgYXQgdGhlIGxvY2F0aW9uIHNwZWNpZmllZFxuICogYnkgdGhlIHBhdGgsIGlmIG9uZSBleGlzdHMuIElmIG5vdCwgaXQgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGxvY2F0aW9uIFRoZSBsb2NhdGlvbiBvZiB0aGUgbm9kZSBzcGVjaWZpZWQgYnkgaXRzIHBhdGhcbiAqXG4gKiBAcmV0dXJuIHtOb2RlIHwgdW5kZWZpbmVkfSBUaGUgbm9kZSBhdCB0aGUgcmVxdWVzdGVkIHBhdGhcbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLmxvb2t1cE5vZGUgPSBmdW5jdGlvbiBsb29rdXBOb2RlIChsb2NhdGlvbikge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycsICdsb2NhdGlvbiBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuXG4gICAgdmFyIHBhdGggPSBhbGxvY1F1ZXVlKCk7XG5cbiAgICBfc3BsaXRUbyhsb2NhdGlvbiwgcGF0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gcGF0aC5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBwYXRoW2ldID0gdGhpcy5fbm9kZXNbcGF0aFtpXV07XG5cbiAgICBwYXRoLmxlbmd0aCA9IDA7XG4gICAgZGVhbGxvY1F1ZXVlKHBhdGgpO1xuXG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbn07XG5cbi8qKlxuICogZGlzcGF0Y2ggdGFrZXMgYW4gZXZlbnQgbmFtZSBhbmQgYSBwYXlsb2FkIGFuZCBkaXNwYXRjaGVzIGl0IHRvIHRoZVxuICogZW50aXJlIHNjZW5lIGdyYXBoIGJlbG93IHRoZSBub2RlIHRoYXQgdGhlIGRpc3BhdGNoZXIgaXMgb24uIFRoZSBub2Rlc1xuICogcmVjZWl2ZSB0aGUgZXZlbnRzIGluIGEgYnJlYWR0aCBmaXJzdCB0cmF2ZXJzYWwsIG1lYW5pbmcgdGhhdCBwYXJlbnRzXG4gKiBoYXZlIHRoZSBvcHBvcnR1bml0eSB0byByZWFjdCB0byB0aGUgZXZlbnQgYmVmb3JlIGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHBhdGggb2YgdGhlIG5vZGUgdG8gc2VuZCB0aGUgZXZlbnQgdG9cbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCBuYW1lIG9mIHRoZSBldmVudFxuICogQHBhcmFtIHtBbnl9IHBheWxvYWQgZGF0YSBhc3NvY2lhdGVkIHdpdGggdGhlIGV2ZW50XG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLmRpc3BhdGNoID0gZnVuY3Rpb24gZGlzcGF0Y2ggKHBhdGgsIGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycsICdwYXRoIG5lZWRzIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnLCAnZXZlbnQgbmVlZHMgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JywgJ3BheWxvYWQgbmVlZHMgdG8gYmUgYSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGVzW3BhdGhdO1xuXG4gICAgaWYgKCFub2RlKSByZXR1cm47XG5cbiAgICBwYXlsb2FkLm5vZGUgPSBub2RlO1xuXG4gICAgdmFyIHF1ZXVlID0gYWxsb2NRdWV1ZSgpO1xuICAgIHF1ZXVlLnB1c2gobm9kZSk7XG5cbiAgICB2YXIgY2hpbGQ7XG4gICAgdmFyIGNvbXBvbmVudHM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcblxuICAgIHdoaWxlICgoY2hpbGQgPSBicmVhZHRoRmlyc3ROZXh0KHF1ZXVlKSkpIHtcbiAgICAgICAgaWYgKGNoaWxkICYmIGNoaWxkLm9uUmVjZWl2ZSlcbiAgICAgICAgICAgIGNoaWxkLm9uUmVjZWl2ZShldmVudCwgcGF5bG9hZCk7XG5cbiAgICAgICAgY29tcG9uZW50cyA9IGNoaWxkLmdldENvbXBvbmVudHMoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uUmVjZWl2ZSlcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uUmVjZWl2ZShldmVudCwgcGF5bG9hZCk7XG4gICAgfVxuXG4gICAgZGVhbGxvY1F1ZXVlKHF1ZXVlKTtcbn07XG5cbi8qKlxuICogZGlzcGF0Y2hVSWV2ZW50IHRha2VzIGEgcGF0aCwgYW4gZXZlbnQgbmFtZSwgYW5kIGEgcGF5bG9hZCBhbmQgZGlzcGF0Y2hlcyB0aGVtIGluXG4gKiBhIG1hbm5lciBhbm9sb2dvdXMgdG8gRE9NIGJ1YmJsaW5nLiBJdCBmaXJzdCB0cmF2ZXJzZXMgZG93biB0byB0aGUgbm9kZSBzcGVjaWZpZWQgYXRcbiAqIHRoZSBwYXRoLiBUaGF0IG5vZGUgcmVjZWl2ZXMgdGhlIGV2ZW50IGZpcnN0LCBhbmQgdGhlbiBldmVyeSBhbmNlc3RvciByZWNlaXZlcyB0aGUgZXZlbnRcbiAqIHVudGlsIHRoZSBjb250ZXh0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoIG9mIHRoZSBub2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnQgdGhlIGV2ZW50IG5hbWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIHRoZSBwYXlsb2FkXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRGlzcGF0Y2gucHJvdG90eXBlLmRpc3BhdGNoVUlFdmVudCA9IGZ1bmN0aW9uIGRpc3BhdGNoVUlFdmVudCAocGF0aCwgZXZlbnQsIHBheWxvYWQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJywgJ3BhdGggbmVlZHMgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycsICdldmVudCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuICAgICAgICBhc3NlcnQodHlwZW9mIHBheWxvYWQgPT09ICdvYmplY3QnLCAncGF5bG9hZCBuZWVkcyB0byBiZSBhIG9iamVjdCcpO1xuICAgIH1cblxuICAgIHZhciBub2RlID0gdGhpcy5fbm9kZXNbcGF0aF07XG4gICAgRXZlbnQuY2FsbChwYXlsb2FkKTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KG5vZGUsICdObyBub2RlIHJlZ2lzdGVyZWQgYXQgcGF0aCAnICsgcGF0aCk7XG5cbiAgICB2YXIgcGFyZW50O1xuICAgIHZhciBjb21wb25lbnRzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG5cbiAgICBwYXlsb2FkLm5vZGUgPSBub2RlO1xuXG4gICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgaWYgKG5vZGUub25SZWNlaXZlKSBub2RlLm9uUmVjZWl2ZShldmVudCwgcGF5bG9hZCk7XG4gICAgICAgIGNvbXBvbmVudHMgPSBub2RlLmdldENvbXBvbmVudHMoKTtcblxuICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uUmVjZWl2ZSlcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uUmVjZWl2ZShldmVudCwgcGF5bG9hZCk7XG5cbiAgICAgICAgaWYgKHBheWxvYWQucHJvcGFnYXRpb25TdG9wcGVkKSBicmVhaztcbiAgICAgICAgcGFyZW50ID0gbm9kZS5nZXRQYXJlbnQoKTtcbiAgICAgICAgaWYgKHBhcmVudCA9PT0gbm9kZSkgYnJlYWs7XG4gICAgICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgfVxufTtcblxudmFyIHF1ZXVlcyA9IFtdO1xuXG4vKipcbiAqIEhlbHBlciBtZXRob2QgdXNlZCBmb3IgYWxsb2NhdGluZyBhIG5ldyBxdWV1ZSBvciByZXVzaW5nIGEgcHJldmlvdXNseSBmcmVlZFxuICogb25lIGlmIHBvc3NpYmxlLlxuICpcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGFsbG9jYXRlZCBxdWV1ZS5cbiAqL1xuZnVuY3Rpb24gYWxsb2NRdWV1ZSAoKSB7XG4gICAgcmV0dXJuIHF1ZXVlcy5wb3AoKSB8fCBbXTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgbWV0aG9kIHVzZWQgZm9yIGZyZWVpbmcgYSBwcmV2aW91c2x5IGFsbG9jYXRlZCBxdWV1ZS5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge0FycmF5fSBxdWV1ZSAgICB0aGUgcXVldWUgdG8gYmUgcmVsYXNlZCB0byB0aGUgcG9vbC5cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gZGVhbGxvY1F1ZXVlKHF1ZXVlKSB7XG4gICAgcXVldWVzLnB1c2gocXVldWUpO1xufVxuXG4vKipcbiAqIF9zcGxpdFRvIGlzIGEgcHJpdmF0ZSBtZXRob2Qgd2hpY2ggdGFrZXMgYSBwYXRoIGFuZCBzcGxpdHMgaXQgYXQgZXZlcnkgJy8nXG4gKiBwdXNoaW5nIHRoZSByZXN1bHQgaW50byB0aGUgc3VwcGxpZWQgYXJyYXkuIFRoaXMgaXMgYSBkZXN0cnVjdGl2ZSBjaGFuZ2UuXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgdGhlIHNwZWNpZmllZCBwYXRoXG4gKiBAcGFyYW0ge0FycmF5fSB0YXJnZXQgdGhlIGFycmF5IHRvIHdoaWNoIHRoZSByZXN1bHQgc2hvdWxkIGJlIHdyaXR0ZW5cbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gdGhlIHRhcmdldCBhZnRlciBoYXZpbmcgYmVlbiB3cml0dGVuIHRvXG4gKi9cbmZ1bmN0aW9uIF9zcGxpdFRvIChzdHJpbmcsIHRhcmdldCkge1xuICAgIHRhcmdldC5sZW5ndGggPSAwOyAvLyBjbGVhcnMgdGhlIGFycmF5IGZpcnN0LlxuICAgIHZhciBsYXN0ID0gMDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aDtcblxuICAgIGZvciAoaSA9IDAgOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIGlmIChzdHJpbmdbaV0gPT09ICcvJykge1xuICAgICAgICAgICAgdGFyZ2V0LnB1c2goc3RyaW5nLnN1YnN0cmluZyhsYXN0LCBpKSk7XG4gICAgICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaSAtIGxhc3QgPiAwKSB0YXJnZXQucHVzaChzdHJpbmcuc3Vic3RyaW5nKGxhc3QsIGkpKTtcblxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogRW5xdWUgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSB3aXRoaW4gdGhlIGRpc3BhdGNoZXIuIERvZXMgbm90IGNsZWFyXG4gKiB0aGUgZGlzcGF0Y2hlcnMgcXVldWUgZmlyc3QuXG4gKlxuICogQG1ldGhvZCBhZGRDaGlsZHJlblRvUXVldWVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgZnJvbSB3aGljaCB0byBhZGQgY2hpbGRyZW4gdG8gdGhlIHF1ZXVlXG4gKiBAcGFyYW0ge0FycmF5fSBxdWV1ZSB0aGUgcXVldWUgdXNlZCBmb3IgcmV0cmlldmluZyB0aGUgbmV3IGNoaWxkIGZyb21cbiAqXG4gKiBAcmV0dXJuIHt2b2lkfVxuICovXG5mdW5jdGlvbiBhZGRDaGlsZHJlblRvUXVldWUgKG5vZGUsIHF1ZXVlKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gbm9kZS5nZXRDaGlsZHJlbigpO1xuICAgIHZhciBjaGlsZDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2hpbGRyZW4ubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuICAgICAgICBpZiAoY2hpbGQpIHF1ZXVlLnB1c2goY2hpbGQpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBuZXh0IG5vZGUgaW4gdGhlIHF1ZXVlLCBidXQgYWxzbyBhZGRzIGl0cyBjaGlsZHJlbiB0b1xuICogdGhlIGVuZCBvZiB0aGUgcXVldWUuIENvbnRpbnVhbGx5IGNhbGxpbmcgdGhpcyBtZXRob2Qgd2lsbCByZXN1bHRcbiAqIGluIGEgYnJlYWR0aCBmaXJzdCB0cmF2ZXJzYWwgb2YgdGhlIHJlbmRlciB0cmVlLlxuICpcbiAqIEBtZXRob2QgYnJlYWR0aEZpcnN0TmV4dFxuICogQHBhcmFtIHtBcnJheX0gcXVldWUgdGhlIHF1ZXVlIHVzZWQgZm9yIHJldHJpZXZpbmcgdGhlIG5ldyBjaGlsZCBmcm9tXG4gKiBAcmV0dXJuIHtOb2RlIHwgdW5kZWZpbmVkfSB0aGUgbmV4dCBub2RlIGluIHRoZSB0cmF2ZXJzYWwgaWYgb25lIGV4aXN0c1xuICovXG5mdW5jdGlvbiBicmVhZHRoRmlyc3ROZXh0IChxdWV1ZSkge1xuICAgIHZhciBjaGlsZCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgaWYgKCFjaGlsZCkgcmV0dXJuIHZvaWQgMDtcbiAgICBhZGRDaGlsZHJlblRvUXVldWUoY2hpbGQsIHF1ZXVlKTtcbiAgICByZXR1cm4gY2hpbGQ7XG59XG5cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgRGlzcGF0Y2goKTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKiBcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqIFxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICogXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogVGhlIEV2ZW50IGNsYXNzIGFkZHMgdGhlIHN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbmFsaXR5XG4gKiB0byB0aGUgVUlFdmVudHMgd2l0aGluIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAY29uc3RydWN0b3IgRXZlbnRcbiAqL1xuZnVuY3Rpb24gRXZlbnQgKCkge1xuICAgIHRoaXMucHJvcGFnYXRpb25TdG9wcGVkID0gZmFsc2U7XG4gICAgdGhpcy5zdG9wUHJvcGFnYXRpb24gPSBzdG9wUHJvcGFnYXRpb247XG59XG5cbi8qKlxuICogc3RvcFByb3BhZ2F0aW9uIGVuZHMgdGhlIGJ1YmJsaW5nIG9mIHRoZSBldmVudCBpbiB0aGVcbiAqIHNjZW5lIGdyYXBoLlxuICpcbiAqIEBtZXRob2Qgc3RvcFByb3BhZ2F0aW9uXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uICgpIHtcbiAgICB0aGlzLnByb3BhZ2F0aW9uU3RvcHBlZCA9IHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnQ7XG5cbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENsb2NrID0gcmVxdWlyZSgnLi9DbG9jaycpO1xudmFyIFNjZW5lID0gcmVxdWlyZSgnLi9TY2VuZScpO1xudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbnZhciBDaGFubmVsID0gcmVxdWlyZSgnLi9DaGFubmVsJyk7XG52YXIgRGlzcGF0Y2ggPSByZXF1aXJlKCcuL0Rpc3BhdGNoJyk7XG52YXIgVUlNYW5hZ2VyID0gcmVxdWlyZSgnLi4vcmVuZGVyZXJzL1VJTWFuYWdlcicpO1xudmFyIENvbXBvc2l0b3IgPSByZXF1aXJlKCcuLi9yZW5kZXJlcnMvQ29tcG9zaXRvcicpO1xudmFyIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AgPSByZXF1aXJlKCcuLi9yZW5kZXItbG9vcHMvUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcCcpO1xudmFyIFRyYW5zZm9ybVN5c3RlbSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtU3lzdGVtJyk7XG52YXIgT3BhY2l0eVN5c3RlbSA9IHJlcXVpcmUoJy4vT3BhY2l0eVN5c3RlbScpO1xudmFyIFNpemVTeXN0ZW0gPSByZXF1aXJlKCcuL1NpemVTeXN0ZW0nKTtcbnZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcblxudmFyIEVOR0lORV9TVEFSVCA9IFtDb21tYW5kcy5FTkdJTkUsIENvbW1hbmRzLlNUQVJUXTtcbnZhciBFTkdJTkVfU1RPUCA9IFtDb21tYW5kcy5FTkdJTkUsIENvbW1hbmRzLlNUT1BdO1xudmFyIFRJTUVfVVBEQVRFID0gW0NvbW1hbmRzLlRJTUUsIG51bGxdO1xuXG4vKipcbiAqIEZhbW91cyBoYXMgdHdvIHJlc3BvbnNpYmlsaXRpZXMsIG9uZSB0byBhY3QgYXMgdGhlIGhpZ2hlc3QgbGV2ZWxcbiAqIHVwZGF0ZXIgYW5kIGFub3RoZXIgdG8gc2VuZCBtZXNzYWdlcyBvdmVyIHRvIHRoZSByZW5kZXJlcnMuIEl0IGlzXG4gKiBhIHNpbmdsZXRvbi5cbiAqXG4gKiBAY2xhc3MgRmFtb3VzRW5naW5lXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gRmFtb3VzRW5naW5lKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICBEaXNwYXRjaC5fc2V0VXBkYXRlcih0aGlzKTtcblxuICAgIHRoaXMuX3VwZGF0ZVF1ZXVlID0gW107IC8vIFRoZSB1cGRhdGVRdWV1ZSBpcyBhIHBsYWNlIHdoZXJlIG5vZGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2FuIHBsYWNlIHRoZW1zZWx2ZXMgaW4gb3JkZXIgdG8gYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1cGRhdGVkIG9uIHRoZSBmcmFtZS5cblxuICAgIHRoaXMuX25leHRVcGRhdGVRdWV1ZSA9IFtdOyAvLyB0aGUgbmV4dFVwZGF0ZVF1ZXVlIGlzIHVzZWQgdG8gcXVldWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlcyBmb3IgdGhlIG5leHQgdGljay5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyBwcmV2ZW50cyBpbmZpbml0ZSBsb29wcyB3aGVyZSBkdXJpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW4gdXBkYXRlIGEgbm9kZSBjb250aW51b3VzbHkgcHV0cyBpdHNlbGZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFjayBpbiB0aGUgdXBkYXRlIHF1ZXVlLlxuXG4gICAgdGhpcy5fc2NlbmVzID0ge307IC8vIGEgaGFzaCBvZiBhbGwgb2YgdGhlIHNjZW5lcydzIHRoYXQgdGhlIEZhbW91c0VuZ2luZVxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzIHJlc3BvbnNpYmxlIGZvci5cblxuICAgIHRoaXMuX21lc3NhZ2VzID0gVElNRV9VUERBVEU7ICAgLy8gYSBxdWV1ZSBvZiBhbGwgb2YgdGhlIGRyYXcgY29tbWFuZHMgdG9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNlbmQgdG8gdGhlIHRoZSByZW5kZXJlcnMgdGhpcyBmcmFtZS5cblxuICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7IC8vIHdoZW4gdGhlIGZhbW91cyBpcyB1cGRhdGluZyB0aGlzIGlzIHRydWUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWxsIHJlcXVlc3RzIGZvciB1cGRhdGVzIHdpbGwgZ2V0IHB1dCBpbiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZXh0VXBkYXRlUXVldWVcblxuICAgIHRoaXMuX2Nsb2NrID0gbmV3IENsb2NrKCk7IC8vIGEgY2xvY2sgdG8ga2VlcCB0cmFjayBvZiB0aW1lIGZvciB0aGUgc2NlbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBncmFwaC5cblxuXG4gICAgdGhpcy5fY2hhbm5lbCA9IG5ldyBDaGFubmVsKCk7XG4gICAgdGhpcy5fY2hhbm5lbC5vbk1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBfdGhpcy5oYW5kbGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgIH07XG59XG5cblxuLyoqXG4gKiBBbiBpbml0IHNjcmlwdCB0aGF0IGluaXRpYWxpemVzIHRoZSBGYW1vdXNFbmdpbmUgd2l0aCBvcHRpb25zXG4gKiBvciBkZWZhdWx0IHBhcmFtZXRlcnMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIGEgc2V0IG9mIG9wdGlvbnMgY29udGFpbmluZyBhIGNvbXBvc2l0b3IgYW5kIGEgcmVuZGVyIGxvb3BcbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXNFbmdpbmV9IHRoaXNcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gaW5pdChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdGYW1vdXNFbmdpbmUjaW5pdCBuZWVkcyB0byBoYXZlIGFjY2VzcyB0byB0aGUgZ2xvYmFsIHdpbmRvdyBvYmplY3QuICcgK1xuICAgICAgICAgICAgJ0luc3RhbnRpYXRlIENvbXBvc2l0b3IgYW5kIFVJTWFuYWdlciBtYW51YWxseSBpbiB0aGUgVUkgdGhyZWFkLidcbiAgICAgICAgKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NpdG9yID0gb3B0aW9ucyAmJiBvcHRpb25zLmNvbXBvc2l0b3IgfHwgbmV3IENvbXBvc2l0b3IoKTtcbiAgICB0aGlzLnJlbmRlckxvb3AgPSBvcHRpb25zICYmIG9wdGlvbnMucmVuZGVyTG9vcCB8fCBuZXcgUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcCgpO1xuICAgIHRoaXMudWlNYW5hZ2VyID0gbmV3IFVJTWFuYWdlcih0aGlzLmdldENoYW5uZWwoKSwgdGhpcy5jb21wb3NpdG9yLCB0aGlzLnJlbmRlckxvb3ApO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBjaGFubmVsIHRoYXQgdGhlIGVuZ2luZSB3aWxsIHVzZSB0byBjb21tdW5pY2F0ZSB0b1xuICogdGhlIHJlbmRlcmVycy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtDaGFubmVsfSBjaGFubmVsICAgICBUaGUgY2hhbm5lbCB0byBiZSB1c2VkIGZvciBjb21tdW5pY2F0aW5nIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGBVSU1hbmFnZXJgLyBgQ29tcG9zaXRvcmAuXG4gKlxuICogQHJldHVybiB7RmFtb3VzRW5naW5lfSB0aGlzXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuc2V0Q2hhbm5lbCA9IGZ1bmN0aW9uIHNldENoYW5uZWwoY2hhbm5lbCkge1xuICAgIHRoaXMuX2NoYW5uZWwgPSBjaGFubmVsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjaGFubmVsIHRoYXQgdGhlIGVuZ2luZSBpcyBjdXJyZW50bHkgdXNpbmdcbiAqIHRvIGNvbW11bmljYXRlIHdpdGggdGhlIHJlbmRlcmVycy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7Q2hhbm5lbH0gY2hhbm5lbCAgICBUaGUgY2hhbm5lbCB0byBiZSB1c2VkIGZvciBjb21tdW5pY2F0aW5nIHdpdGhcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGBVSU1hbmFnZXJgLyBgQ29tcG9zaXRvcmAuXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuZ2V0Q2hhbm5lbCA9IGZ1bmN0aW9uIGdldENoYW5uZWwgKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGFubmVsO1xufTtcblxuLyoqXG4gKiBfdXBkYXRlIGlzIHRoZSBib2R5IG9mIHRoZSB1cGRhdGUgbG9vcC4gVGhlIGZyYW1lIGNvbnNpc3RzIG9mXG4gKiBwdWxsaW5nIGluIGFwcGVuZGluZyB0aGUgbmV4dFVwZGF0ZVF1ZXVlIHRvIHRoZSBjdXJyZW50VXBkYXRlIHF1ZXVlXG4gKiB0aGVuIG1vdmluZyB0aHJvdWdoIHRoZSB1cGRhdGVRdWV1ZSBhbmQgY2FsbGluZyBvblVwZGF0ZSB3aXRoIHRoZSBjdXJyZW50XG4gKiB0aW1lIG9uIGFsbCBub2Rlcy4gV2hpbGUgX3VwZGF0ZSBpcyBjYWxsZWQgX2luVXBkYXRlIGlzIHNldCB0byB0cnVlIGFuZFxuICogYWxsIHJlcXVlc3RzIHRvIGJlIHBsYWNlZCBpbiB0aGUgdXBkYXRlIHF1ZXVlIHdpbGwgYmUgZm9yd2FyZGVkIHRvIHRoZVxuICogbmV4dFVwZGF0ZVF1ZXVlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlICgpIHtcbiAgICB0aGlzLl9pblVwZGF0ZSA9IHRydWU7XG4gICAgdmFyIHRpbWUgPSB0aGlzLl9jbG9jay5ub3coKTtcbiAgICB2YXIgbmV4dFF1ZXVlID0gdGhpcy5fbmV4dFVwZGF0ZVF1ZXVlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3VwZGF0ZVF1ZXVlO1xuICAgIHZhciBpdGVtO1xuXG4gICAgdGhpcy5fbWVzc2FnZXNbMV0gPSB0aW1lO1xuXG4gICAgU2l6ZVN5c3RlbS51cGRhdGUoKTtcbiAgICBUcmFuc2Zvcm1TeXN0ZW0udXBkYXRlKCk7XG4gICAgT3BhY2l0eVN5c3RlbS51cGRhdGUoKTtcblxuICAgIHdoaWxlIChuZXh0UXVldWUubGVuZ3RoKSBxdWV1ZS51bnNoaWZ0KG5leHRRdWV1ZS5wb3AoKSk7XG5cbiAgICB3aGlsZSAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGl0ZW0gPSBxdWV1ZS5zaGlmdCgpO1xuICAgICAgICBpZiAoaXRlbSAmJiBpdGVtLnVwZGF0ZSkgaXRlbS51cGRhdGUodGltZSk7XG4gICAgICAgIGlmIChpdGVtICYmIGl0ZW0ub25VcGRhdGUpIGl0ZW0ub25VcGRhdGUodGltZSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5VcGRhdGUgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogcmVxdWVzdFVwZGF0ZXMgdGFrZXMgYSBjbGFzcyB0aGF0IGhhcyBhbiBvblVwZGF0ZSBtZXRob2QgYW5kIHB1dHMgaXRcbiAqIGludG8gdGhlIHVwZGF0ZVF1ZXVlIHRvIGJlIHVwZGF0ZWQgYXQgdGhlIG5leHQgZnJhbWUuXG4gKiBJZiBGYW1vdXNFbmdpbmUgaXMgY3VycmVudGx5IGluIGFuIHVwZGF0ZSwgcmVxdWVzdFVwZGF0ZVxuICogcGFzc2VzIGl0cyBhcmd1bWVudCB0byByZXF1ZXN0VXBkYXRlT25OZXh0VGljay5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RlciBhbiBvYmplY3Qgd2l0aCBhbiBvblVwZGF0ZSBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLnJlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiByZXF1ZXN0VXBkYXRlIChyZXF1ZXN0ZXIpIHtcbiAgICBpZiAoIXJlcXVlc3RlcilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ3JlcXVlc3RVcGRhdGUgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIGNsYXNzIHRvIGJlIHVwZGF0ZWQnXG4gICAgICAgICk7XG5cbiAgICBpZiAodGhpcy5faW5VcGRhdGUpIHRoaXMucmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2socmVxdWVzdGVyKTtcbiAgICBlbHNlIHRoaXMuX3VwZGF0ZVF1ZXVlLnB1c2gocmVxdWVzdGVyKTtcbn07XG5cbi8qKlxuICogcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sgaXMgcmVxdWVzdHMgYW4gdXBkYXRlIG9uIHRoZSBuZXh0IGZyYW1lLlxuICogSWYgRmFtb3VzRW5naW5lIGlzIG5vdCBjdXJyZW50bHkgaW4gYW4gdXBkYXRlIHRoYW4gaXQgaXMgZnVuY3Rpb25hbGx5IGVxdWl2YWxlbnRcbiAqIHRvIHJlcXVlc3RVcGRhdGUuIFRoaXMgbWV0aG9kIHNob3VsZCBiZSB1c2VkIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHMgd2hlcmVcbiAqIGEgY2xhc3MgaXMgdXBkYXRlZCBvbiB0aGUgZnJhbWUgYnV0IG5lZWRzIHRvIGJlIHVwZGF0ZWQgYWdhaW4gbmV4dCBmcmFtZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RlciBhbiBvYmplY3Qgd2l0aCBhbiBvblVwZGF0ZSBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLnJlcXVlc3RVcGRhdGVPbk5leHRUaWNrID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2sgKHJlcXVlc3Rlcikge1xuICAgIHRoaXMuX25leHRVcGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG59O1xuXG4vKipcbiAqIHBvc3RNZXNzYWdlIHNlbmRzIGEgbWVzc2FnZSBxdWV1ZSBpbnRvIEZhbW91c0VuZ2luZSB0byBiZSBwcm9jZXNzZWQuXG4gKiBUaGVzZSBtZXNzYWdlcyB3aWxsIGJlIGludGVycHJldGVkIGFuZCBzZW50IGludG8gdGhlIHNjZW5lIGdyYXBoXG4gKiBhcyBldmVudHMgaWYgbmVjZXNzYXJ5LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBtZXNzYWdlcyBhbiBhcnJheSBvZiBjb21tYW5kcy5cbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXNFbmdpbmV9IHRoaXNcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5oYW5kbGVNZXNzYWdlID0gZnVuY3Rpb24gaGFuZGxlTWVzc2FnZSAobWVzc2FnZXMpIHtcbiAgICBpZiAoIW1lc3NhZ2VzKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnb25NZXNzYWdlIG11c3QgYmUgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgbWVzc2FnZXMnXG4gICAgICAgICk7XG5cbiAgICB2YXIgY29tbWFuZDtcblxuICAgIHdoaWxlIChtZXNzYWdlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbW1hbmQgPSBtZXNzYWdlcy5zaGlmdCgpO1xuICAgICAgICBzd2l0Y2ggKGNvbW1hbmQpIHtcbiAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuV0lUSDpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVdpdGgobWVzc2FnZXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5GUkFNRTpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUZyYW1lKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNlaXZlZCB1bmtub3duIGNvbW1hbmQ6ICcgKyBjb21tYW5kKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogaGFuZGxlV2l0aCBpcyBhIG1ldGhvZCB0aGF0IHRha2VzIGFuIGFycmF5IG9mIG1lc3NhZ2VzIGZvbGxvd2luZyB0aGVcbiAqIFdJVEggY29tbWFuZC4gSXQnbGwgdGhlbiBpc3N1ZSB0aGUgbmV4dCBjb21tYW5kcyB0byB0aGUgcGF0aCBzcGVjaWZpZWRcbiAqIGJ5IHRoZSBXSVRIIGNvbW1hbmQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG1lc3NhZ2VzIGFycmF5IG9mIG1lc3NhZ2VzLlxuICpcbiAqIEByZXR1cm4ge0ZhbW91c0VuZ2luZX0gdGhpc1xuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLmhhbmRsZVdpdGggPSBmdW5jdGlvbiBoYW5kbGVXaXRoIChtZXNzYWdlcykge1xuICAgIHZhciBwYXRoID0gbWVzc2FnZXMuc2hpZnQoKTtcbiAgICB2YXIgY29tbWFuZCA9IG1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgc3dpdGNoIChjb21tYW5kKSB7XG4gICAgICAgIGNhc2UgQ29tbWFuZHMuVFJJR0dFUjogLy8gdGhlIFRSSUdHRVIgY29tbWFuZCBzZW5kcyBhIFVJRXZlbnQgdG8gdGhlIHNwZWNpZmllZCBwYXRoXG4gICAgICAgICAgICB2YXIgdHlwZSA9IG1lc3NhZ2VzLnNoaWZ0KCk7XG4gICAgICAgICAgICB2YXIgZXYgPSBtZXNzYWdlcy5zaGlmdCgpO1xuICAgICAgICAgICAgRGlzcGF0Y2guZGlzcGF0Y2hVSUV2ZW50KHBhdGgsIHR5cGUsIGV2KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZWNlaXZlZCB1bmtub3duIGNvbW1hbmQ6ICcgKyBjb21tYW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIGhhbmRsZUZyYW1lIGlzIGNhbGxlZCB3aGVuIHRoZSByZW5kZXJlcnMgaXNzdWUgYSBGUkFNRSBjb21tYW5kIHRvXG4gKiBGYW1vdXNFbmdpbmUuIEZhbW91c0VuZ2luZSB3aWxsIHRoZW4gc3RlcCB1cGRhdGluZyB0aGUgc2NlbmUgZ3JhcGggdG8gdGhlIGN1cnJlbnQgdGltZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gbWVzc2FnZXMgYXJyYXkgb2YgbWVzc2FnZXMuXG4gKlxuICogQHJldHVybiB7RmFtb3VzRW5naW5lfSB0aGlzXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuaGFuZGxlRnJhbWUgPSBmdW5jdGlvbiBoYW5kbGVGcmFtZSAobWVzc2FnZXMpIHtcbiAgICBpZiAoIW1lc3NhZ2VzKSB0aHJvdyBuZXcgRXJyb3IoJ2hhbmRsZUZyYW1lIG11c3QgYmUgY2FsbGVkIHdpdGggYW4gYXJyYXkgb2YgbWVzc2FnZXMnKTtcbiAgICBpZiAoIW1lc3NhZ2VzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdGUkFNRSBtdXN0IGJlIHNlbnQgd2l0aCBhIHRpbWUnKTtcblxuICAgIHRoaXMuc3RlcChtZXNzYWdlcy5zaGlmdCgpKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogc3RlcCB1cGRhdGVzIHRoZSBjbG9jayBhbmQgdGhlIHNjZW5lIGdyYXBoIGFuZCB0aGVuIHNlbmRzIHRoZSBkcmF3IGNvbW1hbmRzXG4gKiB0aGF0IGFjY3VtdWxhdGVkIGluIHRoZSB1cGRhdGUgdG8gdGhlIHJlbmRlcmVycy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgY3VycmVudCBlbmdpbmUgdGltZVxuICpcbiAqIEByZXR1cm4ge0ZhbW91c0VuZ2luZX0gdGhpc1xuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiBzdGVwICh0aW1lKSB7XG4gICAgaWYgKHRpbWUgPT0gbnVsbCkgdGhyb3cgbmV3IEVycm9yKCdzdGVwIG11c3QgYmUgY2FsbGVkIHdpdGggYSB0aW1lJyk7XG5cbiAgICB0aGlzLl9jbG9jay5zdGVwKHRpbWUpO1xuICAgIHRoaXMuX3VwZGF0ZSgpO1xuXG4gICAgaWYgKHRoaXMuX21lc3NhZ2VzLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9jaGFubmVsLnNlbmRNZXNzYWdlKHRoaXMuX21lc3NhZ2VzKTtcbiAgICAgICAgd2hpbGUgKHRoaXMuX21lc3NhZ2VzLmxlbmd0aCA+IDIpIHRoaXMuX21lc3NhZ2VzLnBvcCgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiByZXR1cm5zIHRoZSBjb250ZXh0IG9mIGEgcGFydGljdWxhciBwYXRoLiBUaGUgY29udGV4dCBpcyBsb29rZWQgdXAgYnkgdGhlIHNlbGVjdG9yXG4gKiBwb3J0aW9uIG9mIHRoZSBwYXRoIGFuZCBpcyBsaXN0ZWQgZnJvbSB0aGUgc3RhcnQgb2YgdGhlIHN0cmluZyB0byB0aGUgZmlyc3RcbiAqICcvJy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIHRoZSBwYXRoIHRvIGxvb2sgdXAgdGhlIGNvbnRleHQgZm9yLlxuICpcbiAqIEByZXR1cm4ge0NvbnRleHQgfCBVbmRlZmluZWR9IHRoZSBjb250ZXh0IGlmIGZvdW5kLCBlbHNlIHVuZGVmaW5lZC5cbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dCAoc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yKSB0aHJvdyBuZXcgRXJyb3IoJ2dldENvbnRleHQgbXVzdCBiZSBjYWxsZWQgd2l0aCBhIHNlbGVjdG9yJyk7XG5cbiAgICB2YXIgaW5kZXggPSBzZWxlY3Rvci5pbmRleE9mKCcvJyk7XG4gICAgc2VsZWN0b3IgPSBpbmRleCA9PT0gLTEgPyBzZWxlY3RvciA6IHNlbGVjdG9yLnN1YnN0cmluZygwLCBpbmRleCk7XG5cbiAgICByZXR1cm4gdGhpcy5fc2NlbmVzW3NlbGVjdG9yXTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgaW5zdGFuY2Ugb2YgY2xvY2sgdXNlZCBieSB0aGUgRmFtb3VzRW5naW5lLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtDbG9ja30gRmFtb3VzRW5naW5lJ3MgY2xvY2tcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5nZXRDbG9jayA9IGZ1bmN0aW9uIGdldENsb2NrICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY2xvY2s7XG59O1xuXG4vKipcbiAqIEVucXVldWVzIGEgbWVzc2FnZSB0byBiZSB0cmFuc2ZlcmVkIHRvIHRoZSByZW5kZXJlcnMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7QW55fSBjb21tYW5kIERyYXcgQ29tbWFuZFxuICpcbiAqIEByZXR1cm4ge0ZhbW91c0VuZ2luZX0gdGhpc1xuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLm1lc3NhZ2UgPSBmdW5jdGlvbiBtZXNzYWdlIChjb21tYW5kKSB7XG4gICAgdGhpcy5fbWVzc2FnZXMucHVzaChjb21tYW5kKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBkZXRhY2hlZCBOb2RlIHRoYXQgY2FuIGJlIGFkZGVkIHRvIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSAgICAgICAgICAgICAgIEEgbmV3IGluc3RhbmNlIG9mIE5vZGUuXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuY3JlYXRlTm9kZSA9IGZ1bmN0aW9uIGNyZWF0ZU5vZGUgKCkge1xuICAgIHJldHVybiBuZXcgTm9kZSgpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc2NlbmUgdW5kZXIgd2hpY2ggYSBzY2VuZSBncmFwaCBjb3VsZCBiZSBidWlsdC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIGEgZG9tIHNlbGVjdG9yIGZvciB3aGVyZSB0aGUgc2NlbmUgc2hvdWxkIGJlIHBsYWNlZFxuICpcbiAqIEByZXR1cm4ge1NjZW5lfSBhIG5ldyBpbnN0YW5jZSBvZiBTY2VuZS5cbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5jcmVhdGVTY2VuZSA9IGZ1bmN0aW9uIGNyZWF0ZVNjZW5lIChzZWxlY3Rvcikge1xuICAgIHNlbGVjdG9yID0gc2VsZWN0b3IgfHwgJ2JvZHknO1xuICAgIGlmICh0aGlzLl9zY2VuZXNbc2VsZWN0b3JdKSB0aGlzLnJlbW92ZVNjZW5lKHRoaXMuX3NjZW5lc1tzZWxlY3Rvcl0pO1xuXG4gICAgdmFyIHNjZW5lID0gbmV3IFNjZW5lKCk7XG4gICAgdGhpcy5hZGRTY2VuZShzZWxlY3Rvciwgc2NlbmUpO1xuICAgIHJldHVybiBzY2VuZTtcbn07XG5cbi8qKlxuICogSW50cm9kdWNlIGFuIGFscmVhZHkgaW5zdGFudGlhdGVkIHNjZW5lIHRvIHRoZSBlbmdpbmUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzZWxlY3RvciBhIGRvbSBzZWxlY3RvciBmb3Igd2hlcmUgdGhlIHNjZW5lIHNob3VsZCBiZSBwbGFjZWRcbiAqIEBwYXJhbSB7U2NlbmV9IHNjZW5lIHRoZSBzY2VuZSB0byByZWludHJvZHVjZSB0byB0aGUgZW5naW5lXG4gKlxuICogQHJldHVybiB7RmFtb3VzRW5naW5lfSB0aGlzXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuYWRkU2NlbmUgPSBmdW5jdGlvbiBhZGRTY2VuZSAoc2VsZWN0b3IsIHNjZW5lKSB7XG4gICAgc2VsZWN0b3IgPSBzZWxlY3RvciB8fCAnYm9keSc7XG4gICAgdGhpcy5yZW1vdmVTY2VuZShzY2VuZSk7XG4gICAgaWYgKHRoaXMuX3NjZW5lc1tzZWxlY3Rvcl0pIHRoaXMucmVtb3ZlU2NlbmUodGhpcy5fc2NlbmVzW3NlbGVjdG9yXSk7XG5cbiAgICB0aGlzLl9zY2VuZXNbc2VsZWN0b3JdID0gc2NlbmU7XG4gICAgc2NlbmUubW91bnQoc2VsZWN0b3IpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhIHNjZW5lLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1NjZW5lfSBzY2VuZSB0aGUgc2NlbmUgdG8gcmVtb3ZlIGZyb20gdGhlIGVuZ2luZVxuICpcbiAqIEByZXR1cm4ge0ZhbW91c0VuZ2luZX0gdGhpc1xuICovXG5GYW1vdXNFbmdpbmUucHJvdG90eXBlLnJlbW92ZVNjZW5lID0gZnVuY3Rpb24gcmVtb3ZlU2NlbmUgKHNjZW5lKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gc2NlbmUuX2lkO1xuXG4gICAgdmFyIGN1cnJlbnQgPSB0aGlzLl9zY2VuZXNbc2VsZWN0b3JdO1xuICAgIGlmIChjdXJyZW50ICYmIGN1cnJlbnQgPT09IHNjZW5lKSB7XG4gICAgICAgIHNjZW5lLmRpc21vdW50KCk7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zY2VuZXNbc2VsZWN0b3JdO1xuICAgICAgICB0aGlzLl9tZXNzYWdlcy5wdXNoKENvbW1hbmRzLldJVEgsIHNlbGVjdG9yLCBDb21tYW5kcy5SRU1PVkVfU0NFTkUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3RhcnRzIHRoZSBlbmdpbmUgcnVubmluZyBpbiB0aGUgTWFpbi1UaHJlYWQuXG4gKiBUaGlzIGVmZmVjdHMgKipldmVyeSoqIHVwZGF0ZWFibGUgbWFuYWdlZCBieSB0aGUgRW5naW5lLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtGYW1vdXNFbmdpbmV9IHRoaXNcbiAqL1xuRmFtb3VzRW5naW5lLnByb3RvdHlwZS5zdGFydFJlbmRlckxvb3AgPSBmdW5jdGlvbiBzdGFydFJlbmRlckxvb3AoKSB7XG4gICAgdGhpcy5fY2hhbm5lbC5zZW5kTWVzc2FnZShFTkdJTkVfU1RBUlQpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTdG9wcyB0aGUgZW5naW5lIHJ1bm5pbmcgaW4gdGhlIE1haW4tVGhyZWFkLlxuICogVGhpcyBlZmZlY3RzICoqZXZlcnkqKiB1cGRhdGVhYmxlIG1hbmFnZWQgYnkgdGhlIEVuZ2luZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmFtb3VzRW5naW5lfSB0aGlzXG4gKi9cbkZhbW91c0VuZ2luZS5wcm90b3R5cGUuc3RvcFJlbmRlckxvb3AgPSBmdW5jdGlvbiBzdG9wUmVuZGVyTG9vcCgpIHtcbiAgICB0aGlzLl9jaGFubmVsLnNlbmRNZXNzYWdlKEVOR0lORV9TVE9QKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gbmV3IEZhbW91c0VuZ2luZSgpO1xuIiwiLypcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4vKmpzaGludCAtVzA3OSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTaXplU3lzdGVtID0gcmVxdWlyZSgnLi9TaXplU3lzdGVtJyk7XG52YXIgRGlzcGF0Y2ggPSByZXF1aXJlKCcuL0Rpc3BhdGNoJyk7XG52YXIgVHJhbnNmb3JtU3lzdGVtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1TeXN0ZW0nKTtcbnZhciBPcGFjaXR5U3lzdGVtID0gcmVxdWlyZSgnLi9PcGFjaXR5U3lzdGVtJyk7XG52YXIgU2l6ZSA9IHJlcXVpcmUoJy4vU2l6ZScpO1xudmFyIE9wYWNpdHkgPSByZXF1aXJlKCcuL09wYWNpdHknKTtcbnZhciBUcmFuc2Zvcm0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybScpO1xuXG4vKipcbiAqIE5vZGVzIGRlZmluZSBoaWVyYXJjaHkgYW5kIGdlb21ldHJpY2FsIHRyYW5zZm9ybWF0aW9ucy4gVGhleSBjYW4gYmUgbW92ZWRcbiAqICh0cmFuc2xhdGVkKSwgc2NhbGVkIGFuZCByb3RhdGVkLlxuICpcbiAqIEEgTm9kZSBpcyBlaXRoZXIgbW91bnRlZCBvciB1bm1vdW50ZWQuIFVubW91bnRlZCBub2RlcyBhcmUgZGV0YWNoZWQgZnJvbSB0aGVcbiAqIHNjZW5lIGdyYXBoLiBVbm1vdW50ZWQgbm9kZXMgaGF2ZSBubyBwYXJlbnQgbm9kZSwgd2hpbGUgZWFjaCBtb3VudGVkIG5vZGUgaGFzXG4gKiBleGFjdGx5IG9uZSBwYXJlbnQuIE5vZGVzIGhhdmUgYW4gYXJiaXRyYXJ5IG51bWJlciBvZiBjaGlsZHJlbiwgd2hpY2ggY2FuIGJlXG4gKiBkeW5hbWljYWxseSBhZGRlZCB1c2luZyB7QGxpbmsgTm9kZSNhZGRDaGlsZH0uXG4gKlxuICogRWFjaCBOb2RlIGhhcyBhbiBhcmJpdHJhcnkgbnVtYmVyIG9mIGBjb21wb25lbnRzYC4gVGhvc2UgY29tcG9uZW50cyBjYW5cbiAqIHNlbmQgYGRyYXdgIGNvbW1hbmRzIHRvIHRoZSByZW5kZXJlciBvciBtdXRhdGUgdGhlIG5vZGUgaXRzZWxmLCBpbiB3aGljaCBjYXNlXG4gKiB0aGV5IGRlZmluZSBiZWhhdmlvciBpbiB0aGUgbW9zdCBleHBsaWNpdCB3YXkuIENvbXBvbmVudHMgdGhhdCBzZW5kIGBkcmF3YFxuICogY29tbWFuZHMgYXJlIGNvbnNpZGVyZWQgYHJlbmRlcmFibGVzYC4gRnJvbSB0aGUgbm9kZSdzIHBlcnNwZWN0aXZlLCB0aGVyZSBpc1xuICogbm8gZGlzdGluY3Rpb24gYmV0d2VlbiBub2RlcyB0aGF0IHNlbmQgZHJhdyBjb21tYW5kcyBhbmQgbm9kZXMgdGhhdCBkZWZpbmVcbiAqIGJlaGF2aW9yLlxuICpcbiAqIEJlY2F1c2Ugb2YgdGhlIGZhY3QgdGhhdCBOb2RlcyB0aGVtc2VsZiBhcmUgdmVyeSB1bm9waW5pb3RlZCAodGhleSBkb24ndFxuICogXCJyZW5kZXJcIiB0byBhbnl0aGluZyksIHRoZXkgYXJlIG9mdGVuIGJlaW5nIHN1YmNsYXNzZWQgaW4gb3JkZXIgdG8gYWRkIGUuZy5cbiAqIGNvbXBvbmVudHMgYXQgaW5pdGlhbGl6YXRpb24gdG8gdGhlbS4gQmVjYXVzZSBvZiB0aGlzIGZsZXhpYmlsaXR5LCB0aGV5IG1pZ2h0XG4gKiBhcyB3ZWxsIGhhdmUgYmVlbiBjYWxsZWQgYEVudGl0aWVzYC5cbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gY3JlYXRlIHRocmVlIGRldGFjaGVkICh1bm1vdW50ZWQpIG5vZGVzXG4gKiB2YXIgcGFyZW50ID0gbmV3IE5vZGUoKTtcbiAqIHZhciBjaGlsZDEgPSBuZXcgTm9kZSgpO1xuICogdmFyIGNoaWxkMiA9IG5ldyBOb2RlKCk7XG4gKlxuICogLy8gYnVpbGQgYW4gdW5tb3VudGVkIHN1YnRyZWUgKHBhcmVudCBpcyBzdGlsbCBkZXRhY2hlZClcbiAqIHBhcmVudC5hZGRDaGlsZChjaGlsZDEpO1xuICogcGFyZW50LmFkZENoaWxkKGNoaWxkMik7XG4gKlxuICogLy8gbW91bnQgcGFyZW50IGJ5IGFkZGluZyBpdCB0byB0aGUgY29udGV4dFxuICogdmFyIGNvbnRleHQgPSBGYW1vdXMuY3JlYXRlQ29udGV4dChcImJvZHlcIik7XG4gKiBjb250ZXh0LmFkZENoaWxkKHBhcmVudCk7XG4gKlxuICogQGNsYXNzIE5vZGVcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBOb2RlIChvcHRpb25zKSB7XG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX2luVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fbW91bnRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3Nob3duID0gdHJ1ZTtcbiAgICB0aGlzLl91cGRhdGVyID0gbnVsbDtcbiAgICB0aGlzLl9VSUV2ZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fdXBkYXRlUXVldWUgPSBbXTtcbiAgICB0aGlzLl9uZXh0VXBkYXRlUXVldWUgPSBbXTtcblxuICAgIHRoaXMuX2ZyZWVkQ29tcG9uZW50SW5kaWNpZXMgPSBbXTtcbiAgICB0aGlzLl9jb21wb25lbnRzID0gW107XG5cbiAgICB0aGlzLl9mcmVlZENoaWxkSW5kaWNpZXMgPSBbXTtcbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXG4gICAgdGhpcy5fZnVsbENoaWxkcmVuID0gW107XG5cbiAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuXG4gICAgdGhpcy5faWQgPSBudWxsO1xuXG4gICAgdGhpcy5fdHJhbnNmb3JtSUQgPSBudWxsO1xuICAgIHRoaXMuX3NpemVJRCA9IG51bGw7XG4gICAgdGhpcy5fb3BhY2l0eUlEID0gbnVsbDtcblxuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpIHRoaXMuX2luaXQoKTtcblxuICAgIGlmIChvcHRpb25zKSB0aGlzLl9oYW5kbGVPcHRpb25zKG9wdGlvbnMpO1xufVxuXG5Ob2RlLlJFTEFUSVZFX1NJWkUgPSAwO1xuTm9kZS5BQlNPTFVURV9TSVpFID0gMTtcbk5vZGUuUkVOREVSX1NJWkUgPSAyO1xuTm9kZS5ERUZBVUxUX1NJWkUgPSAwO1xuTm9kZS5OT19ERUZBVUxUX0NPTVBPTkVOVFMgPSBmYWxzZTtcblxuLyoqXG4gKiBQcm90ZWN0ZWQgbWV0aG9kLiBJbml0aWFsaXplcyBhIG5vZGUgd2l0aCBhIGRlZmF1bHQgVHJhbnNmb3JtIGFuZCBTaXplIGNvbXBvbmVudFxuICpcbiAqIEBtZXRob2RcbiAqIEBwcm90ZWN0ZWRcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Ob2RlLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIF9pbml0ICgpIHtcbiAgICB0aGlzLl90cmFuc2Zvcm1JRCA9IHRoaXMuYWRkQ29tcG9uZW50KG5ldyBUcmFuc2Zvcm0oKSk7XG4gICAgdGhpcy5fc2l6ZUlEID0gdGhpcy5hZGRDb21wb25lbnQobmV3IFNpemUoKSk7XG4gICAgdGhpcy5fb3BhY2l0eUlEID0gdGhpcy5hZGRDb21wb25lbnQobmV3IE9wYWNpdHkoKSk7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5faGFuZGxlT3B0aW9ucyA9IGZ1bmN0aW9uIF9oYW5kbGVPcHRpb25zIChvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMucG9zaXRpb24pIHRoaXMuc2V0UG9zaXRpb24uYXBwbHkodGhpcywgb3B0aW9ucy5wb3NpdGlvbik7XG4gICAgaWYgKG9wdGlvbnMucm90YXRpb24pIHRoaXMuc2V0Um90YXRpb24uYXBwbHkodGhpcywgb3B0aW9ucy5yb3RhdGlvbik7XG4gICAgaWYgKG9wdGlvbnMuc2NhbGUpIHRoaXMuc2V0U2NhbGUuYXBwbHkodGhpcywgb3B0aW9ucy5zY2FsZSk7XG5cbiAgICBpZiAob3B0aW9ucy5vcmlnaW4pIHRoaXMuc2V0T3JpZ2luLmFwcGx5KHRoaXMsIG9wdGlvbnMub3JpZ2luKTtcbiAgICBpZiAob3B0aW9ucy5tb3VudFBvaW50KSB0aGlzLnNldE1vdW50UG9pbnQuYXBwbHkodGhpcywgb3B0aW9ucy5tb3VudFBvaW50KTtcbiAgICBpZiAob3B0aW9ucy5hbGlnbikgdGhpcy5zZXRBbGlnbi5hcHBseSh0aGlzLCBvcHRpb25zLmFsaWduKTtcblxuICAgIGlmIChvcHRpb25zLm9wYWNpdHkgIT0gbnVsbCkgdGhpcy5zZXRPcGFjaXR5KG9wdGlvbnMub3BhY2l0eSk7XG5cbiAgICBpZiAob3B0aW9ucy5zaXplTW9kZSkgdGhpcy5zZXRTaXplTW9kZS5hcHBseSh0aGlzLCBvcHRpb25zLnNpemVNb2RlKTtcbiAgICBpZiAob3B0aW9ucy5hYnNvbHV0ZVNpemUpIHRoaXMuc2V0QWJzb2x1dGVTaXplLmFwcGx5KHRoaXMsIG9wdGlvbnMuYWJzb2x1dGVTaXplKTtcbiAgICBpZiAob3B0aW9ucy5kaWZmZXJlbnRpYWxTaXplKSB0aGlzLnNldERpZmZlcmVudGlhbFNpemUuYXBwbHkodGhpcywgb3B0aW9ucy5kaWZmZXJlbnRpYWxTaXplKTtcbiAgICBpZiAob3B0aW9ucy5wcm9wb3J0aW9uYWxTaXplKSB0aGlzLnNldFByb3BvcnRpb25hbFNpemUuYXBwbHkodGhpcywgb3B0aW9ucy5wcm9wb3J0aW9uYWxTaXplKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdXNlZCB1ZHBhdGVyLlxuICpcbiAqIEByZXR1cm4ge0ZhbW91c30gdGhlIHVwZGF0ZXIgZm9yIHRoaXMgTm9kZS5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0VXBkYXRlciA9IGZ1bmN0aW9uIGdldFVwZGF0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzLl91cGRhdGVyO1xufTtcblxuLyoqXG4gKiBQcm90ZWN0ZWQgbWV0aG9kLiBTZXRzIHRoZSBwYXJlbnQgb2YgdGhpcyBub2RlIHN1Y2ggdGhhdCBpdCBjYW4gYmUgbG9va2VkIHVwLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge05vZGV9IHBhcmVudCBUaGUgbm9kZSB0byBzZXQgYXMgdGhlIHBhcmVudCBvZiB0aGlzXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWQ7XG4gKi9cbk5vZGUucHJvdG90eXBlLl9zZXRQYXJlbnQgPSBmdW5jdGlvbiBfc2V0UGFyZW50IChwYXJlbnQpIHtcbiAgICBpZiAodGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5nZXRDaGlsZHJlbigpLmluZGV4T2YodGhpcykgIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3BhcmVudC5yZW1vdmVDaGlsZCh0aGlzKTtcbiAgICB9XG4gICAgdGhpcy5fcGFyZW50ID0gcGFyZW50O1xufTtcblxuLyoqXG4gKiBQcm90ZWN0ZWQgbWV0aG9kLiBTZXRzIHRoZSBtb3VudCBzdGF0ZSBvZiB0aGUgbm9kZS4gU2hvdWxkIG9ubHkgYmUgY2FsbGVkXG4gKiBieSB0aGUgZGlzcGF0Y2hcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBtb3VudGVkIHdoZXRoZXIgb3Igbm90IHRoZSBOb2RlIGlzIG1vdW50ZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCB0aGF0IHRoZSBub2RlIHdpbGwgYmUgbW91bnRlZCB0b1xuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbk5vZGUucHJvdG90eXBlLl9zZXRNb3VudGVkID0gZnVuY3Rpb24gX3NldE1vdW50ZWQgKG1vdW50ZWQsIHBhdGgpIHtcbiAgICB0aGlzLl9tb3VudGVkID0gbW91bnRlZDtcbiAgICB0aGlzLl9pZCA9IHBhdGggPyBwYXRoIDogbnVsbDtcbn07XG5cbi8qKlxuICogUHJvdGVjdGVkIG1ldGhvZCwgc2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgTm9kZSBpcyBzaG93bi4gU2hvdWxkIG9ubHlcbiAqIGJlIGNhbGxlZCBieSB0aGUgZGlzcGF0Y2hcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBzaG93biB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZSBpcyBzaG93blxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbk5vZGUucHJvdG90eXBlLl9zZXRTaG93biA9IGZ1bmN0aW9uIF9zZXRTaG93biAoc2hvd24pIHtcbiAgICB0aGlzLl9zaG93biA9IHNob3duO1xufTtcblxuLyoqXG4gKiBQcm90ZWN0ZWQgbWV0aG9kLiBTZXRzIHRoZSB1cGRhdGVyIG9mIHRoZSBub2RlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0ZhbW91c0VuZ2luZX0gdXBkYXRlciB0aGUgVXBkYXRlciBvZiB0aGUgbm9kZS5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Ob2RlLnByb3RvdHlwZS5fc2V0VXBkYXRlciA9IGZ1bmN0aW9uIF9zZXRVcGRhdGVyICh1cGRhdGVyKSB7XG4gICAgdGhpcy5fdXBkYXRlciA9IHVwZGF0ZXI7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3VwZGF0ZXIucmVxdWVzdFVwZGF0ZSh0aGlzKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lIHRoZSBub2RlJ3MgbG9jYXRpb24gaW4gdGhlIHNjZW5lIGdyYXBoIGhpZXJhcmNoeS5cbiAqIEEgbG9jYXRpb24gb2YgYGJvZHkvMC8xYCBjYW4gYmUgaW50ZXJwcmV0ZWQgYXMgdGhlIGZvbGxvd2luZyBzY2VuZSBncmFwaFxuICogaGllcmFyY2h5IChpZ25vcmluZyBzaWJsaW5ncyBvZiBhbmNlc3RvcnMgYW5kIGFkZGl0aW9uYWwgY2hpbGQgbm9kZXMpOlxuICpcbiAqIGBDb250ZXh0OmJvZHlgIC0+IGBOb2RlOjBgIC0+IGBOb2RlOjFgLCB3aGVyZSBgTm9kZToxYCBpcyB0aGUgbm9kZSB0aGVcbiAqIGBnZXRMb2NhdGlvbmAgbWV0aG9kIGhhcyBiZWVuIGludm9rZWQgb24uXG4gKlxuICogQG1ldGhvZCBnZXRMb2NhdGlvblxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gbG9jYXRpb24gKHBhdGgpLCBlLmcuIGBib2R5LzAvMWBcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb24gPSBmdW5jdGlvbiBnZXRMb2NhdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lkO1xufTtcblxuLyoqXG4gKiBAYWxpYXMgZ2V0SWRcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHRoZSBwYXRoIG9mIHRoZSBOb2RlXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldElkID0gTm9kZS5wcm90b3R5cGUuZ2V0TG9jYXRpb247XG5cbi8qKlxuICogRGlzcGF0Y2hlcyB0aGUgZXZlbnQgdXNpbmcgdGhlIERpc3BhdGNoLiBBbGwgZGVzY2VuZGVudCBub2RlcyB3aWxsXG4gKiByZWNlaXZlIHRoZSBkaXNwYXRjaGVkIGV2ZW50LlxuICpcbiAqIEBtZXRob2QgZW1pdFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gZXZlbnQgICBFdmVudCB0eXBlLlxuICogQHBhcmFtICB7T2JqZWN0fSBwYXlsb2FkIEV2ZW50IG9iamVjdCB0byBiZSBkaXNwYXRjaGVkLlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQgKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgRGlzcGF0Y2guZGlzcGF0Y2godGhpcy5nZXRMb2NhdGlvbigpLCBldmVudCwgcGF5bG9hZCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBUSElTIFdJTEwgQkUgREVQUkVDQVRFRFxuTm9kZS5wcm90b3R5cGUuc2VuZERyYXdDb21tYW5kID0gZnVuY3Rpb24gc2VuZERyYXdDb21tYW5kIChtZXNzYWdlKSB7XG4gICAgdGhpcy5fdXBkYXRlci5tZXNzYWdlKG1lc3NhZ2UpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWN1cnNpdmVseSBzZXJpYWxpemVzIHRoZSBOb2RlLCBpbmNsdWRpbmcgYWxsIHByZXZpb3VzbHkgYWRkZWQgY29tcG9uZW50cy5cbiAqXG4gKiBAbWV0aG9kIGdldFZhbHVlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSAgICAgU2VyaWFsaXplZCByZXByZXNlbnRhdGlvbiBvZiB0aGUgbm9kZSwgaW5jbHVkaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRzLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlICgpIHtcbiAgICB2YXIgbnVtYmVyT2ZDaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcbiAgICB2YXIgbnVtYmVyT2ZDb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5sZW5ndGg7XG4gICAgdmFyIGkgPSAwO1xuXG4gICAgdmFyIHZhbHVlID0ge1xuICAgICAgICBsb2NhdGlvbjogdGhpcy5nZXRJZCgpLFxuICAgICAgICBzcGVjOiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogdGhpcy5nZXRJZCgpLFxuICAgICAgICAgICAgc2hvd1N0YXRlOiB7XG4gICAgICAgICAgICAgICAgbW91bnRlZDogdGhpcy5pc01vdW50ZWQoKSxcbiAgICAgICAgICAgICAgICBzaG93bjogdGhpcy5pc1Nob3duKCksXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogMVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9mZnNldHM6IHtcbiAgICAgICAgICAgICAgICBtb3VudFBvaW50OiBbMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgYWxpZ246IFswLCAwLCAwXSxcbiAgICAgICAgICAgICAgICBvcmlnaW46IFswLCAwLCAwXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZlY3RvcnM6IHtcbiAgICAgICAgICAgICAgICBwb3NpdGlvbjogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBbMCwgMCwgMCwgMV0sXG4gICAgICAgICAgICAgICAgc2NhbGU6IFsxLCAxLCAxXVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNpemU6IHtcbiAgICAgICAgICAgICAgICBzaXplTW9kZTogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIHByb3BvcnRpb25hbDogWzEsIDEsIDFdLFxuICAgICAgICAgICAgICAgIGRpZmZlcmVudGlhbDogWzAsIDAsIDBdLFxuICAgICAgICAgICAgICAgIGFic29sdXRlOiBbMCwgMCwgMF0sXG4gICAgICAgICAgICAgICAgcmVuZGVyOiBbMCwgMCwgMF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgVUlFdmVudHM6IHRoaXMuX1VJRXZlbnRzLFxuICAgICAgICBjb21wb25lbnRzOiBbXSxcbiAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgfTtcblxuICAgIGlmICh2YWx1ZS5sb2NhdGlvbikge1xuICAgICAgICB2YXIgdHJhbnNmb3JtID0gVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldElkKCkpO1xuICAgICAgICB2YXIgc2l6ZSA9IFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0SWQoKSk7XG4gICAgICAgIHZhciBvcGFjaXR5ID0gT3BhY2l0eVN5c3RlbS5nZXQodGhpcy5nZXRJZCgpKTtcblxuICAgICAgICB2YWx1ZS5zcGVjLnNob3dTdGF0ZS5vcGFjaXR5ID0gb3BhY2l0eS5nZXRPcGFjaXR5KCk7XG5cbiAgICAgICAgZm9yIChpID0gMCA7IGkgPCAzIDsgaSsrKSB7XG4gICAgICAgICAgICB2YWx1ZS5zcGVjLm9mZnNldHMubW91bnRQb2ludFtpXSA9IHRyYW5zZm9ybS5vZmZzZXRzLm1vdW50UG9pbnRbaV07XG4gICAgICAgICAgICB2YWx1ZS5zcGVjLm9mZnNldHMuYWxpZ25baV0gPSB0cmFuc2Zvcm0ub2Zmc2V0cy5hbGlnbltpXTtcbiAgICAgICAgICAgIHZhbHVlLnNwZWMub2Zmc2V0cy5vcmlnaW5baV0gPSB0cmFuc2Zvcm0ub2Zmc2V0cy5vcmlnaW5baV07XG4gICAgICAgICAgICB2YWx1ZS5zcGVjLnZlY3RvcnMucG9zaXRpb25baV0gPSB0cmFuc2Zvcm0udmVjdG9ycy5wb3NpdGlvbltpXTtcbiAgICAgICAgICAgIHZhbHVlLnNwZWMudmVjdG9ycy5yb3RhdGlvbltpXSA9IHRyYW5zZm9ybS52ZWN0b3JzLnJvdGF0aW9uW2ldO1xuICAgICAgICAgICAgdmFsdWUuc3BlYy52ZWN0b3JzLnNjYWxlW2ldID0gdHJhbnNmb3JtLnZlY3RvcnMuc2NhbGVbaV07XG4gICAgICAgICAgICB2YWx1ZS5zcGVjLnNpemUuc2l6ZU1vZGVbaV0gPSBzaXplLnNpemVNb2RlW2ldO1xuICAgICAgICAgICAgdmFsdWUuc3BlYy5zaXplLnByb3BvcnRpb25hbFtpXSA9IHNpemUucHJvcG9ydGlvbmFsU2l6ZVtpXTtcbiAgICAgICAgICAgIHZhbHVlLnNwZWMuc2l6ZS5kaWZmZXJlbnRpYWxbaV0gPSBzaXplLmRpZmZlcmVudGlhbFNpemVbaV07XG4gICAgICAgICAgICB2YWx1ZS5zcGVjLnNpemUuYWJzb2x1dGVbaV0gPSBzaXplLmFic29sdXRlU2l6ZVtpXTtcbiAgICAgICAgICAgIHZhbHVlLnNwZWMuc2l6ZS5yZW5kZXJbaV0gPSBzaXplLnJlbmRlclNpemVbaV07XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZS5zcGVjLnZlY3RvcnMucm90YXRpb25bM10gPSB0cmFuc2Zvcm0udmVjdG9ycy5yb3RhdGlvblszXTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtYmVyT2ZDaGlsZHJlbiA7IGkrKylcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuW2ldICYmIHRoaXMuX2NoaWxkcmVuW2ldLmdldFZhbHVlKVxuICAgICAgICAgICAgdmFsdWUuY2hpbGRyZW4ucHVzaCh0aGlzLl9jaGlsZHJlbltpXS5nZXRWYWx1ZSgpKTtcblxuICAgIGZvciAoaSA9IDAgOyBpIDwgbnVtYmVyT2ZDb21wb25lbnRzIDsgaSsrKVxuICAgICAgICBpZiAodGhpcy5fY29tcG9uZW50c1tpXSAmJiB0aGlzLl9jb21wb25lbnRzW2ldLmdldFZhbHVlKVxuICAgICAgICAgICAgdmFsdWUuY29tcG9uZW50cy5wdXNoKHRoaXMuX2NvbXBvbmVudHNbaV0uZ2V0VmFsdWUoKSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFNpbWlsYXIgdG8ge0BsaW5rIE5vZGUjZ2V0VmFsdWV9LCBidXQgcmV0dXJucyB0aGUgYWN0dWFsIFwiY29tcHV0ZWRcIiB2YWx1ZS4gRS5nLlxuICogYSBwcm9wb3J0aW9uYWwgc2l6ZSBvZiAwLjUgbWlnaHQgcmVzb2x2ZSBpbnRvIGEgXCJjb21wdXRlZFwiIHNpemUgb2YgMjAwcHhcbiAqIChhc3N1bWluZyB0aGUgcGFyZW50IGhhcyBhIHdpZHRoIG9mIDQwMHB4KS5cbiAqXG4gKiBAbWV0aG9kIGdldENvbXB1dGVkVmFsdWVcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9ICAgICBTZXJpYWxpemVkIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBub2RlLCBpbmNsdWRpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLCBleGNsdWRpbmcgY29tcG9uZW50cy5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0Q29tcHV0ZWRWYWx1ZSA9IGZ1bmN0aW9uIGdldENvbXB1dGVkVmFsdWUgKCkge1xuICAgIGNvbnNvbGUud2FybignTm9kZS5nZXRDb21wdXRlZFZhbHVlIGlzIGRlcHJpY2F0ZWQuIFVzZSBOb2RlLmdldFZhbHVlIGluc3RlYWQnKTtcbiAgICB2YXIgbnVtYmVyT2ZDaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDtcblxuICAgIHZhciB2YWx1ZSA9IHtcbiAgICAgICAgbG9jYXRpb246IHRoaXMuZ2V0SWQoKSxcbiAgICAgICAgY29tcHV0ZWRWYWx1ZXM6IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdGhpcy5pc01vdW50ZWQoKSA/IFRyYW5zZm9ybVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5nZXRMb2NhbFRyYW5zZm9ybSgpIDogbnVsbCxcbiAgICAgICAgICAgIHNpemU6IHRoaXMuaXNNb3VudGVkKCkgPyBTaXplU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLmdldCgpIDogbnVsbCxcbiAgICAgICAgICAgIG9wYWNpdHk6IHRoaXMuaXNNb3VudGVkKCkgPyBPcGFjaXR5U3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLmdldCgpIDogbnVsbFxuICAgICAgICB9LFxuICAgICAgICBjaGlsZHJlbjogW11cbiAgICB9O1xuXG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgbnVtYmVyT2ZDaGlsZHJlbiA7IGkrKylcbiAgICAgICAgaWYgKHRoaXMuX2NoaWxkcmVuW2ldICYmIHRoaXMuX2NoaWxkcmVuW2ldLmdldENvbXB1dGVkVmFsdWUpXG4gICAgICAgICAgICB2YWx1ZS5jaGlsZHJlbi5wdXNoKHRoaXMuX2NoaWxkcmVuW2ldLmdldENvbXB1dGVkVmFsdWUoKSk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG4vKipcbiAqIFJldHJpZXZlcyBhbGwgY2hpbGRyZW4gb2YgdGhlIGN1cnJlbnQgbm9kZS5cbiAqXG4gKiBAbWV0aG9kIGdldENoaWxkcmVuXG4gKlxuICogQHJldHVybiB7QXJyYXkuPE5vZGU+fSAgIEFuIGFycmF5IG9mIGNoaWxkcmVuLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldENoaWxkcmVuICgpIHtcbiAgICByZXR1cm4gdGhpcy5fZnVsbENoaWxkcmVuO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdXNlZCBpbnRlcm5hbGx5IHRvIHJldHJpZXZlIHRoZSBjaGlsZHJlbiBvZiBhIG5vZGUuIEVhY2ggaW5kZXggaW4gdGhlXG4gKiByZXR1cm5lZCBhcnJheSByZXByZXNlbnRzIGEgcGF0aCBmcmFnbWVudC5cbiAqXG4gKiBAbWV0aG9kIGdldFJhd0NoaWxkcmVuXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge0FycmF5fSAgQW4gYXJyYXkgb2YgY2hpbGRyZW4uIE1pZ2h0IGNvbnRhaW4gYG51bGxgIGVsZW1lbnRzLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRSYXdDaGlsZHJlbiA9IGZ1bmN0aW9uIGdldFJhd0NoaWxkcmVuKCkge1xuICAgIHJldHVybiB0aGlzLl9jaGlsZHJlbjtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBwYXJlbnQgb2YgdGhlIGN1cnJlbnQgbm9kZS4gVW5tb3VudGVkIG5vZGVzIGRvIG5vdCBoYXZlIGFcbiAqIHBhcmVudCBub2RlLlxuICpcbiAqIEBtZXRob2QgZ2V0UGFyZW50XG4gKlxuICogQHJldHVybiB7Tm9kZX0gICAgICAgUGFyZW50IG5vZGUuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uIGdldFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbn07XG5cbi8qKlxuICogU2NoZWR1bGVzIHRoZSB7QGxpbmsgTm9kZSN1cGRhdGV9IGZ1bmN0aW9uIG9mIHRoZSBub2RlIHRvIGJlIGludm9rZWQgb24gdGhlXG4gKiBuZXh0IGZyYW1lIChpZiBubyB1cGRhdGUgZHVyaW5nIHRoaXMgZnJhbWUgaGFzIGJlZW4gc2NoZWR1bGVkIGFscmVhZHkpLlxuICogSWYgdGhlIG5vZGUgaXMgY3VycmVudGx5IGJlaW5nIHVwZGF0ZWQgKHdoaWNoIG1lYW5zIG9uZSBvZiB0aGUgcmVxdWVzdGVyc1xuICogaW52b2tlZCByZXF1ZXN0c1VwZGF0ZSB3aGlsZSBiZWluZyB1cGRhdGVkIGl0c2VsZiksIGFuIHVwZGF0ZSB3aWxsIGJlXG4gKiBzY2hlZHVsZWQgb24gdGhlIG5leHQgZnJhbWUgYnkgZmFsbGluZyBiYWNrIHRvIHRoZSBgcmVxdWVzdFVwZGF0ZU9uTmV4dFRpY2tgXG4gKiBmdW5jdGlvbi5cbiAqXG4gKiBDb21wb25lbnRzIHJlcXVlc3QgdGhlaXIgYG9uVXBkYXRlYCBtZXRob2QgdG8gYmUgY2FsbGVkIGR1cmluZyB0aGUgbmV4dFxuICogZnJhbWUgdXNpbmcgdGhpcyBtZXRob2QuXG4gKlxuICogQG1ldGhvZCByZXF1ZXN0VXBkYXRlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSByZXF1ZXN0ZXIgICBJZCBvZiB0aGUgY29tcG9uZW50IChhcyByZXR1cm5lZCBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgTm9kZSNhZGRDb21wb25lbnR9KSB0byBiZSB1cGRhdGVkLiBUaGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50J3MgYG9uVXBkYXRlYCBtZXRob2Qgd2lsbCBiZSBpbnZva2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmluZyB0aGUgbmV4dCB1cGRhdGUgY3ljbGUuXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlID0gZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZSAocmVxdWVzdGVyKSB7XG4gICAgaWYgKHRoaXMuX2luVXBkYXRlIHx8ICF0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICByZXR1cm4gdGhpcy5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayhyZXF1ZXN0ZXIpO1xuICAgIGlmICh0aGlzLl91cGRhdGVRdWV1ZS5pbmRleE9mKHJlcXVlc3RlcikgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVF1ZXVlLnB1c2gocmVxdWVzdGVyKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTY2hlZHVsZXMgYW4gdXBkYXRlIG9uIHRoZSBuZXh0IHRpY2suXG4gKlxuICogVGhpcyBtZXRob2QgaXMgc2ltaWxhciB0byB7QGxpbmsgTm9kZSNyZXF1ZXN0VXBkYXRlfSwgYnV0IHNjaGVkdWxlcyBhblxuICogdXBkYXRlIG9uIHRoZSAqKm5leHQqKiBmcmFtZS4gSXQgc2NoZWR1bGVzIHRoZSBub2RlJ3MgYG9uVXBkYXRlYCBmdW5jdGlvblxuICogdG8gYmUgaW52b2tlZCBvbiB0aGUgZnJhbWUgYWZ0ZXIgdGhlIG5leHQgaW52b2NhdGlvbiBvblxuICogdGhlIG5vZGUncyBvblVwZGF0ZSBmdW5jdGlvbi5cbiAqXG4gKiBUaGUgcHJpbWFyeSB1c2UtY2FzZSBmb3IgdGhpcyBtZXRob2QgaXMgdG8gcmVxdWVzdCBhbiB1cGRhdGUgd2hpbGUgYmVpbmcgaW5cbiAqIGFuIHVwZGF0ZSBwaGFzZSAoZS5nLiBiZWNhdXNlIGFuIGFuaW1hdGlvbiBpcyBzdGlsbCBhY3RpdmUpLiBNb3N0IG9mIHRoZVxuICogdGltZSwge0BsaW5rIE5vZGUjcmVxdWVzdFVwZGF0ZX0gaXMgc3VmZmljaWVudCwgc2luY2UgaXQgYXV0b21hdGljYWxseVxuICogZmFsbHMgYmFjayB0byB7QGxpbmsgTm9kZSNyZXF1ZXN0VXBkYXRlT25OZXh0VGlja30gd2hlbiBiZWluZyBpbnZva2VkIGR1cmluZ1xuICogdGhlIHVwZGF0ZSBwaGFzZS5cbiAqXG4gKiBAbWV0aG9kIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSByZXF1ZXN0ZXIgICBJZCBvZiB0aGUgY29tcG9uZW50IChhcyByZXR1cm5lZCBieVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7QGxpbmsgTm9kZSNhZGRDb21wb25lbnR9KSB0byBiZSB1cGRhdGVkLiBUaGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50J3MgYG9uVXBkYXRlYCBtZXRob2Qgd2lsbCBiZSBpbnZva2VkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR1cmluZyB0aGUgbmV4dCB1cGRhdGUgY3ljbGUuXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayA9IGZ1bmN0aW9uIHJlcXVlc3RVcGRhdGVPbk5leHRUaWNrIChyZXF1ZXN0ZXIpIHtcbiAgICBpZiAodGhpcy5fbmV4dFVwZGF0ZVF1ZXVlLmluZGV4T2YocmVxdWVzdGVyKSA9PT0gLTEpXG4gICAgICAgIHRoaXMuX25leHRVcGRhdGVRdWV1ZS5wdXNoKHJlcXVlc3Rlcik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyBtb3VudGVkLiBVbm1vdW50ZWQgbm9kZXMgYXJlIGRldGFjaGVkIGZyb20gdGhlIHNjZW5lXG4gKiBncmFwaC5cbiAqXG4gKiBAbWV0aG9kIGlzTW91bnRlZFxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBub2RlIGlzIG1vdW50ZWQgb3Igbm90LlxuICovXG5Ob2RlLnByb3RvdHlwZS5pc01vdW50ZWQgPSBmdW5jdGlvbiBpc01vdW50ZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9tb3VudGVkO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgYmVpbmcgcmVuZGVyZWQuIEEgbm9kZSBpcyBiZWluZyByZW5kZXJlcmQgd2hlbiBpdCBpc1xuICogbW91bnRlZCB0byBhIHBhcmVudCBub2RlICoqYW5kKiogc2hvd24uXG4gKlxuICogQG1ldGhvZCBpc1JlbmRlcmVkXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gICAgQm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlIG5vZGUgaXMgcmVuZGVyZWQgb3Igbm90LlxuICovXG5Ob2RlLnByb3RvdHlwZS5pc1JlbmRlcmVkID0gZnVuY3Rpb24gaXNSZW5kZXJlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21vdW50ZWQgJiYgdGhpcy5fc2hvd247XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyB2aXNpYmxlIChcInNob3duXCIpLlxuICpcbiAqIEBtZXRob2QgaXNTaG93blxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBub2RlIGlzIHZpc2libGVcbiAqICAgICAgICAgICAgICAgICAgICAgIChcInNob3duXCIpIG9yIG5vdC5cbiAqL1xuTm9kZS5wcm90b3R5cGUuaXNTaG93biA9IGZ1bmN0aW9uIGlzU2hvd24gKCkge1xuICAgIHJldHVybiB0aGlzLl9zaG93bjtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHJlbGF0aXZlIG9wYWNpdHkuXG4gKiBUaGUgb3BhY2l0eSBuZWVkcyB0byBiZSB3aXRoaW4gWzAsIDFdLCB3aGVyZSAwIGluZGljYXRlcyBhIGNvbXBsZXRlbHlcbiAqIHRyYW5zcGFyZW50LCB0aGVyZWZvcmUgaW52aXNpYmxlIG5vZGUsIHdoZXJlYXMgYW4gb3BhY2l0eSBvZiAxIG1lYW5zIHRoZVxuICogbm9kZSBpcyBjb21wbGV0ZWx5IHNvbGlkLlxuICpcbiAqIEBtZXRob2QgZ2V0T3BhY2l0eVxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gICAgICAgICBSZWxhdGl2ZSBvcGFjaXR5IG9mIHRoZSBub2RlLlxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRPcGFjaXR5ID0gZnVuY3Rpb24gZ2V0T3BhY2l0eSAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLk5PX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX29wYWNpdHlJRCkuZ2V0T3BhY2l0eSgpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHJldHVybiBPcGFjaXR5U3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLmdldE9wYWNpdHkoKTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGFuIG9wYWNpdHkgY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5vZGUncyBwcmV2aW91c2x5IHNldCBtb3VudCBwb2ludC5cbiAqXG4gKiBAbWV0aG9kIGdldE1vdW50UG9pbnRcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9ICAgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBtb3VudCBwb2ludC5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0TW91bnRQb2ludCA9IGZ1bmN0aW9uIGdldE1vdW50UG9pbnQgKCkge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCh0aGlzLl90cmFuc2Zvcm1JRCkuZ2V0TW91bnRQb2ludCgpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1TeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0TW91bnRQb2ludCgpO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSB0cmFuc2Zvcm0gY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgdGhlIG5vZGUncyBwcmV2aW91c2x5IHNldCBhbGlnbi5cbiAqXG4gKiBAbWV0aG9kIGdldEFsaWduXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSAgIEFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgYWxpZ24uXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldEFsaWduID0gZnVuY3Rpb24gZ2V0QWxpZ24gKCkge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCh0aGlzLl90cmFuc2Zvcm1JRCkuZ2V0QWxpZ24oKTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLmdldEFsaWduKCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHRyYW5zZm9ybSBjb21wb25lbnQnKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHByZXZpb3VzbHkgc2V0IG9yaWdpbi5cbiAqXG4gKiBAbWV0aG9kIGdldE9yaWdpblxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gICBBbiBhcnJheSByZXByZXNlbnRpbmcgdGhlIG9yaWdpbi5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0T3JpZ2luID0gZnVuY3Rpb24gZ2V0T3JpZ2luICgpIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuTk9fREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQodGhpcy5fdHJhbnNmb3JtSUQpLmdldE9yaWdpbigpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1TeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0T3JpZ2luKCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHRyYW5zZm9ybSBjb21wb25lbnQnKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB0aGUgbm9kZSdzIHByZXZpb3VzbHkgc2V0IHBvc2l0aW9uLlxuICpcbiAqIEBtZXRob2QgZ2V0UG9zaXRpb25cbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9ICAgQW4gYXJyYXkgcmVwcmVzZW50aW5nIHRoZSBwb3NpdGlvbi5cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLk5PX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3RyYW5zZm9ybUlEKS5nZXRQb3NpdGlvbigpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1TeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0UG9zaXRpb24oKTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgdHJhbnNmb3JtIGNvbXBvbmVudCcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBub2RlJ3MgY3VycmVudCByb3RhdGlvblxuICpcbiAqIEBtZXRob2QgZ2V0Um90YXRpb25cbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IGFuIGFycmF5IG9mIGZvdXIgdmFsdWVzLCBzaG93aW5nIHRoZSByb3RhdGlvbiBhcyBhIHF1YXRlcm5pb25cbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiBnZXRSb3RhdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLk5PX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3RyYW5zZm9ybUlEKS5nZXRSb3RhdGlvbigpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHJldHVybiBUcmFuc2Zvcm1TeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0Um90YXRpb24oKTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgdHJhbnNmb3JtIGNvbXBvbmVudCcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzY2FsZSBvZiB0aGUgbm9kZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IGFuIGFycmF5IHNob3dpbmcgdGhlIGN1cnJlbnQgc2NhbGUgdmVjdG9yXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFNjYWxlID0gZnVuY3Rpb24gZ2V0U2NhbGUgKCkge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCh0aGlzLl90cmFuc2Zvcm1JRCkuZ2V0U2NhbGUoKTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICByZXR1cm4gVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLmdldFNjYWxlKCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHRyYW5zZm9ybSBjb21wb25lbnQnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBzaXplIG1vZGUgb2YgdGhlIG5vZGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSBhbiBhcnJheSBvZiBudW1iZXJzIHNob3dpbmcgdGhlIGN1cnJlbnQgc2l6ZSBtb2RlXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFNpemVNb2RlID0gZnVuY3Rpb24gZ2V0U2l6ZU1vZGUgKCkge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCh0aGlzLl9zaXplSUQpLmdldFNpemVNb2RlKCk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgcmV0dXJuIFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0U2l6ZU1vZGUoKTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgc2l6ZSBjb21wb25lbnQnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBwcm9wb3J0aW9uYWwgc2l6ZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IGEgdmVjdG9yIDMgc2hvd2luZyB0aGUgY3VycmVudCBwcm9wb3J0aW9uYWwgc2l6ZVxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRQcm9wb3J0aW9uYWxTaXplID0gZnVuY3Rpb24gZ2V0UHJvcG9ydGlvbmFsU2l6ZSAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLk5PX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3NpemVJRCkuZ2V0UHJvcG9ydGlvbmFsKCk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgcmV0dXJuIFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0UHJvcG9ydGlvbmFsKCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHNpemUgY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGRpZmZlcmVudGlhbCBzaXplIG9mIHRoZSBub2RlXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gYSB2ZWN0b3IgMyBzaG93aW5nIHRoZSBjdXJyZW50IGRpZmZlcmVudGlhbCBzaXplXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldERpZmZlcmVudGlhbFNpemUgPSBmdW5jdGlvbiBnZXREaWZmZXJlbnRpYWxTaXplICgpIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuTk9fREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQodGhpcy5fc2l6ZUlEKS5nZXREaWZmZXJlbnRpYWwoKTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICByZXR1cm4gU2l6ZVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5nZXREaWZmZXJlbnRpYWwoKTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgc2l6ZSBjb21wb25lbnQnKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWJzb2x1dGUgc2l6ZSBvZiB0aGUgbm9kZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IGEgdmVjdG9yIDMgc2hvd2luZyB0aGUgY3VycmVudCBhYnNvbHV0ZSBzaXplIG9mIHRoZSBub2RlXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldEFic29sdXRlU2l6ZSA9IGZ1bmN0aW9uIGdldEFic29sdXRlU2l6ZSAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLk5PX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3NpemVJRCkuZ2V0QWJzb2x1dGUoKTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICByZXR1cm4gU2l6ZVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5nZXRBYnNvbHV0ZSgpO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSBzaXplIGNvbXBvbmVudCcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IFJlbmRlciBTaXplIG9mIHRoZSBub2RlLiBOb3RlIHRoYXQgdGhlIHJlbmRlciBzaXplXG4gKiBpcyBhc3luY2hyb25vdXMgKHdpbGwgYWx3YXlzIGJlIG9uZSBmcmFtZSBiZWhpbmQpIGFuZCBuZWVkcyB0byBiZSBleHBsaWNpdGVseVxuICogY2FsY3VsYXRlZCBieSBzZXR0aW5nIHRoZSBwcm9wZXIgc2l6ZSBtb2RlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IGEgdmVjdG9yIDMgc2hvd2luZyB0aGUgY3VycmVudCByZW5kZXIgc2l6ZVxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRSZW5kZXJTaXplID0gZnVuY3Rpb24gZ2V0UmVuZGVyU2l6ZSAoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLk5PX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3NpemVJRCkuZ2V0UmVuZGVyKCk7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgcmV0dXJuIFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuZ2V0UmVuZGVyKCk7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHNpemUgY29tcG9uZW50Jyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGV4dGVybmFsIHNpemUgb2YgdGhlIG5vZGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSBhIHZlY3RvciAzIG9mIHRoZSBmaW5hbCBjYWxjdWxhdGVkIHNpZGUgb2YgdGhlIG5vZGVcbiAqL1xuTm9kZS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uIGdldFNpemUgKCkge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCh0aGlzLl9zaXplSUQpLmdldCgpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHJldHVybiBTaXplU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLmdldCgpO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSBzaXplIGNvbXBvbmVudCcpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjdXJyZW50IHdvcmxkIHRyYW5zZm9ybSBvZiB0aGUgbm9kZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IGEgMTYgdmFsdWUgdHJhbnNmb3JtXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGdldFRyYW5zZm9ybSAoKSB7XG4gICAgcmV0dXJuIFRyYW5zZm9ybVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKTtcbn07XG5cbi8qKlxuICogR2V0IHRoZSBsaXN0IG9mIHRoZSBVSSBFdmVudHMgdGhhdCBhcmUgY3VycmVudGx5IGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7QXJyYXl9IGFuIGFycmF5IG9mIHN0cmluZ3MgcmVwcmVzZW50aW5nIHRoZSBjdXJyZW50IHN1YnNjcmliZWQgVUkgZXZlbnQgb2YgdGhpcyBub2RlXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldFVJRXZlbnRzID0gZnVuY3Rpb24gZ2V0VUlFdmVudHMgKCkge1xuICAgIHJldHVybiB0aGlzLl9VSUV2ZW50cztcbn07XG5cbi8qKlxuICogQWRkcyBhIG5ldyBjaGlsZCB0byB0aGlzIG5vZGUuIElmIHRoaXMgbWV0aG9kIGlzIGNhbGxlZCB3aXRoIG5vIGFyZ3VtZW50IGl0IHdpbGxcbiAqIGNyZWF0ZSBhIG5ldyBub2RlLCBob3dldmVyIGl0IGNhbiBhbHNvIGJlIGNhbGxlZCB3aXRoIGFuIGV4aXN0aW5nIG5vZGUgd2hpY2ggaXQgd2lsbFxuICogYXBwZW5kIHRvIHRoZSBub2RlIHRoYXQgdGhpcyBtZXRob2QgaXMgYmVpbmcgY2FsbGVkIG9uLiBSZXR1cm5zIHRoZSBuZXcgb3IgcGFzc2VkIGluIG5vZGUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7Tm9kZSB8IHZvaWR9IGNoaWxkIHRoZSBub2RlIHRvIGFwcGVuZGVkIG9yIG5vIG5vZGUgdG8gY3JlYXRlIGEgbmV3IG5vZGUuXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhlIGFwcGVuZGVkIG5vZGUuXG4gKi9cbk5vZGUucHJvdG90eXBlLmFkZENoaWxkID0gZnVuY3Rpb24gYWRkQ2hpbGQgKGNoaWxkKSB7XG4gICAgdmFyIGluZGV4ID0gY2hpbGQgPyB0aGlzLl9jaGlsZHJlbi5pbmRleE9mKGNoaWxkKSA6IC0xO1xuICAgIGNoaWxkID0gY2hpbGQgPyBjaGlsZCA6IG5ldyBOb2RlKCk7XG5cbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgIGluZGV4ID0gdGhpcy5fZnJlZWRDaGlsZEluZGljaWVzLmxlbmd0aCA/XG4gICAgICAgICAgICAgICAgdGhpcy5fZnJlZWRDaGlsZEluZGljaWVzLnBvcCgpIDogdGhpcy5fY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2luZGV4XSA9IGNoaWxkO1xuICAgICAgICB0aGlzLl9mdWxsQ2hpbGRyZW4ucHVzaChjaGlsZCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIGNoaWxkLm1vdW50KHRoaXMuZ2V0TG9jYXRpb24oKSArICcvJyArIGluZGV4KTtcblxuICAgIHJldHVybiBjaGlsZDtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyBhIGNoaWxkIG5vZGUgZnJvbSBhbm90aGVyIG5vZGUuIFRoZSBwYXNzZWQgaW4gbm9kZSBtdXN0IGJlXG4gKiBhIGNoaWxkIG9mIHRoZSBub2RlIHRoYXQgdGhpcyBtZXRob2QgaXMgY2FsbGVkIHVwb24uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gY2hpbGQgbm9kZSB0byBiZSByZW1vdmVkXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIG5vZGUgd2FzIHN1Y2Nlc3NmdWxseSByZW1vdmVkXG4gKi9cbk5vZGUucHJvdG90eXBlLnJlbW92ZUNoaWxkID0gZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKGNoaWxkKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fY2hpbGRyZW4uaW5kZXhPZihjaGlsZCk7XG5cbiAgICBpZiAoaW5kZXggPiAtIDEpIHtcbiAgICAgICAgdGhpcy5fZnJlZWRDaGlsZEluZGljaWVzLnB1c2goaW5kZXgpO1xuXG4gICAgICAgIHRoaXMuX2NoaWxkcmVuW2luZGV4XSA9IG51bGw7XG5cbiAgICAgICAgaWYgKGNoaWxkLmlzTW91bnRlZCgpKSBjaGlsZC5kaXNtb3VudCgpO1xuXG4gICAgICAgIHZhciBmdWxsQ2hpbGRyZW5JbmRleCA9IHRoaXMuX2Z1bGxDaGlsZHJlbi5pbmRleE9mKGNoaWxkKTtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuX2Z1bGxDaGlsZHJlbi5sZW5ndGg7XG4gICAgICAgIHZhciBpID0gMDtcblxuICAgICAgICBmb3IgKGkgPSBmdWxsQ2hpbGRyZW5JbmRleDsgaSA8IGxlbi0xOyBpKyspXG4gICAgICAgICAgICB0aGlzLl9mdWxsQ2hpbGRyZW5baV0gPSB0aGlzLl9mdWxsQ2hpbGRyZW5baSArIDFdO1xuXG4gICAgICAgIHRoaXMuX2Z1bGxDaGlsZHJlbi5wb3AoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYWxsIGNoaWxkcmVuIG5vZGVzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbm9kZXMgd2VyZSBzdWNjZXNzZnVsbHkgcmVtb3ZlZFxuICovXG5Ob2RlLnByb3RvdHlwZS5yZW1vdmVBbGxDaGlsZHJlbiA9IGZ1bmN0aW9uIHJlbW92ZUFsbENoaWxkcmVuICgpIHtcbiAgICB2YXIgY2hlY2sgPSB0cnVlO1xuICAgIHZhciBjaGlsZHJlbiA9IHRoaXMuZ2V0Q2hpbGRyZW4oKTtcbiAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjaGVjayA9IGNoZWNrICYmIHRoaXMucmVtb3ZlQ2hpbGQoY2hpbGRyZW5bMF0pO1xuICAgIH1cblxuICAgIHJldHVybiBjaGVjaztcbn07XG5cbi8qKlxuICogRWFjaCBjb21wb25lbnQgY2FuIG9ubHkgYmUgYWRkZWQgb25jZSBwZXIgbm9kZS5cbiAqXG4gKiBAbWV0aG9kIGFkZENvbXBvbmVudFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgICAgQSBjb21wb25lbnQgdG8gYmUgYWRkZWQuXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGluZGV4ICAgICAgIFRoZSBpbmRleCBhdCB3aGljaCB0aGUgY29tcG9uZW50IGhhcyBiZWVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQuIEluZGljZXMgYXJlbid0IG5lY2Vzc2FyaWx5XG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNlY3V0aXZlLlxuICovXG5Ob2RlLnByb3RvdHlwZS5hZGRDb21wb25lbnQgPSBmdW5jdGlvbiBhZGRDb21wb25lbnQgKGNvbXBvbmVudCkge1xuICAgIHZhciBpbmRleCA9IHRoaXMuX2NvbXBvbmVudHMuaW5kZXhPZihjb21wb25lbnQpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgaW5kZXggPSB0aGlzLl9mcmVlZENvbXBvbmVudEluZGljaWVzLmxlbmd0aCA/IHRoaXMuX2ZyZWVkQ29tcG9uZW50SW5kaWNpZXMucG9wKCkgOiB0aGlzLl9jb21wb25lbnRzLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fY29tcG9uZW50c1tpbmRleF0gPSBjb21wb25lbnQ7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNNb3VudGVkKCkgJiYgY29tcG9uZW50Lm9uTW91bnQpXG4gICAgICAgICAgICBjb21wb25lbnQub25Nb3VudCh0aGlzLCBpbmRleCk7XG5cbiAgICAgICAgaWYgKHRoaXMuaXNTaG93bigpICYmIGNvbXBvbmVudC5vblNob3cpXG4gICAgICAgICAgICBjb21wb25lbnQub25TaG93KCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGluZGV4O1xufTtcblxuLyoqXG4gKiBAbWV0aG9kICBnZXRDb21wb25lbnRcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4ICAgSW5kZXggYXQgd2hpY2ggdGhlIGNvbXBvbmVudCBoYXMgYmVlbiByZWdpc3RlcmVkXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgKHVzaW5nIGBOb2RlI2FkZENvbXBvbmVudGApLlxuICogQHJldHVybiB7Kn0gICAgICAgICAgICAgIFRoZSBjb21wb25lbnQgcmVnaXN0ZXJlZCBhdCB0aGUgcGFzc2VkIGluIGluZGV4IChpZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgIGFueSkuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldENvbXBvbmVudCA9IGZ1bmN0aW9uIGdldENvbXBvbmVudCAoaW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50c1tpbmRleF07XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBwcmV2aW91c2x5IHZpYSB7QGxpbmsgTm9kZSNhZGRDb21wb25lbnR9IGFkZGVkIGNvbXBvbmVudC5cbiAqXG4gKiBAbWV0aG9kIHJlbW92ZUNvbXBvbmVudFxuICpcbiAqIEBwYXJhbSAge09iamVjdH0gY29tcG9uZW50ICAgQW4gY29tcG9uZW50IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBhZGRlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2luZyB7QGxpbmsgTm9kZSNhZGRDb21wb25lbnR9LlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUucmVtb3ZlQ29tcG9uZW50ID0gZnVuY3Rpb24gcmVtb3ZlQ29tcG9uZW50IChjb21wb25lbnQpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX2ZyZWVkQ29tcG9uZW50SW5kaWNpZXMucHVzaChpbmRleCk7XG4gICAgICAgIGlmICh0aGlzLmlzU2hvd24oKSAmJiBjb21wb25lbnQub25IaWRlKVxuICAgICAgICAgICAgY29tcG9uZW50Lm9uSGlkZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmlzTW91bnRlZCgpICYmIGNvbXBvbmVudC5vbkRpc21vdW50KVxuICAgICAgICAgICAgY29tcG9uZW50Lm9uRGlzbW91bnQoKTtcblxuICAgICAgICB0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjb21wb25lbnQ7XG59O1xuXG4vKipcbiAqIFJlbW92ZXMgYSBub2RlJ3Mgc3Vic2NyaXB0aW9uIHRvIGEgcGFydGljdWxhciBVSUV2ZW50LiBBbGwgY29tcG9uZW50c1xuICogb24gdGhlIG5vZGUgd2lsbCBoYXZlIHRoZSBvcHBvcnR1bml0eSB0byByZW1vdmUgYWxsIGxpc3RlbmVycyBkZXBlbmRpbmdcbiAqIG9uIHRoaXMgZXZlbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuTm9kZS5wcm90b3R5cGUucmVtb3ZlVUlFdmVudCA9IGZ1bmN0aW9uIHJlbW92ZVVJRXZlbnQgKGV2ZW50TmFtZSkge1xuICAgIHZhciBVSUV2ZW50cyA9IHRoaXMuZ2V0VUlFdmVudHMoKTtcbiAgICB2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHM7XG4gICAgdmFyIGNvbXBvbmVudDtcblxuICAgIHZhciBpbmRleCA9IFVJRXZlbnRzLmluZGV4T2YoZXZlbnROYW1lKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIFVJRXZlbnRzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgICAgIGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5vblJlbW92ZVVJRXZlbnQpIGNvbXBvbmVudC5vblJlbW92ZVVJRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogU3Vic2NyaWJlcyBhIG5vZGUgdG8gYSBVSSBFdmVudC4gQWxsIGNvbXBvbmVudHMgb24gdGhlIG5vZGVcbiAqIHdpbGwgaGF2ZSB0aGUgb3Bwb3J0dW5pdHkgdG8gYmVnaW4gbGlzdGVuaW5nIHRvIHRoYXQgZXZlbnRcbiAqIGFuZCBhbGVydGluZyB0aGUgc2NlbmUgZ3JhcGguXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudE5hbWUgdGhlIG5hbWUgb2YgdGhlIGV2ZW50XG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5hZGRVSUV2ZW50ID0gZnVuY3Rpb24gYWRkVUlFdmVudCAoZXZlbnROYW1lKSB7XG4gICAgdmFyIFVJRXZlbnRzID0gdGhpcy5nZXRVSUV2ZW50cygpO1xuICAgIHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cztcbiAgICB2YXIgY29tcG9uZW50O1xuXG4gICAgdmFyIGFkZGVkID0gVUlFdmVudHMuaW5kZXhPZihldmVudE5hbWUpICE9PSAtMTtcbiAgICBpZiAoIWFkZGVkKSB7XG4gICAgICAgIFVJRXZlbnRzLnB1c2goZXZlbnROYW1lKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgY29tcG9uZW50ID0gY29tcG9uZW50c1tpXTtcbiAgICAgICAgICAgIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50Lm9uQWRkVUlFdmVudCkgY29tcG9uZW50Lm9uQWRkVUlFdmVudChldmVudE5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIGZvciB0aGUgTm9kZSB0byByZXF1ZXN0IGFuIHVwZGF0ZSBmb3IgaXRzZWxmLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBmb3JjZSB3aGV0aGVyIG9yIG5vdCB0byBmb3JjZSB0aGUgdXBkYXRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuTm9kZS5wcm90b3R5cGUuX3JlcXVlc3RVcGRhdGUgPSBmdW5jdGlvbiBfcmVxdWVzdFVwZGF0ZSAoZm9yY2UpIHtcbiAgICBpZiAoZm9yY2UgfHwgIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3VwZGF0ZXIpXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVyLnJlcXVlc3RVcGRhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSB0cnVlO1xuICAgIH1cbn07XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gc2V0IGFuIG9wdGlvbmFsIHZhbHVlIGluIGFuIGFycmF5LCBhbmRcbiAqIHJlcXVlc3QgYW4gdXBkYXRlIGlmIHRoaXMgY2hhbmdlcyB0aGUgdmFsdWUgb2YgdGhlIGFycmF5LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSB2ZWMgdGhlIGFycmF5IHRvIGluc2VydCB0aGUgdmFsdWUgaW50b1xuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IHRoZSBpbmRleCBhdCB3aGljaCB0byBpbnNlcnQgdGhlIHZhbHVlXG4gKiBAcGFyYW0ge0FueX0gdmFsIHRoZSB2YWx1ZSB0byBwb3RlbnRpYWxseSBpbnNlcnQgKGlmIG5vdCBudWxsIG9yIHVuZGVmaW5lZClcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCBhIG5ldyB2YWx1ZSB3YXMgaW5zZXJ0ZWQuXG4gKi9cbk5vZGUucHJvdG90eXBlLl92ZWNPcHRpb25hbFNldCA9IGZ1bmN0aW9uIF92ZWNPcHRpb25hbFNldCAodmVjLCBpbmRleCwgdmFsKSB7XG4gICAgaWYgKHZhbCAhPSBudWxsICYmIHZlY1tpbmRleF0gIT09IHZhbCkge1xuICAgICAgICB2ZWNbaW5kZXhdID0gdmFsO1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2hvd3MgdGhlIG5vZGUsIHdoaWNoIGlzIHRvIHNheSwgY2FsbHMgb25TaG93IG9uIGFsbCBvZiB0aGVcbiAqIG5vZGUncyBjb21wb25lbnRzLiBSZW5kZXJhYmxlIGNvbXBvbmVudHMgY2FuIHRoZW4gaXNzdWUgdGhlXG4gKiBkcmF3IGNvbW1hbmRzIG5lY2Vzc2FyeSB0byBiZSBzaG93bi5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5zaG93ID0gZnVuY3Rpb24gc2hvdyAoKSB7XG4gICAgcmV0dXJuIERpc3BhdGNoLnNob3codGhpcy5faWQpO1xufTtcblxuLyoqXG4gKiBIaWRlcyB0aGUgbm9kZSwgd2hpY2ggaXMgdG8gc2F5LCBjYWxscyBvbkhpZGUgb24gYWxsIG9mIHRoZVxuICogbm9kZSdzIGNvbXBvbmVudHMuIFJlbmRlcmFibGUgY29tcG9uZW50cyBjYW4gdGhlbiBpc3N1ZVxuICogdGhlIGRyYXcgY29tbWFuZHMgbmVjZXNzYXJ5IHRvIGJlIGhpZGRlblxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiBoaWRlICgpIHtcbiAgICByZXR1cm4gRGlzcGF0Y2guaGlkZSh0aGlzLl9pZCk7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGFsaWduIHZhbHVlIG9mIHRoZSBub2RlLiBXaWxsIGNhbGwgb25BbGlnbkNoYW5nZVxuICogb24gYWxsIG9mIHRoZSBOb2RlJ3MgY29tcG9uZW50cy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggQWxpZ24gdmFsdWUgaW4gdGhlIHggZGltZW5zaW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgQWxpZ24gdmFsdWUgaW4gdGhlIHkgZGltZW5zaW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogQWxpZ24gdmFsdWUgaW4gdGhlIHogZGltZW5zaW9uLlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0QWxpZ24gPSBmdW5jdGlvbiBzZXRBbGlnbiAoeCwgeSwgeikge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3RyYW5zZm9ybUlEKS5zZXRBbGlnbih4LCB5LCB6KTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICBUcmFuc2Zvcm1TeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuc2V0QWxpZ24oeCwgeSwgeik7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHRyYW5zZm9ybSBjb21wb25lbnQnKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbW91bnQgcG9pbnQgdmFsdWUgb2YgdGhlIG5vZGUuIFdpbGwgY2FsbCBvbk1vdW50UG9pbnRDaGFuZ2VcbiAqIG9uIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IE1vdW50UG9pbnQgdmFsdWUgaW4geCBkaW1lbnNpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IE1vdW50UG9pbnQgdmFsdWUgaW4geSBkaW1lbnNpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IE1vdW50UG9pbnQgdmFsdWUgaW4geiBkaW1lbnNpb25cbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldE1vdW50UG9pbnQgPSBmdW5jdGlvbiBzZXRNb3VudFBvaW50ICh4LCB5LCB6KSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLk5PX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQodGhpcy5fdHJhbnNmb3JtSUQpLnNldE1vdW50UG9pbnQoeCwgeSwgeik7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldE1vdW50UG9pbnQoeCwgeSwgeik7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHRyYW5zZm9ybSBjb21wb25lbnQnKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgb3JpZ2luIHZhbHVlIG9mIHRoZSBub2RlLiBXaWxsIGNhbGwgb25PcmlnaW5DaGFuZ2VcbiAqIG9uIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IE9yaWdpbiB2YWx1ZSBpbiB4IGRpbWVuc2lvblxuICogQHBhcmFtIHtOdW1iZXJ9IHkgT3JpZ2luIHZhbHVlIGluIHkgZGltZW5zaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geiBPcmlnaW4gdmFsdWUgaW4geiBkaW1lbnNpb25cbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldE9yaWdpbiA9IGZ1bmN0aW9uIHNldE9yaWdpbiAoeCwgeSwgeikge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3RyYW5zZm9ybUlEKS5zZXRPcmlnaW4oeCwgeSwgeik7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldE9yaWdpbih4LCB5LCB6KTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgdHJhbnNmb3JtIGNvbXBvbmVudCcpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgbm9kZS4gV2lsbCBjYWxsIG9uUG9zaXRpb25DaGFuZ2VcbiAqIG9uIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFBvc2l0aW9uIGluIHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFBvc2l0aW9uIGluIHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFBvc2l0aW9uIGluIHpcbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24gKHgsIHksIHopIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuTk9fREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl90cmFuc2Zvcm1JRCkuc2V0UG9zaXRpb24oeCwgeSwgeik7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldFBvc2l0aW9uKHgsIHksIHopO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSB0cmFuc2Zvcm0gY29tcG9uZW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHJvdGF0aW9uIG9mIHRoZSBub2RlLiBXaWxsIGNhbGwgb25Sb3RhdGlvbkNoYW5nZVxuICogb24gYWxsIG9mIHRoZSBub2RlJ3MgY29tcG9uZW50cy4gVGhpcyBtZXRob2QgdGFrZXMgZWl0aGVyXG4gKiBFdWxlciBhbmdsZXMgb3IgYSBxdWF0ZXJuaW9uLiBJZiB0aGUgZm91cnRoIGFyZ3VtZW50IGlzIHVuZGVmaW5lZFxuICogRXVsZXIgYW5nbGVzIGFyZSBhc3N1bWVkLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBFaXRoZXIgdGhlIHJvdGF0aW9uIGFyb3VuZCB0aGUgeCBheGlzIG9yIHRoZSBtYWduaXR1ZGUgaW4geCBvZiB0aGUgYXhpcyBvZiByb3RhdGlvbi5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IEVpdGhlciB0aGUgcm90YXRpb24gYXJvdW5kIHRoZSB5IGF4aXMgb3IgdGhlIG1hZ25pdHVkZSBpbiB5IG9mIHRoZSBheGlzIG9mIHJvdGF0aW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogRWl0aGVyIHRoZSByb3RhdGlvbiBhcm91bmQgdGhlIHogYXhpcyBvciB0aGUgbWFnbml0dWRlIGluIHogb2YgdGhlIGF4aXMgb2Ygcm90YXRpb24uXG4gKiBAcGFyYW0ge051bWJlcnx1bmRlZmluZWR9IHcgdGhlIGFtb3VudCBvZiByb3RhdGlvbiBhcm91bmQgdGhlIGF4aXMgb2Ygcm90YXRpb24sIGlmIGEgcXVhdGVybmlvbiBpcyBzcGVjaWZpZWQuXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uIHNldFJvdGF0aW9uICh4LCB5LCB6LCB3KSB7XG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLk5PX0RFRkFVTFRfQ09NUE9ORU5UUylcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQodGhpcy5fdHJhbnNmb3JtSUQpLnNldFJvdGF0aW9uKHgsIHksIHosIHcpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIFRyYW5zZm9ybVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5zZXRSb3RhdGlvbih4LCB5LCB6LCB3KTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgdHJhbnNmb3JtIGNvbXBvbmVudCcpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBzY2FsZSBvZiB0aGUgbm9kZS4gVGhlIGRlZmF1bHQgdmFsdWUgaXMgMSBpbiBhbGwgZGltZW5zaW9ucy5cbiAqIFRoZSBub2RlJ3MgY29tcG9uZW50cyB3aWxsIGhhdmUgb25TY2FsZUNoYW5nZWQgY2FsbGVkIG9uIHRoZW0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFNjYWxlIHZhbHVlIGluIHhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFNjYWxlIHZhbHVlIGluIHlcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFNjYWxlIHZhbHVlIGluIHpcbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gc2V0U2NhbGUgKHgsIHksIHopIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuTk9fREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl90cmFuc2Zvcm1JRCkuc2V0U2NhbGUoeCwgeSwgeik7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgVHJhbnNmb3JtU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldFNjYWxlKHgsIHksIHopO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYSB0cmFuc2Zvcm0gY29tcG9uZW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIHZhbHVlIG9mIHRoZSBvcGFjaXR5IG9mIHRoaXMgbm9kZS4gQWxsIG9mIHRoZSBub2RlJ3NcbiAqIGNvbXBvbmVudHMgd2lsbCBoYXZlIG9uT3BhY2l0eUNoYW5nZSBjYWxsZWQgb24gdGhlbS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHZhbD0xIFZhbHVlIG9mIHRoZSBvcGFjaXR5LiAxIGlzIHRoZSBkZWZhdWx0LlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIHNldE9wYWNpdHkgKHZhbCkge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX29wYWNpdHlJRCkuc2V0T3BhY2l0eSh2YWwpO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIE9wYWNpdHlTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuc2V0T3BhY2l0eSh2YWwpO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG5vZGUgZG9lcyBub3QgaGF2ZSBhY2Nlc3MgdG8gYW4gb3BhY2l0eSBjb21wb25lbnQnKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc2l6ZSBtb2RlIGJlaW5nIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBub2RlJ3MgZmluYWwgd2lkdGgsIGhlaWdodFxuICogYW5kIGRlcHRoLlxuICogU2l6ZSBtb2RlcyBhcmUgYSB3YXkgdG8gZGVmaW5lIHRoZSB3YXkgdGhlIG5vZGUncyBzaXplIGlzIGJlaW5nIGNhbGN1bGF0ZWQuXG4gKiBTaXplIG1vZGVzIGFyZSBlbnVtcyBzZXQgb24gdGhlIHtAbGluayBTaXplfSBjb25zdHJ1Y3RvciAoYW5kIGFsaWFzZWQgb25cbiAqIHRoZSBOb2RlKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogbm9kZS5zZXRTaXplTW9kZShOb2RlLlJFTEFUSVZFX1NJWkUsIE5vZGUuQUJTT0xVVEVfU0laRSwgTm9kZS5BQlNPTFVURV9TSVpFKTtcbiAqIC8vIEluc3RlYWQgb2YgbnVsbCwgYW55IHByb3BvcnRpb25hbCBoZWlnaHQgb3IgZGVwdGggY2FuIGJlIHBhc3NlZCBpbiwgc2luY2VcbiAqIC8vIGl0IHdvdWxkIGJlIGlnbm9yZWQgaW4gYW55IGNhc2UuXG4gKiBub2RlLnNldFByb3BvcnRpb25hbFNpemUoMC41LCBudWxsLCBudWxsKTtcbiAqIG5vZGUuc2V0QWJzb2x1dGVTaXplKG51bGwsIDEwMCwgMjAwKTtcbiAqXG4gKiBAbWV0aG9kIHNldFNpemVNb2RlXG4gKlxuICogQHBhcmFtIHtTaXplTW9kZX0geCAgICBUaGUgc2l6ZSBtb2RlIGJlaW5nIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBzaXplIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHggZGlyZWN0aW9uIChcIndpZHRoXCIpLlxuICogQHBhcmFtIHtTaXplTW9kZX0geSAgICBUaGUgc2l6ZSBtb2RlIGJlaW5nIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBzaXplIGluXG4gKiAgICAgICAgICAgICAgICAgICAgICAgIHkgZGlyZWN0aW9uIChcImhlaWdodFwiKS5cbiAqIEBwYXJhbSB7U2l6ZU1vZGV9IHogICAgVGhlIHNpemUgbW9kZSBiZWluZyB1c2VkIGZvciBkZXRlcm1pbmluZyB0aGUgc2l6ZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgICB6IGRpcmVjdGlvbiAoXCJkZXB0aFwiKS5cbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldFNpemVNb2RlID0gZnVuY3Rpb24gc2V0U2l6ZU1vZGUgKHgsIHksIHopIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuTk9fREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl9zaXplSUQpLnNldFNpemVNb2RlKHgsIHksIHopO1xuICAgIGVsc2UgaWYgKHRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIFNpemVTeXN0ZW0uZ2V0KHRoaXMuZ2V0TG9jYXRpb24oKSkuc2V0U2l6ZU1vZGUoeCwgeSwgeik7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgbm9kZSBkb2VzIG5vdCBoYXZlIGFjY2VzcyB0byBhIHNpemUgY29tcG9uZW50Jyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEEgcHJvcG9ydGlvbmFsIHNpemUgZGVmaW5lcyB0aGUgbm9kZSdzIGRpbWVuc2lvbnMgcmVsYXRpdmUgdG8gaXRzIHBhcmVudHNcbiAqIGZpbmFsIHNpemUuXG4gKiBQcm9wb3J0aW9uYWwgc2l6ZXMgbmVlZCB0byBiZSB3aXRoaW4gdGhlIHJhbmdlIG9mIFswLCAxXS5cbiAqXG4gKiBAbWV0aG9kIHNldFByb3BvcnRpb25hbFNpemVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCAgICB4LVNpemUgaW4gcGl4ZWxzIChcIndpZHRoXCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgICAgeS1TaXplIGluIHBpeGVscyAoXCJoZWlnaHRcIikuXG4gKiBAcGFyYW0ge051bWJlcn0geiAgICB6LVNpemUgaW4gcGl4ZWxzIChcImRlcHRoXCIpLlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0UHJvcG9ydGlvbmFsU2l6ZSA9IGZ1bmN0aW9uIHNldFByb3BvcnRpb25hbFNpemUgKHgsIHksIHopIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuTk9fREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl9zaXplSUQpLnNldFByb3BvcnRpb25hbCh4LCB5LCB6KTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICBTaXplU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldFByb3BvcnRpb25hbCh4LCB5LCB6KTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgc2l6ZSBjb21wb25lbnQnKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGlmZmVyZW50aWFsIHNpemluZyBjYW4gYmUgdXNlZCB0byBhZGQgb3Igc3VidHJhY3QgYW4gYWJzb2x1dGUgc2l6ZSBmcm9tIGFuXG4gKiBvdGhlcndpc2UgcHJvcG9ydGlvbmFsbHkgc2l6ZWQgbm9kZS5cbiAqIEUuZy4gYSBkaWZmZXJlbnRpYWwgd2lkdGggb2YgYC0xMGAgYW5kIGEgcHJvcG9ydGlvbmFsIHdpZHRoIG9mIGAwLjVgIGlzXG4gKiBiZWluZyBpbnRlcnByZXRlZCBhcyBzZXR0aW5nIHRoZSBub2RlJ3Mgc2l6ZSB0byA1MCUgb2YgaXRzIHBhcmVudCdzIHdpZHRoXG4gKiAqbWludXMqIDEwIHBpeGVscy5cbiAqXG4gKiBAbWV0aG9kIHNldERpZmZlcmVudGlhbFNpemVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCAgICB4LVNpemUgdG8gYmUgYWRkZWQgdG8gdGhlIHJlbGF0aXZlbHkgc2l6ZWQgbm9kZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzIChcIndpZHRoXCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHkgICAgeS1TaXplIHRvIGJlIGFkZGVkIHRvIHRoZSByZWxhdGl2ZWx5IHNpemVkIG5vZGUgaW5cbiAqICAgICAgICAgICAgICAgICAgICAgIHBpeGVscyAoXCJoZWlnaHRcIikuXG4gKiBAcGFyYW0ge051bWJlcn0geiAgICB6LVNpemUgdG8gYmUgYWRkZWQgdG8gdGhlIHJlbGF0aXZlbHkgc2l6ZWQgbm9kZSBpblxuICogICAgICAgICAgICAgICAgICAgICAgcGl4ZWxzIChcImRlcHRoXCIpLlxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUuc2V0RGlmZmVyZW50aWFsU2l6ZSA9IGZ1bmN0aW9uIHNldERpZmZlcmVudGlhbFNpemUgKHgsIHksIHopIHtcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuTk9fREVGQVVMVF9DT01QT05FTlRTKVxuICAgICAgICB0aGlzLmdldENvbXBvbmVudCh0aGlzLl9zaXplSUQpLnNldERpZmZlcmVudGlhbCh4LCB5LCB6KTtcbiAgICBlbHNlIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICBTaXplU3lzdGVtLmdldCh0aGlzLmdldExvY2F0aW9uKCkpLnNldERpZmZlcmVudGlhbCh4LCB5LCB6KTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgc2l6ZSBjb21wb25lbnQnKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbm9kZSdzIHNpemUgaW4gcGl4ZWxzLCBpbmRlcGVuZGVudCBvZiBpdHMgcGFyZW50LlxuICpcbiAqIEBtZXRob2Qgc2V0QWJzb2x1dGVTaXplXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggeC1TaXplIGluIHBpeGVscyAoXCJ3aWR0aFwiKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IHktU2l6ZSBpbiBwaXhlbHMgKFwiaGVpZ2h0XCIpLlxuICogQHBhcmFtIHtOdW1iZXJ9IHogei1TaXplIGluIHBpeGVscyAoXCJkZXB0aFwiKS5cbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnNldEFic29sdXRlU2l6ZSA9IGZ1bmN0aW9uIHNldEFic29sdXRlU2l6ZSAoeCwgeSwgeikge1xuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpXG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3NpemVJRCkuc2V0QWJzb2x1dGUoeCwgeSwgeik7XG4gICAgZWxzZSBpZiAodGhpcy5pc01vdW50ZWQoKSlcbiAgICAgICAgU2l6ZVN5c3RlbS5nZXQodGhpcy5nZXRMb2NhdGlvbigpKS5zZXRBYnNvbHV0ZSh4LCB5LCB6KTtcbiAgICBlbHNlIHRocm93IG5ldyBFcnJvcignVGhpcyBub2RlIGRvZXMgbm90IGhhdmUgYWNjZXNzIHRvIGEgc2l6ZSBjb21wb25lbnQnKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogTWV0aG9kIGZvciBnZXR0aW5nIHRoZSBjdXJyZW50IGZyYW1lLiBXaWxsIGJlIGRlcHJlY2F0ZWQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gY3VycmVudCBmcmFtZVxuICovXG5Ob2RlLnByb3RvdHlwZS5nZXRGcmFtZSA9IGZ1bmN0aW9uIGdldEZyYW1lICgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXBkYXRlci5nZXRGcmFtZSgpO1xufTtcblxuLyoqXG4gKiByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSBjb21wb25lbnRzIGN1cnJlbnRseSBhdHRhY2hlZCB0byB0aGlzXG4gKiBub2RlLlxuICpcbiAqIEBtZXRob2QgZ2V0Q29tcG9uZW50c1xuICpcbiAqIEByZXR1cm4ge0FycmF5fSBsaXN0IG9mIGNvbXBvbmVudHMuXG4gKi9cbk5vZGUucHJvdG90eXBlLmdldENvbXBvbmVudHMgPSBmdW5jdGlvbiBnZXRDb21wb25lbnRzICgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50cztcbn07XG5cbi8qKlxuICogRW50ZXJzIHRoZSBub2RlJ3MgdXBkYXRlIHBoYXNlIHdoaWxlIHVwZGF0aW5nIGl0cyBvd24gc3BlYyBhbmQgdXBkYXRpbmcgaXRzIGNvbXBvbmVudHMuXG4gKlxuICogQG1ldGhvZCB1cGRhdGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IHRpbWUgICAgaGlnaC1yZXNvbHV0aW9uIHRpbWVzdGFtcCwgdXN1YWxseSByZXRyaWV2ZWQgdXNpbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAqXG4gKiBAcmV0dXJuIHtOb2RlfSB0aGlzXG4gKi9cbk5vZGUucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSAodGltZSl7XG4gICAgdGhpcy5faW5VcGRhdGUgPSB0cnVlO1xuICAgIHZhciBuZXh0UXVldWUgPSB0aGlzLl9uZXh0VXBkYXRlUXVldWU7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fdXBkYXRlUXVldWU7XG4gICAgdmFyIGl0ZW07XG5cbiAgICB3aGlsZSAobmV4dFF1ZXVlLmxlbmd0aCkgcXVldWUudW5zaGlmdChuZXh0UXVldWUucG9wKCkpO1xuXG4gICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBpdGVtID0gdGhpcy5fY29tcG9uZW50c1txdWV1ZS5zaGlmdCgpXTtcbiAgICAgICAgaWYgKGl0ZW0gJiYgaXRlbS5vblVwZGF0ZSkgaXRlbS5vblVwZGF0ZSh0aW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pblVwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3JlcXVlc3RpbmdVcGRhdGUgPSBmYWxzZTtcblxuICAgIGlmICghdGhpcy5pc01vdW50ZWQoKSkge1xuICAgICAgICAvLyBsYXN0IHVwZGF0ZVxuICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xuICAgICAgICB0aGlzLl9pZCA9IG51bGw7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX25leHRVcGRhdGVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlci5yZXF1ZXN0VXBkYXRlT25OZXh0VGljayh0aGlzKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNb3VudHMgdGhlIG5vZGUgYW5kIHRoZXJlZm9yZSBpdHMgc3VidHJlZSBieSBzZXR0aW5nIGl0IGFzIGEgY2hpbGQgb2YgdGhlXG4gKiBwYXNzZWQgaW4gcGFyZW50LlxuICpcbiAqIEBtZXRob2QgbW91bnRcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggdW5pcXVlIHBhdGggb2Ygbm9kZSAoZS5nLiBgYm9keS8wLzFgKVxuICpcbiAqIEByZXR1cm4ge05vZGV9IHRoaXNcbiAqL1xuTm9kZS5wcm90b3R5cGUubW91bnQgPSBmdW5jdGlvbiBtb3VudCAocGF0aCkge1xuICAgIGlmICh0aGlzLmlzTW91bnRlZCgpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vZGUgaXMgYWxyZWFkeSBtb3VudGVkIGF0OiAnICsgdGhpcy5nZXRMb2NhdGlvbigpKTtcblxuICAgIGlmICghdGhpcy5jb25zdHJ1Y3Rvci5OT19ERUZBVUxUX0NPTVBPTkVOVFMpe1xuICAgICAgICBUcmFuc2Zvcm1TeXN0ZW0ucmVnaXN0ZXJUcmFuc2Zvcm1BdFBhdGgocGF0aCwgdGhpcy5nZXRDb21wb25lbnQodGhpcy5fdHJhbnNmb3JtSUQpKTtcbiAgICAgICAgT3BhY2l0eVN5c3RlbS5yZWdpc3Rlck9wYWNpdHlBdFBhdGgocGF0aCwgdGhpcy5nZXRDb21wb25lbnQodGhpcy5fb3BhY2l0eUlEKSk7XG4gICAgICAgIFNpemVTeXN0ZW0ucmVnaXN0ZXJTaXplQXRQYXRoKHBhdGgsIHRoaXMuZ2V0Q29tcG9uZW50KHRoaXMuX3NpemVJRCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgVHJhbnNmb3JtU3lzdGVtLnJlZ2lzdGVyVHJhbnNmb3JtQXRQYXRoKHBhdGgpO1xuICAgICAgICBPcGFjaXR5U3lzdGVtLnJlZ2lzdGVyT3BhY2l0eUF0UGF0aChwYXRoKTtcbiAgICAgICAgU2l6ZVN5c3RlbS5yZWdpc3RlclNpemVBdFBhdGgocGF0aCk7XG4gICAgfVxuICAgIERpc3BhdGNoLm1vdW50KHBhdGgsIHRoaXMpO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG5cbn07XG5cbi8qKlxuICogRGlzbW91bnRzIChkZXRhY2hlcykgdGhlIG5vZGUgZnJvbSB0aGUgc2NlbmUgZ3JhcGggYnkgcmVtb3ZpbmcgaXQgYXMgYVxuICogY2hpbGQgb2YgaXRzIHBhcmVudC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7Tm9kZX0gdGhpc1xuICovXG5Ob2RlLnByb3RvdHlwZS5kaXNtb3VudCA9IGZ1bmN0aW9uIGRpc21vdW50ICgpIHtcbiAgICBpZiAoIXRoaXMuaXNNb3VudGVkKCkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm9kZSBpcyBub3QgbW91bnRlZCcpO1xuXG4gICAgdmFyIHBhdGggPSB0aGlzLmdldExvY2F0aW9uKCk7XG5cbiAgICBUcmFuc2Zvcm1TeXN0ZW0uZGVyZWdpc3RlclRyYW5zZm9ybUF0UGF0aChwYXRoKTtcbiAgICBTaXplU3lzdGVtLmRlcmVnaXN0ZXJTaXplQXRQYXRoKHBhdGgpO1xuICAgIE9wYWNpdHlTeXN0ZW0uZGVyZWdpc3Rlck9wYWNpdHlBdFBhdGgocGF0aCk7XG4gICAgRGlzcGF0Y2guZGlzbW91bnQocGF0aCk7XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTm9kZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gT3BhY2l0eSAocGFyZW50KSB7XG4gICAgdGhpcy5sb2NhbCA9IDE7XG4gICAgdGhpcy5nbG9iYWwgPSAxO1xuICAgIHRoaXMub3BhY2l0eSA9IDE7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgPyBwYXJlbnQgOiBudWxsO1xuICAgIHRoaXMuYnJlYWtQb2ludCA9IGZhbHNlO1xuICAgIHRoaXMuY2FsY3VsYXRpbmdXb3JsZE9wYWNpdHkgPSBmYWxzZTtcbn1cblxuT3BhY2l0eS5XT1JMRF9DSEFOR0VEID0gMTtcbk9wYWNpdHkuTE9DQUxfQ0hBTkdFRCA9IDI7XG5cbk9wYWNpdHkucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gcmVzZXQgKCkge1xuICAgIHRoaXMucGFyZW50ID0gbnVsbDtcbiAgICB0aGlzLmJyZWFrUG9pbnQgPSBmYWxzZTtcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIHNldFBhcmVudCAocGFyZW50KSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG59O1xuXG5PcGFjaXR5LnByb3RvdHlwZS5nZXRQYXJlbnQgPSBmdW5jdGlvbiBnZXRQYXJlbnQgKCkge1xuICAgIHJldHVybiB0aGlzLnBhcmVudDtcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLnNldEJyZWFrUG9pbnQgPSBmdW5jdGlvbiBzZXRCcmVha1BvaW50ICgpIHtcbiAgICB0aGlzLmJyZWFrUG9pbnQgPSB0cnVlO1xuICAgIHRoaXMuY2FsY3VsYXRpbmdXb3JsZE9wYWNpdHkgPSB0cnVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhpcyBub2RlIHRvIGNhbGN1bGF0ZSB0aGUgd29ybGQgb3BhY2l0eS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuT3BhY2l0eS5wcm90b3R5cGUuc2V0Q2FsY3VsYXRlV29ybGRPcGFjaXR5ID0gZnVuY3Rpb24gc2V0Q2FsY3VsYXRlV29ybGRPcGFjaXR5ICgpIHtcbiAgICB0aGlzLmNhbGN1bGF0aW5nV29ybGRPcGFjaXR5ID0gdHJ1ZTtcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLmlzQnJlYWtQb2ludCA9IGZ1bmN0aW9uIGlzQnJlYWtQb2ludCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnJlYWtQb2ludDtcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLmdldExvY2FsT3BhY2l0eSA9IGZ1bmN0aW9uIGdldExvY2FsT3BhY2l0eSAoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWw7XG59O1xuXG5PcGFjaXR5LnByb3RvdHlwZS5nZXRXb3JsZE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRXb3JsZE9wYWNpdHkgKCkge1xuICAgIGlmICghdGhpcy5pc0JyZWFrUG9pbnQoKSAmJiAhdGhpcy5jYWxjdWxhdGluZ1dvcmxkT3BhY2l0eSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIG9wYWNpdHkgaXMgbm90IGNhbGN1bGF0aW5nIHdvcmxkIHRyYW5zZm9ybXMnKTtcbiAgICByZXR1cm4gdGhpcy5nbG9iYWw7XG59O1xuXG5PcGFjaXR5LnByb3RvdHlwZS5jYWxjdWxhdGUgPSBmdW5jdGlvbiBjYWxjdWxhdGUgKG5vZGUpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50IHx8IHRoaXMucGFyZW50LmlzQnJlYWtQb2ludCgpKVxuICAgICAgICByZXR1cm4gdGhpcy5mcm9tTm9kZShub2RlKTtcbiAgICBlbHNlIHJldHVybiB0aGlzLmZyb21Ob2RlV2l0aFBhcmVudChub2RlKTtcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLmdldE9wYWNpdHkgPSBmdW5jdGlvbiBnZXRPcGFjaXR5ICgpIHtcbiAgICByZXR1cm4gdGhpcy5vcGFjaXR5O1xufTtcblxuT3BhY2l0eS5wcm90b3R5cGUuc2V0T3BhY2l0eSA9IGZ1bmN0aW9uIHNldE9wYWNpdHkgKG9wYWNpdHkpIHtcbiAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xufTtcblxuT3BhY2l0eS5wcm90b3R5cGUuY2FsY3VsYXRlV29ybGRPcGFjaXR5ID0gZnVuY3Rpb24gY2FsY3VsYXRlV29ybGRPcGFjaXR5ICgpIHtcbiAgICB2YXIgbmVhcmVzdEJyZWFrUG9pbnQgPSB0aGlzLnBhcmVudDtcblxuICAgIHZhciBwcmV2aW91c0dsb2JhbCA9IHRoaXMuZ2xvYmFsO1xuXG4gICAgd2hpbGUgKG5lYXJlc3RCcmVha1BvaW50ICYmICFuZWFyZXN0QnJlYWtQb2ludC5pc0JyZWFrUG9pbnQoKSlcbiAgICAgICAgbmVhcmVzdEJyZWFrUG9pbnQgPSBuZWFyZXN0QnJlYWtQb2ludC5wYXJlbnQ7XG5cbiAgICBpZiAobmVhcmVzdEJyZWFrUG9pbnQpIHtcbiAgICAgICAgdGhpcy5nbG9iYWwgPSBuZWFyZXN0QnJlYWtQb2ludC5nZXRXb3JsZE9wYWNpdHkoKSAqIHRoaXMubG9jYWw7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmdsb2JhbCA9IHRoaXMubG9jYWw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHByZXZpb3VzR2xvYmFsICE9PSB0aGlzLmdsb2JhbDtcbn07XG5cbk9wYWNpdHkucHJvdG90eXBlLmZyb21Ob2RlID0gZnVuY3Rpb24gZnJvbU5vZGUgKCkge1xuICAgIHZhciBjaGFuZ2VkID0gMDtcblxuICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IHRoaXMubG9jYWwpXG4gICAgICAgIGNoYW5nZWQgfD0gT3BhY2l0eS5MT0NBTF9DSEFOR0VEO1xuXG4gICAgdGhpcy5sb2NhbCA9IHRoaXMub3BhY2l0eTtcblxuICAgIGlmICh0aGlzLmNhbGN1bGF0aW5nV29ybGRPcGFjaXR5ICYmIHRoaXMuY2FsY3VsYXRlV29ybGRPcGFjaXR5KCkpXG4gICAgICAgIGNoYW5nZWQgfD0gT3BhY2l0eS5XT1JMRF9DSEFOR0VEO1xuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59O1xuXG5PcGFjaXR5LnByb3RvdHlwZS5mcm9tTm9kZVdpdGhQYXJlbnQgPSBmdW5jdGlvbiBmcm9tTm9kZVdpdGhQYXJlbnQgKCkge1xuICAgIHZhciBjaGFuZ2VkID0gMDtcblxuICAgIHZhciBwcmV2aW91c0xvY2FsID0gdGhpcy5sb2NhbDtcblxuICAgIHRoaXMubG9jYWwgPSB0aGlzLnBhcmVudC5nZXRMb2NhbE9wYWNpdHkoKSAqIHRoaXMub3BhY2l0eTtcblxuICAgIGlmICh0aGlzLmNhbGN1bGF0aW5nV29ybGRPcGFjaXR5ICYmIHRoaXMuY2FsY3VsYXRlV29ybGRPcGFjaXR5KCkpXG4gICAgICAgIGNoYW5nZWQgfD0gT3BhY2l0eS5XT1JMRF9DSEFOR0VEO1xuXG4gICAgaWYgKHByZXZpb3VzTG9jYWwgIT09IHRoaXMubG9jYWwpXG4gICAgICAgIGNoYW5nZWQgfD0gT3BhY2l0eS5MT0NBTF9DSEFOR0VEO1xuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9wYWNpdHk7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGgnKTtcbnZhciBPcGFjaXR5ID0gcmVxdWlyZSgnLi9PcGFjaXR5Jyk7XG52YXIgRGlzcGF0Y2ggPSByZXF1aXJlKCcuL0Rpc3BhdGNoJyk7XG52YXIgU3lzdGVtID0gcmVxdWlyZSgnLi9TeXN0ZW0nKTtcblxuLyoqXG4gKiBUaGUgb3BhY2l0eSBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgY2FsY3VsYXRpbmcgdGhlIG9wYWNpdHkgb2YgYSBwYXJ0aWN1bGFyXG4gKiBub2RlIGZyb20gdGhlIGRhdGEgb24gdGhlIG5vZGUgYW5kIGl0cyBwYXJlbnRcbiAqXG4gKiBAY29uc3RydWN0b3Ige09wYWNpdHlTeXN0ZW19XG4gKi9cbmZ1bmN0aW9uIE9wYWNpdHlTeXN0ZW0gKCkge1xuICAgIFN5c3RlbS5jYWxsKHRoaXMpO1xufVxuXG5PcGFjaXR5U3lzdGVtLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3lzdGVtLnByb3RvdHlwZSk7XG5PcGFjaXR5U3lzdGVtLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IE9wYWNpdHlTeXN0ZW07XG5cbi8qKlxuICogcmVnaXN0ZXJzIGEgbmV3IE9wYWNpdHkgZm9yIHRoZSBnaXZlbiBwYXRoLiBUaGlzIG9wYWNpdHkgd2lsbCBiZSB1cGRhdGVkXG4gKiB3aGVuIHRoZSBPcGFjaXR5U3lzdGVtIHVwZGF0ZXMuXG4gKlxuICogQG1ldGhvZCByZWdpc3Rlck9wYWNpdHlBdFBhdGhcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBwYXRoIGZvciB0aGUgb3BhY2l0eSB0byBiZSByZWdpc3RlcmVkIHRvLlxuICogQHBhcmFtIHtPcGFjaXR5fSBbb3BhY2l0eV0gb3BhY2l0eSB0byByZWdpc3Rlci5cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbk9wYWNpdHlTeXN0ZW0ucHJvdG90eXBlLnJlZ2lzdGVyT3BhY2l0eUF0UGF0aCA9IGZ1bmN0aW9uIHJlZ2lzdGVyT3BhY2l0eUF0UGF0aCAocGF0aCwgb3BhY2l0eSkge1xuICAgIGlmICghUGF0aFV0aWxzLmRlcHRoKHBhdGgpKSByZXR1cm4gdGhpcy5pbnNlcnQocGF0aCwgb3BhY2l0eSA/IG9wYWNpdHkgOiBuZXcgT3BhY2l0eSgpKTtcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldChQYXRoVXRpbHMucGFyZW50KHBhdGgpKTtcblxuICAgIGlmICghcGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnTm8gcGFyZW50IG9wYWNpdHkgcmVnaXN0ZXJlZCBhdCBleHBlY3RlZCBwYXRoOiAnICsgUGF0aFV0aWxzLnBhcmVudChwYXRoKVxuICAgICk7XG5cbiAgICBpZiAob3BhY2l0eSkgb3BhY2l0eS5zZXRQYXJlbnQocGFyZW50KTtcblxuICAgIHRoaXMuaW5zZXJ0KHBhdGgsIG9wYWNpdHkgPyBvcGFjaXR5IDogbmV3IE9wYWNpdHkocGFyZW50KSk7XG59O1xuXG4vKipcbiAqIERlcmVnaXN0ZXJzIGEgb3BhY2l0eSByZWdpc3RlcmVkIGF0IHRoZSBnaXZlbiBwYXRoLlxuICpcbiAqIEBtZXRob2QgZGVyZWdpc3Rlck9wYWNpdHlBdFBhdGhcbiAqIEByZXR1cm4ge3ZvaWR9XG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggYXQgd2hpY2ggdG8gcmVnaXN0ZXIgdGhlIG9wYWNpdHlcbiAqL1xuT3BhY2l0eVN5c3RlbS5wcm90b3R5cGUuZGVyZWdpc3Rlck9wYWNpdHlBdFBhdGggPSBPcGFjaXR5U3lzdGVtLnByb3RvdHlwZS5yZW1vdmU7XG5cbi8qKlxuICogTWV0aG9kIHdoaWNoIHdpbGwgbWFrZSB0aGUgb3BhY2l0eSBjdXJyZW50bHkgc3RvcmVkIGF0IHRoZSBnaXZlbiBwYXRoIGEgYnJlYWtwb2ludC5cbiAqIEEgb3BhY2l0eSBiZWluZyBhIGJyZWFrcG9pbnQgbWVhbnMgdGhhdCBib3RoIGEgbG9jYWwgYW5kIHdvcmxkIG9wYWNpdHkgd2lsbCBiZSBjYWxjdWxhdGVkXG4gKiBmb3IgdGhhdCBwb2ludC4gVGhlIGxvY2FsIG9wYWNpdHkgYmVpbmcgdGhlIGNvbmNhdGluYXRlZCBvcGFjaXR5IG9mIGFsbCBhbmNlc3RvciBvcGFjaXRpZXMgdXBcbiAqIHVudGlsIHRoZSBuZWFyZXN0IGJyZWFrcG9pbnQsIGFuZCB0aGUgd29ybGQgYmVpbmcgdGhlIGNvbmNhdGluYXRlZCBvcGFjaXR5IG9mIGFsbCBhbmNlc3RvciBvcGFjaXRpZXMuXG4gKiBUaGlzIG1ldGhvZCB0aHJvd3MgaWYgbm8gb3BhY2l0eSBpcyBhdCB0aGUgcHJvdmlkZWQgcGF0aC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggYXQgd2hpY2ggdG8gdHVybiB0aGUgb3BhY2l0eSBpbnRvIGEgYnJlYWtwb2ludFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbk9wYWNpdHlTeXN0ZW0ucHJvdG90eXBlLm1ha2VCcmVha1BvaW50QXQgPSBmdW5jdGlvbiBtYWtlQnJlYWtQb2ludEF0IChwYXRoKSB7XG4gICAgdmFyIG9wYWNpdHkgPSB0aGlzLmdldChwYXRoKTtcbiAgICBpZiAoIW9wYWNpdHkpIHRocm93IG5ldyBFcnJvcignTm8gb3BhY2l0eSBSZWdpc3RlcmVkIGF0IHBhdGg6ICcgKyBwYXRoKTtcbiAgICBvcGFjaXR5LnNldEJyZWFrUG9pbnQoKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRoYXQgd2lsbCBtYWtlIHRoZSBvcGFjaXR5IGF0IHRoaXMgbG9jYXRpb24gY2FsY3VsYXRlIGEgd29ybGQgb3BhY2l0eS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggYXQgd2hpY2ggdG8gbWFrZSB0aGUgb3BhY2l0eSBjYWxjdWxhdGUgYSB3b3JsZCBtYXRyaXhcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5PcGFjaXR5U3lzdGVtLnByb3RvdHlwZS5tYWtlQ2FsY3VsYXRlV29ybGRPcGFjaXR5QXQgPSBmdW5jdGlvbiBtYWtlQ2FsY3VsYXRlV29ybGRPcGFjaXR5QXQgKHBhdGgpIHtcbiAgICB2YXIgb3BhY2l0eSA9IHRoaXMuZ2V0KHBhdGgpO1xuICAgIGlmICghb3BhY2l0eSkgdGhyb3cgbmV3IEVycm9yKCdObyBvcGFjaXR5IG9wYWNpdHkgYXQgcGF0aDogJyArIHBhdGgpO1xuICAgIG9wYWNpdHkuc2V0Q2FsY3VsYXRlV29ybGRPcGFjaXR5KCk7XG59O1xuXG4vKipcbiAqIHVwZGF0ZSBpcyBjYWxsZWQgd2hlbiB0aGUgb3BhY2l0eSBzeXN0ZW0gcmVxdWlyZXMgYW4gdXBkYXRlLlxuICogSXQgdHJhdmVyc2VzIHRoZSBvcGFjaXR5IGFycmF5IGFuZCBldmFsdWF0ZXMgdGhlIG5lY2Vzc2FyeSBvcGFjaXRpZXNcbiAqIGluIHRoZSBzY2VuZSBncmFwaCB3aXRoIHRoZSBpbmZvcm1hdGlvbiBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIG5vZGVcbiAqIGluIHRoZSBzY2VuZSBncmFwaFxuICpcbiAqIEBtZXRob2QgdXBkYXRlXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5PcGFjaXR5U3lzdGVtLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKCkge1xuICAgIHZhciBvcGFjaXRpZXMgPSB0aGlzLmdldEl0ZW1zKCk7XG4gICAgdmFyIHBhdGhzID0gdGhpcy5nZXRQYXRocygpO1xuICAgIHZhciBvcGFjaXR5O1xuICAgIHZhciBjaGFuZ2VkO1xuICAgIHZhciBub2RlO1xuICAgIHZhciBjb21wb25lbnRzO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IG9wYWNpdGllcy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBEaXNwYXRjaC5nZXROb2RlKHBhdGhzW2ldKTtcbiAgICAgICAgaWYgKCFub2RlKSBjb250aW51ZTtcbiAgICAgICAgY29tcG9uZW50cyA9IG5vZGUuZ2V0Q29tcG9uZW50cygpO1xuICAgICAgICBvcGFjaXR5ID0gb3BhY2l0aWVzW2ldO1xuXG4gICAgICAgIGlmICgoY2hhbmdlZCA9IG9wYWNpdHkuY2FsY3VsYXRlKCkpKSB7XG4gICAgICAgICAgICBvcGFjaXR5Q2hhbmdlZChub2RlLCBjb21wb25lbnRzLCBvcGFjaXR5KTtcbiAgICAgICAgICAgIGlmIChjaGFuZ2VkICYgT3BhY2l0eS5MT0NBTF9DSEFOR0VEKSBsb2NhbE9wYWNpdHlDaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIG9wYWNpdHkuZ2V0TG9jYWxPcGFjaXR5KCkpO1xuICAgICAgICAgICAgaWYgKGNoYW5nZWQgJiBPcGFjaXR5LldPUkxEX0NIQU5HRUQpIHdvcmxkT3BhY2l0eUNoYW5nZWQobm9kZSwgY29tcG9uZW50cywgb3BhY2l0eS5nZXRXb3JsZE9wYWNpdHkoKSk7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGNhbGwgd2hlbiBlaXRoZXIgdGhlIExvY2FsIG9yIFdvcmxkIE9wYWNpdHkgY2hhbmdlcy5cbiAqIFRyaWdnZXJzICdvbk9wYWNpdHlDaGFuZ2UnIG1ldGhvZHMgb24gdGhlIG5vZGUgYW5kIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHNcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0aGUgbm9kZSBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50cyB0aGUgY29tcG9uZW50cyBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtPcGFjaXR5fSBvcGFjaXR5IHRoZSBvcGFjaXR5IGNsYXNzIHRoYXQgY2hhbmdlZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIG9wYWNpdHlDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBvcGFjaXR5KSB7XG4gICAgaWYgKG5vZGUub25PcGFjaXR5Q2hhbmdlKSBub2RlLm9uT3BhY2l0eUNoYW5nZShvcGFjaXR5KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uT3BhY2l0eUNoYW5nZSlcbiAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25PcGFjaXR5Q2hhbmdlKG9wYWNpdHkpO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgbG9jYWwgb3BhY2l0eSBjaGFuZ2VzLiBUcmlnZ2VycyAnb25Mb2NhbE9wYWNpdHlDaGFuZ2UnIG1ldGhvZHNcbiAqIG9uIHRoZSBub2RlIGFuZCBhbGwgb2YgdGhlIG5vZGUncyBjb21wb25lbnRzXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdGhlIG5vZGUgb24gd2hpY2ggdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgdGhlIGNvbXBvbmVudHMgb24gd2hpY2ggdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7QXJyYXl9IG9wYWNpdHkgdGhlIGxvY2FsIG9wYWNpdHlcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBsb2NhbE9wYWNpdHlDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBvcGFjaXR5KSB7XG4gICAgaWYgKG5vZGUub25Mb2NhbE9wYWNpdHlDaGFuZ2UpIG5vZGUub25Mb2NhbE9wYWNpdHlDaGFuZ2Uob3BhY2l0eSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vbkxvY2FsT3BhY2l0eUNoYW5nZSlcbiAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25Mb2NhbE9wYWNpdHlDaGFuZ2Uob3BhY2l0eSk7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gY2FsbCB3aGVuIHRoZSB3b3JsZCBvcGFjaXR5IGNoYW5nZXMuIFRyaWdnZXJzICdvbldvcmxkT3BhY2l0eUNoYW5nZScgbWV0aG9kc1xuICogb24gdGhlIG5vZGUgYW5kIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHNcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0aGUgbm9kZSBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50cyB0aGUgY29tcG9uZW50cyBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtBcnJheX0gb3BhY2l0eSB0aGUgd29ybGQgb3BhY2l0eVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHdvcmxkT3BhY2l0eUNoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIG9wYWNpdHkpIHtcbiAgICBpZiAobm9kZS5vbldvcmxkT3BhY2l0eUNoYW5nZSkgbm9kZS5vbldvcmxkT3BhY2l0eUNoYW5nZShvcGFjaXR5KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uV29ybGRPcGFjaXR5Q2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbldvcmxkT3BhY2l0eUNoYW5nZShvcGFjaXR5KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgT3BhY2l0eVN5c3RlbSgpO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2Fzc2VydCcpO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiB1dGlsaXRpZXMgZm9yIGhhbmRsaW5nIHBhdGhzLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqL1xudmFyIFBhdGggPSB7XG5cbiAgICAvKipcbiAgICAgKiBkZXRlcm1pbmVzIGlmIHRoZSBwYXNzZWQgaW4gcGF0aCBoYXMgYSB0cmFpbGluZyBzbGFzaC4gUGF0aHMgb2YgdGhlIGZvcm1cbiAgICAgKiAnYm9keS8wLzEvJyByZXR1cm4gdHJ1ZSwgd2hpbGUgcGF0aHMgb2YgdGhlIGZvcm0gJ2JvZHkvMC8xJyByZXR1cm4gZmFsc2UuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aFxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIHBhdGggaGFzIGEgdHJhaWxpbmcgc2xhc2hcbiAgICAgKi9cbiAgICBoYXNUcmFpbGluZ1NsYXNoOiBmdW5jdGlvbiBoYXNUcmFpbGluZ1NsYXNoIChwYXRoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycsICdwYXRoIG5lZWRzIHRvIGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA9PT0gJy8nO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBkZXB0aCBpbiB0aGUgdHJlZSB0aGlzIHBhdGggcmVwcmVzZW50cy4gRXNzZW50aWFsbHkgY291bnRzXG4gICAgICogdGhlIHNsYXNoZXMgaWdub3JpbmcgYSB0cmFpbGluZyBzbGFzaC5cbiAgICAgKlxuICAgICAqIEBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBkZXB0aCBpbiB0aGUgdHJlZSB0aGF0IHRoaXMgcGF0aCByZXByZXNlbnRzXG4gICAgICovXG4gICAgZGVwdGg6IGZ1bmN0aW9uIGRlcHRoIChwYXRoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycsICdwYXRoIG5lZWRzIHRvIGJlIGEgc3RyaW5nJyk7XG5cbiAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgdmFyIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5oYXNUcmFpbGluZ1NsYXNoKHBhdGgpID8gbGVuZ3RoIC0gMSA6IGxlbmd0aDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykgY291bnQgKz0gcGF0aFtpXSA9PT0gJy8nID8gMSA6IDA7XG4gICAgICAgIHJldHVybiBjb3VudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhpcyBwYXRoIGluIHJlbGF0aW9uIHRvIGl0cyBzaWJsaW5ncy5cbiAgICAgKlxuICAgICAqIEBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSBpbmRleCBvZiB0aGlzIHBhdGggaW4gcmVsYXRpb24gdG8gaXRzIHNpYmxpbmdzLlxuICAgICAqL1xuICAgIGluZGV4OiBmdW5jdGlvbiBpbmRleCAocGF0aCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuXG4gICAgICAgIHZhciBsZW5ndGggPSBwYXRoLmxlbmd0aDtcbiAgICAgICAgdmFyIGxlbiA9IHRoaXMuaGFzVHJhaWxpbmdTbGFzaChwYXRoKSA/IGxlbmd0aCAtIDEgOiBsZW5ndGg7XG4gICAgICAgIHdoaWxlIChsZW4tLSkgaWYgKHBhdGhbbGVuXSA9PT0gJy8nKSBicmVhaztcbiAgICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlSW50KHBhdGguc3Vic3RyaW5nKGxlbiArIDEpKTtcbiAgICAgICAgcmV0dXJuIGlzTmFOKHJlc3VsdCkgPyAwIDogcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcGF0aCBhdCBhIHBhcnRpY3VsYXIgYnJlYWR0aCBpbiByZWxhdGlvbnNoaXBcbiAgICAgKiB0byBpdHMgc2libGluZ3NcbiAgICAgKlxuICAgICAqIEBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIHRoZSBwYXRoXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIHRoZSBicmVhZHRoIGF0IHdoaWNoIHRvIGZpbmQgdGhlIGluZGV4XG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9IGluZGV4IGF0IHRoZSBwYXJ0aWN1bGFyIGRlcHRoXG4gICAgICovXG4gICAgaW5kZXhBdERlcHRoOiBmdW5jdGlvbiBpbmRleEF0RGVwdGggKHBhdGgsIGRlcHRoKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50Jykge1xuICAgICAgICAgICAgYXNzZXJ0KHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJywgJ3BhdGggbmVlZHMgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgZGVwdGggPT09ICdudW1iZXInLCAnZGVwdGggbmVlZHMgdG8gYmUgYSBudW1iZXInKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IHBhdGgubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXggPSAwO1xuICAgICAgICBmb3IgKDsgaSA8IGxlbiA7IGkrKykge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0gPT09ICcvJykgaW5kZXgrKztcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gZGVwdGgpIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5zdWJzdHJpbmcoaSA/IGkgKyAxIDogaSk7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBwYXRoLmluZGV4T2YoJy8nKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gaW5kZXggPT09IC0xID8gcGF0aCA6IHBhdGguc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgICAgICAgICBpbmRleCA9IHBhcnNlSW50KHBhdGgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBpc05hTihpbmRleCkgPyBwYXRoIDogaW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogcmV0dXJucyB0aGUgcGF0aCBvZiB0aGUgcGFzc2VkIGluIHBhdGgncyBwYXJlbnQuXG4gICAgICpcbiAgICAgKiBAbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aFxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgcGF0aCBvZiB0aGUgcGFzc2VkIGluIHBhdGgncyBwYXJlbnRcbiAgICAgKi9cbiAgICBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudCAocGF0aCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuXG4gICAgICAgIHJldHVybiBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxhc3RJbmRleE9mKCcvJywgcGF0aC5sZW5ndGggLSAyKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgdGhlIGZpcnN0IGFyZ3VtZW50IHBhdGggaXMgdGhlIGRpcmVjdCBjaGlsZFxuICAgICAqIG9mIHRoZSBzZWNvbmQgYXJndW1lbnQgcGF0aC5cbiAgICAgKlxuICAgICAqIEBtZXRob2RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjaGlsZCB0aGUgcGF0aCB0aGF0IG1heSBiZSBhIGNoaWxkXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmVudCB0aGUgcGF0aCB0aGF0IG1heSBiZSBhIHBhcmVudFxuICAgICAqXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgdGhlIGZpcnN0IGFyZ3VtZW50IHBhdGggaXMgYSBjaGlsZCBvZiB0aGUgc2Vjb25kIGFyZ3VtZW50IHBhdGhcbiAgICAgKi9cbiAgICBpc0NoaWxkT2Y6IGZ1bmN0aW9uIGlzQ2hpbGRPZiAoY2hpbGQsIHBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnLCAnY2hpbGQgbmVlZHMgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJywgJ3BhcmVudCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuaXNEZXNjZW5kZW50T2YoY2hpbGQsIHBhcmVudCkgJiYgdGhpcy5kZXB0aChjaGlsZCkgPT09IHRoaXMuZGVwdGgocGFyZW50KSArIDE7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZmlyc3QgYXJndW1lbnQgcGF0aCBpcyBhIGRlc2NlbmRlbnQgb2YgdGhlIHNlY29uZCBhcmd1bWVudCBwYXRoLlxuICAgICAqXG4gICAgICogQG1ldGhvZFxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGNoaWxkIHBvdGVudGlhbCBkZXNjZW5kZW50IHBhdGhcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyZW50IHBvdGVudGlhbCBhbmNlc3RvciBwYXRoXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgcGF0aCBpcyBhIGRlc2NlbmRlbnRcbiAgICAgKi9cbiAgICBpc0Rlc2NlbmRlbnRPZjogZnVuY3Rpb24gaXNEZXNjZW5kZW50T2YoY2hpbGQsIHBhcmVudCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnLCAnY2hpbGQgbmVlZHMgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgcGFyZW50ID09PSAnc3RyaW5nJywgJ3BhcmVudCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNoaWxkID09PSBwYXJlbnQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2hpbGQgPSB0aGlzLmhhc1RyYWlsaW5nU2xhc2goY2hpbGQpID8gY2hpbGQgOiBjaGlsZCArICcvJztcbiAgICAgICAgcGFyZW50ID0gdGhpcy5oYXNUcmFpbGluZ1NsYXNoKHBhcmVudCkgPyBwYXJlbnQgOiBwYXJlbnQgKyAnLyc7XG4gICAgICAgIHJldHVybiB0aGlzLmRlcHRoKHBhcmVudCkgPCB0aGlzLmRlcHRoKGNoaWxkKSAmJiBjaGlsZC5pbmRleE9mKHBhcmVudCkgPT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIHJldHVybnMgdGhlIHNlbGVjdG9yIHBvcnRpb24gb2YgdGhlIHBhdGguXG4gICAgICpcbiAgICAgKiBAbWV0aG9kXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGF0aCB0aGUgcGF0aFxuICAgICAqXG4gICAgICogQHJldHVybiB7U3RyaW5nfSB0aGUgc2VsZWN0b3IgcG9ydGlvbiBvZiB0aGUgcGF0aC5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RvcjogZnVuY3Rpb24gZ2V0U2VsZWN0b3IocGF0aCkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgICAgICBhc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuXG4gICAgICAgIHZhciBpbmRleCA9IHBhdGguaW5kZXhPZignLycpO1xuICAgICAgICByZXR1cm4gaW5kZXggPT09IC0xID8gcGF0aCA6IHBhdGguc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUGF0aDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE5vZGUgPSByZXF1aXJlKCcuL05vZGUnKTtcbnZhciBEaXNwYXRjaCA9IHJlcXVpcmUoJy4vRGlzcGF0Y2gnKTtcbnZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4vQ29tbWFuZHMnKTtcbnZhciBUcmFuc2Zvcm1TeXN0ZW0gPSByZXF1aXJlKCcuL1RyYW5zZm9ybVN5c3RlbScpO1xudmFyIE9wYWNpdHlTeXN0ZW0gPSByZXF1aXJlKCcuL09wYWNpdHlTeXN0ZW0nKTtcbnZhciBTaXplU3lzdGVtID0gcmVxdWlyZSgnLi9TaXplU3lzdGVtJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2Fzc2VydCcpO1xuXG4vKipcbiAqIFNjZW5lIGlzIHRoZSBib3R0b20gb2YgdGhlIHNjZW5lIGdyYXBoLiBJdCBpcyBpdHMgb3duXG4gKiBwYXJlbnQgYW5kIHByb3ZpZGVzIHRoZSBnbG9iYWwgdXBkYXRlciB0byB0aGUgc2NlbmUgZ3JhcGguXG4gKlxuICogQGNsYXNzIFNjZW5lXG4gKiBAY29uc3RydWN0b3JcbiAqIEBleHRlbmRzIE5vZGVcbiAqL1xuZnVuY3Rpb24gU2NlbmUgKCkge1xuICAgIE5vZGUuY2FsbCh0aGlzKTtcbn1cblxuU2NlbmUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShOb2RlLnByb3RvdHlwZSk7XG5TY2VuZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTY2VuZTtcblxuU2NlbmUuTk9fREVGQVVMVF9DT01QT05FTlRTID0gdHJ1ZTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzZWxlY3RvciB0aGF0IHRoZSBjb250ZXh0IHdhcyBpbnN0YW50aWF0ZWQgd2l0aFxuICpcbiAqIEBhbGlhcyB7Tm9kZSNnZXRMb2NhdGlvbn1cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGRvbSBzZWxlY3RvclxuICovXG5TY2VuZS5wcm90b3R5cGUuZ2V0U2VsZWN0b3IgPSBOb2RlLnByb3RvdHlwZS5nZXRMb2NhdGlvbjtcblxuLyoqXG4gKiBSZWNlaXZlcyBhbiBldmVudC4gSWYgdGhlIGV2ZW50IGlzICdDT05URVhUX1JFU0laRScgaXQgc2V0cyB0aGUgc2l6ZSBvZiB0aGUgc2NlbmVcbiAqIGdyYXBoIHRvIHRoZSBwYXlsb2FkLCB3aGljaCBtdXN0IGJlIGFuIGFycmF5IG9mIG51bWJlcnMgb2YgYXQgbGVhc3RcbiAqIGxlbmd0aCB0aHJlZSByZXByZXNlbnRpbmcgdGhlIHBpeGVsIHNpemUgaW4gMyBkaW1lbnNpb25zLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgYmVpbmcgcmVjZWl2ZWRcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCB0aGUgb2JqZWN0IGJlaW5nIHNlbnRcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5TY2VuZS5wcm90b3R5cGUub25SZWNlaXZlID0gZnVuY3Rpb24gb25SZWNlaXZlIChldmVudCwgcGF5bG9hZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBldmVudCA9PT0gJ3N0cmluZycsICdldmVudCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuXG4gICAgLy8gVE9ETzogSW4gdGhlIGZ1dHVyZSB0aGUgZG9tIGVsZW1lbnQgdGhhdCB0aGUgY29udGV4dCBpcyBhdHRhY2hlZCB0b1xuICAgIC8vIHNob3VsZCBoYXZlIGEgcmVwcmVzZW50YXRpb24gYXMgYSBjb21wb25lbnQuIEl0IHdvdWxkIGJlIHJlbmRlciBzaXplZFxuICAgIC8vIGFuZCB0aGUgY29udGV4dCB3b3VsZCByZWNlaXZlIGl0cyBzaXplIHRoZSBzYW1lIHdheSB0aGF0IGFueSByZW5kZXIgc2l6ZVxuICAgIC8vIGNvbXBvbmVudCByZWNlaXZlcyBpdHMgc2l6ZS5cbiAgICBpZiAoZXZlbnQgPT09ICdDT05URVhUX1JFU0laRScpIHtcbiAgICAgICAgaWYgKHBheWxvYWQubGVuZ3RoIDwgMilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICAnQ09OVEVYVF9SRVNJWkVcXCdzIHBheWxvYWQgbmVlZHMgdG8gYmUgYXQgbGVhc3QgYSBwYWlyJyArXG4gICAgICAgICAgICAgICAgJyBvZiBwaXhlbCBzaXplcydcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgdGhpcy5zZXRTaXplTW9kZSgnYWJzb2x1dGUnLCAnYWJzb2x1dGUnLCAnYWJzb2x1dGUnKTtcbiAgICAgICAgdGhpcy5zZXRBYnNvbHV0ZVNpemUocGF5bG9hZFswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZFsyXSA/IHBheWxvYWRbMl0gOiAwKTtcblxuICAgICAgICB0aGlzLl91cGRhdGVyLm1lc3NhZ2UoQ29tbWFuZHMuV0lUSCkubWVzc2FnZSh0aGlzLl9pZCkubWVzc2FnZShDb21tYW5kcy5SRUFEWSk7XG4gICAgfVxufTtcblxuU2NlbmUucHJvdG90eXBlLm1vdW50ID0gZnVuY3Rpb24gbW91bnQgKHBhdGgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJywgJ3BhdGggbmVlZHMgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgYXNzZXJ0KCF0aGlzLmlzTW91bnRlZCgpLCAnc2NlbmUgbmVlZHMgdG8gYmUgZGlzbW91bnRlZCcpO1xuICAgIH1cblxuICAgIERpc3BhdGNoLm1vdW50KHBhdGgsIHRoaXMpO1xuXG4gICAgdGhpcy5fdXBkYXRlciAgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGEgcmVxdWVzdCBmb3IgdGhlIGRvbVxuICAgICAgICAubWVzc2FnZShDb21tYW5kcy5ORUVEX1NJWkVfRk9SKSAgLy8gc2l6ZSBvZiB0aGUgY29udGV4dCBzbyB0aGF0XG4gICAgICAgIC5tZXNzYWdlKHBhdGgpOyAgICAgICAgIC8vIHRoZSBzY2VuZSBncmFwaCBoYXMgYSB0b3RhbCBzaXplXG5cbiAgICB0aGlzLl9pZCA9IHBhdGg7XG4gICAgdGhpcy5fbW91bnRlZCA9IHRydWU7XG4gICAgdGhpcy5fcGFyZW50ID0gdGhpcztcbiAgICBUcmFuc2Zvcm1TeXN0ZW0ucmVnaXN0ZXJUcmFuc2Zvcm1BdFBhdGgocGF0aCk7XG4gICAgT3BhY2l0eVN5c3RlbS5yZWdpc3Rlck9wYWNpdHlBdFBhdGgocGF0aCk7XG4gICAgU2l6ZVN5c3RlbS5yZWdpc3RlclNpemVBdFBhdGgocGF0aCk7XG5cbiAgICAvLyB0aGUgY29udGV4dCBiZWdpbnMgc2hvd24gKGl0J3MgYWxyZWFkeSBwcmVzZW50IGluIHRoZSBkb20pXG4gICAgdGhpcy5zaG93KCk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNjZW5lO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL2Fzc2VydCcpO1xuXG52YXIgT05FUyA9IFsxLCAxLCAxXTtcbnZhciBaRVJPUyA9IFswLCAwLCAwXTtcblxuLyoqXG4gKiBUaGUgU2l6ZSBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcHJvY2Vzc2luZyBTaXplIGZyb20gYSBub2RlXG4gKiBAY29uc3RydWN0b3IgU2l6ZVxuICpcbiAqIEBwYXJhbSB7U2l6ZX0gcGFyZW50IHRoZSBwYXJlbnQgc2l6ZVxuICovXG5mdW5jdGlvbiBTaXplIChwYXJlbnQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydChwYXJlbnQgPT09IHVuZGVmaW5lZCB8fCBwYXJlbnQuY29uc3RydWN0b3IgPT09IFNpemUsICdwYXJlbnQgbmVlZHMgdG8gYmUgYSBTaXplIGluc3RhbmNlIG9yIHVuZGVmaW5lZCcpO1xuXG4gICAgdGhpcy5maW5hbFNpemUgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgIHRoaXMuc2l6ZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgIHRoaXMuc2l6ZU1vZGUgPSBuZXcgVWludDhBcnJheSgzKTtcbiAgICB0aGlzLnNpemVNb2RlQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5hYnNvbHV0ZVNpemUgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgIHRoaXMuYWJzb2x1dGVTaXplQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5wcm9wb3J0aW9uYWxTaXplID0gbmV3IEZsb2F0MzJBcnJheShPTkVTKTtcbiAgICB0aGlzLnByb3BvcnRpb25hbFNpemVDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB0aGlzLmRpZmZlcmVudGlhbFNpemUgPSBuZXcgRmxvYXQzMkFycmF5KDMpO1xuICAgIHRoaXMuZGlmZmVyZW50aWFsU2l6ZUNoYW5nZWQgPSBmYWxzZTtcblxuICAgIHRoaXMucmVuZGVyU2l6ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMyk7XG4gICAgdGhpcy5yZW5kZXJTaXplQ2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQgIT0gbnVsbCA/IHBhcmVudCA6IG51bGw7XG59XG5cbi8vIGFuIGVudW1lcmF0aW9uIG9mIHRoZSBkaWZmZXJlbnQgdHlwZXMgb2Ygc2l6ZSBtb2Rlc1xuU2l6ZS5SRUxBVElWRSA9IDA7XG5TaXplLkFCU09MVVRFID0gMTtcblNpemUuUkVOREVSID0gMjtcblNpemUuREVGQVVMVCA9IFNpemUuUkVMQVRJVkU7XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2Qgd2hpY2ggc2V0cyBhIHZhbHVlIHdpdGhpbiBhbiBhcnJheVxuICogYW5kIHJlcG9ydCBpZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHZlYyBUaGUgYXJyYXkgdG8gc2V0IHRoZSB2YWx1ZSBpblxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzZXQgdGhlIHZhbHVlXG4gKiBAcGFyYW0ge0FueX0gdmFsIElmIHRoZSB2YWwgaXMgdW5kZWZpbmVkIG9yIG51bGwsIG9yIGlmIHRoZSB2YWx1ZVxuICogICAgICAgICAgICAgICAgICBpcyB0aGUgc2FtZSBhcyB3aGF0IGlzIGFscmVhZHkgdGhlcmUsIHRoZW4gbm90aGluZ1xuICogICAgICAgICAgICAgICAgICBpcyBzZXQuXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gcmV0dXJucyB0cnVlIGlmIGFueXRoaW5nIGNoYW5nZWRcbiAqL1xuZnVuY3Rpb24gX3ZlY09wdGlvbmFsU2V0ICh2ZWMsIGluZGV4LCB2YWwpIHtcbiAgICBpZiAodmFsICE9IG51bGwgJiYgdmVjW2luZGV4XSAhPT0gdmFsKSB7XG4gICAgICAgIHZlY1tpbmRleF0gPSB2YWw7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2Qgd2hpY2ggc2V0cyB0aHJlZSB2YWx1ZXMgd2l0aGluIGFuIGFycmF5IG9mIHRocmVlXG4gKiB1c2luZyBfdmVjT3B0aW9uYWxTZXQuIFJldHVybnMgd2hldGhlciBhbnl0aGluZyBoYXMgY2hhbmdlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVjIFRoZSBhcnJheSB0byBzZXQgdGhlIHZhbHVlcyBvZlxuICogQHBhcmFtIHtBbnl9IHggVGhlIGZpcnN0IHZhbHVlIHRvIHNldCB3aXRoaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge0FueX0geSBUaGUgc2Vjb25kIHZhbHVlIHRvIHNldCB3aXRoaW4gdGhlIGFycmF5XG4gKiBAcGFyYW0ge0FueX0geiBUaGUgdGhpcmQgdmFsdWUgdG8gc2V0IHdpdGhpbiB0aGUgYXJyYXlcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIGFueXRoaW5nIGhhcyBjaGFuZ2VkXG4gKi9cbmZ1bmN0aW9uIHNldFZlYyAodmVjLCB4LCB5LCB6KSB7XG4gICAgdmFyIHByb3BhZ2F0ZSA9IGZhbHNlO1xuXG4gICAgcHJvcGFnYXRlID0gX3ZlY09wdGlvbmFsU2V0KHZlYywgMCwgeCkgfHwgcHJvcGFnYXRlO1xuICAgIHByb3BhZ2F0ZSA9IF92ZWNPcHRpb25hbFNldCh2ZWMsIDEsIHkpIHx8IHByb3BhZ2F0ZTtcbiAgICBwcm9wYWdhdGUgPSBfdmVjT3B0aW9uYWxTZXQodmVjLCAyLCB6KSB8fCBwcm9wYWdhdGU7XG5cbiAgICByZXR1cm4gcHJvcGFnYXRlO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGFsbG93IGZvciBwb2x5bW9ycGhpc20gaW4gdGhlIHNpemUgbW9kZSBzdWNoIHRoYXQgc3RyaW5nc1xuICogb3IgdGhlIG51bWJlcnMgZnJvbSB0aGUgZW51bWVyYXRpb24gY2FuIGJlIHVzZWQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsIFRoZSBTaXplIG1vZGUgdG8gcmVzb2x2ZS5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRoZSByZXNvbHZlZCBzaXplIG1vZGUgZnJvbSB0aGUgZW51bWVyYXRpb24uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVTaXplTW9kZSAodmFsKSB7XG4gICAgaWYgKHZhbC5jb25zdHJ1Y3RvciA9PT0gU3RyaW5nKSB7XG4gICAgICAgIHN3aXRjaCAodmFsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIGNhc2UgJ3JlbGF0aXZlJzpcbiAgICAgICAgICAgIGNhc2UgJ2RlZmF1bHQnOiByZXR1cm4gU2l6ZS5SRUxBVElWRTtcbiAgICAgICAgICAgIGNhc2UgJ2Fic29sdXRlJzogcmV0dXJuIFNpemUuQUJTT0xVVEU7XG4gICAgICAgICAgICBjYXNlICdyZW5kZXInOiByZXR1cm4gU2l6ZS5SRU5ERVI7XG4gICAgICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc2l6ZSBtb2RlOiAnICsgdmFsKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh2YWwgPCAwIHx8IHZhbCA+IFNpemUuUkVOREVSKSB0aHJvdyBuZXcgRXJyb3IoJ3Vua25vd24gc2l6ZSBtb2RlOiAnICsgdmFsKTtcbiAgICByZXR1cm4gdmFsO1xufVxuXG4vKipcbiAqIFNldHMgdGhlIHBhcmVudCBvZiB0aGlzIHNpemUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U2l6ZX0gcGFyZW50IFRoZSBwYXJlbnQgc2l6ZSBjb21wb25lbnRcbiAqXG4gKiBAcmV0dXJuIHtTaXplfSB0aGlzXG4gKi9cblNpemUucHJvdG90eXBlLnNldFBhcmVudCA9IGZ1bmN0aW9uIHNldFBhcmVudCAocGFyZW50KSB7XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCBvZiB0aGlzIHNpemUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm5zIHtTaXplfHVuZGVmaW5lZH0gdGhlIHBhcmVudCBpZiBvbmUgZXhpc3RzXG4gKi9cblNpemUucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uIGdldFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBzaXplIG1vZGUgb2YgdGhpcyBzaXplIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IHRoZSBzaXplIG1vZGUgdG8gdXNlIGZvciB0aGUgd2lkdGhcbiAqIEBwYXJhbSB7TnVtYmVyfSB5IHRoZSBzaXplIG1vZGUgdG8gdXNlIGZvciB0aGUgaGVpZ2h0XG4gKiBAcGFyYW0ge051bWJlcn0geiB0aGUgc2l6ZSBtb2RlIHRvIHVzZSBmb3IgdGhlIGRlcHRoXG4gKlxuICogQHJldHVybiB7YXJyYXl9IGFycmF5IG9mIHNpemUgbW9kZXNcbiAqL1xuU2l6ZS5wcm90b3R5cGUuc2V0U2l6ZU1vZGUgPSBmdW5jdGlvbiBzZXRTaXplTW9kZSAoeCwgeSwgeikge1xuICAgIGlmICh4ICE9IG51bGwpIHggPSByZXNvbHZlU2l6ZU1vZGUoeCk7XG4gICAgaWYgKHkgIT0gbnVsbCkgeSA9IHJlc29sdmVTaXplTW9kZSh5KTtcbiAgICBpZiAoeiAhPSBudWxsKSB6ID0gcmVzb2x2ZVNpemVNb2RlKHopO1xuICAgIHRoaXMuc2l6ZU1vZGVDaGFuZ2VkID0gc2V0VmVjKHRoaXMuc2l6ZU1vZGUsIHgsIHksIHopO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBzaXplIG1vZGUgb2YgdGhpcyBjb21wb25lbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0FycmF5fSB0aGUgY3VycmVudCBzaXplIG1vZGUgb2YgdGhlIHRoaXMuXG4gKi9cblNpemUucHJvdG90eXBlLmdldFNpemVNb2RlID0gZnVuY3Rpb24gZ2V0U2l6ZU1vZGUgKCkge1xuICAgIHJldHVybiB0aGlzLnNpemVNb2RlO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBhYnNvbHV0ZSBzaXplIG9mIHRoaXMgc2l6ZSByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggZGltZW5zaW9uIG9mIHRoZSBhYnNvbHV0ZSBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBkaW1lbnNpb24gb2YgdGhlIGFic29sdXRlIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGRpbWVuc2lvbiBvZiB0aGUgYWJzb2x1dGUgc2l6ZVxuICpcbiAqIEByZXR1cm4ge1NpemV9IHRoaXNcbiAqL1xuU2l6ZS5wcm90b3R5cGUuc2V0QWJzb2x1dGUgPSBmdW5jdGlvbiBzZXRBYnNvbHV0ZSAoeCwgeSwgeikge1xuICAgIHRoaXMuYWJzb2x1dGVTaXplQ2hhbmdlZCA9IHNldFZlYyh0aGlzLmFic29sdXRlU2l6ZSwgeCwgeSwgeik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGFic29sdXRlIHNpemUgb2YgdGhpcyBzaXplIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge2FycmF5fSBhcnJheSBvZiBhYnNvbHV0ZSBzaXplXG4gKi9cblNpemUucHJvdG90eXBlLmdldEFic29sdXRlID0gZnVuY3Rpb24gZ2V0QWJzb2x1dGUgKCkge1xuICAgIHJldHVybiB0aGlzLmFic29sdXRlU2l6ZTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcHJvcG9ydGlvbmFsIHNpemUgb2YgdGhpcyBzaXplIHJlcHJlc2VudGF0aW9uLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCBUaGUgeCBkaW1lbnNpb24gb2YgdGhlIHByb3BvcnRpb25hbCBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0geSBUaGUgeSBkaW1lbnNpb24gb2YgdGhlIHByb3BvcnRpb25hbCBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0geiBUaGUgeiBkaW1lbnNpb24gb2YgdGhlIHByb3BvcnRpb25hbCBzaXplXG4gKlxuICogQHJldHVybiB7U2l6ZX0gdGhpc1xuICovXG5TaXplLnByb3RvdHlwZS5zZXRQcm9wb3J0aW9uYWwgPSBmdW5jdGlvbiBzZXRQcm9wb3J0aW9uYWwgKHgsIHksIHopIHtcbiAgICB0aGlzLnByb3BvcnRpb25hbFNpemVDaGFuZ2VkID0gc2V0VmVjKHRoaXMucHJvcG9ydGlvbmFsU2l6ZSwgeCwgeSwgeik7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHByb3BvdGlvbmFsIHNpemUgb2YgdGhpcyBzaXplIHJlcHJlc2VudGF0aW9uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge2FycmF5fSBhcnJheSBvZiBwcm9wb3J0aW9uYWwgc2l6ZVxuICovXG5TaXplLnByb3RvdHlwZS5nZXRQcm9wb3J0aW9uYWwgPSBmdW5jdGlvbiBnZXRQcm9wb3J0aW9uYWwgKCkge1xuICAgIHJldHVybiB0aGlzLnByb3BvcnRpb25hbFNpemU7XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGRpZmZlcmVudGlhbCBzaXplIG9mIHRoaXMgc2l6ZSByZXByZXNlbnRhdGlvbi5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHggZGltZW5zaW9uIG9mIHRoZSBkaWZmZXJlbnRpYWwgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgZGltZW5zaW9uIG9mIHRoZSBkaWZmZXJlbnRpYWwgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHogVGhlIHogZGltZW5zaW9uIG9mIHRoZSBkaWZmZXJlbnRpYWwgc2l6ZVxuICpcbiAqIEByZXR1cm4ge1NpemV9IHRoaXNcbiAqL1xuU2l6ZS5wcm90b3R5cGUuc2V0RGlmZmVyZW50aWFsID0gZnVuY3Rpb24gc2V0RGlmZmVyZW50aWFsICh4LCB5LCB6KSB7XG4gICAgdGhpcy5kaWZmZXJlbnRpYWxTaXplQ2hhbmdlZCA9IHNldFZlYyh0aGlzLmRpZmZlcmVudGlhbFNpemUsIHgsIHksIHopO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBkaWZmZXJlbnRpYWwgc2l6ZSBvZiB0aGlzIHNpemUgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7YXJyYXl9IGFycmF5IG9mIGRpZmZlcmVudGlhbCBzaXplXG4gKi9cblNpemUucHJvdG90eXBlLmdldERpZmZlcmVudGlhbCA9IGZ1bmN0aW9uIGdldERpZmZlcmVudGlhbCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGlmZmVyZW50aWFsU2l6ZTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc2l6ZSBvZiB0aGlzIHNpemUgcmVwcmVzZW50YXRpb24uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGRpbWVuc2lvbiBvZiB0aGUgc2l6ZVxuICogQHBhcmFtIHtOdW1iZXJ9IHkgVGhlIHkgZGltZW5zaW9uIG9mIHRoZSBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0geiBUaGUgeiBkaW1lbnNpb24gb2YgdGhlIHNpemVcbiAqXG4gKiBAcmV0dXJuIHtTaXplfSB0aGlzXG4gKi9cblNpemUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZmluYWxTaXplO1xufTtcblxuLyoqXG4gKiBmcm9tU3BlY1dpdGhQYXJlbnQgdGFrZXMgdGhlIHBhcmVudCBub2RlJ3Mgc2l6ZSwgdGhlIHRhcmdldCBub2RlJ3Mgc3BlYyxcbiAqIGFuZCBhIHRhcmdldCBhcnJheSB0byB3cml0ZSB0by4gVXNpbmcgdGhlIG5vZGUncyBzaXplIG1vZGUgaXQgY2FsY3VsYXRlc1xuICogYSBmaW5hbCBzaXplIGZvciB0aGUgbm9kZSBmcm9tIHRoZSBub2RlJ3Mgc3BlYy4gUmV0dXJucyB3aGV0aGVyIG9yIG5vdFxuICogdGhlIGZpbmFsIHNpemUgaGFzIGNoYW5nZWQgZnJvbSBpdHMgbGFzdCB2YWx1ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50cyB0aGUgbm9kZSdzIGNvbXBvbmVudHNcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoZSBzaXplIG9mIHRoZSBub2RlIGhhcyBjaGFuZ2VkLlxuICovXG5TaXplLnByb3RvdHlwZS5mcm9tQ29tcG9uZW50cyA9IGZ1bmN0aW9uIGZyb21Db21wb25lbnRzIChjb21wb25lbnRzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQoQXJyYXkuaXNBcnJheShjb21wb25lbnRzKSwgJ2NvbXBvbmVudHMgbmVlZHMgdG8gYmUgYW4gYXJyYXknKTtcblxuICAgIHZhciBtb2RlID0gdGhpcy5zaXplTW9kZTtcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcy5maW5hbFNpemU7XG4gICAgdmFyIHBhcmVudFNpemUgPSB0aGlzLnBhcmVudCA/IHRoaXMucGFyZW50LmdldCgpIDogWkVST1M7XG4gICAgdmFyIHByZXY7XG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgbGVuID0gY29tcG9uZW50cy5sZW5ndGg7XG4gICAgdmFyIGo7XG4gICAgZm9yICh2YXIgaSA9IDAgOyBpIDwgMyA7IGkrKykge1xuICAgICAgICBwcmV2ID0gdGFyZ2V0W2ldO1xuICAgICAgICBzd2l0Y2ggKG1vZGVbaV0pIHtcbiAgICAgICAgICAgIGNhc2UgU2l6ZS5SRUxBVElWRTpcbiAgICAgICAgICAgICAgICB0YXJnZXRbaV0gPSBwYXJlbnRTaXplW2ldICogdGhpcy5wcm9wb3J0aW9uYWxTaXplW2ldICsgdGhpcy5kaWZmZXJlbnRpYWxTaXplW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTaXplLkFCU09MVVRFOlxuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IHRoaXMuYWJzb2x1dGVTaXplW2ldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBTaXplLlJFTkRFUjpcbiAgICAgICAgICAgICAgICB2YXIgY2FuZGlkYXRlO1xuICAgICAgICAgICAgICAgIHZhciBjb21wb25lbnQ7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxlbiA7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQgPSBjb21wb25lbnRzW2pdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50ICYmIGNvbXBvbmVudC5nZXRSZW5kZXJTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGUgPSBjb21wb25lbnQuZ2V0UmVuZGVyU2l6ZSgpW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gdGFyZ2V0W2ldIDwgY2FuZGlkYXRlIHx8IHRhcmdldFtpXSA9PT0gMCA/IGNhbmRpZGF0ZSA6IHRhcmdldFtpXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjaGFuZ2VkID0gY2hhbmdlZCB8fCBwcmV2ICE9PSB0YXJnZXRbaV07XG4gICAgfVxuICAgIHRoaXMuc2l6ZUNoYW5nZWQgPSBjaGFuZ2VkO1xuICAgIHJldHVybiBjaGFuZ2VkO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaXplO1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3lzdGVtID0gcmVxdWlyZSgnLi9TeXN0ZW0nKTtcbnZhciBTaXplID0gcmVxdWlyZSgnLi9TaXplJyk7XG52YXIgRGlzcGF0Y2ggPSByZXF1aXJlKCcuL0Rpc3BhdGNoJyk7XG52YXIgUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoJyk7XG52YXIgVHJhbnNmb3JtU3lzdGVtID0gcmVxdWlyZSgnLi9UcmFuc2Zvcm1TeXN0ZW0nKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvYXNzZXJ0Jyk7XG5cbi8qKlxuICogVGhlIHNpemUgc3lzdGVtIGlzIHVzZWQgdG8gY2FsY3VsYXRlIHNpemUgdGhyb3VnaG91dCB0aGUgc2NlbmUgZ3JhcGguXG4gKiBJdCBob2xkcyBzaXplIGNvbXBvbmVudHMgYW5kIG9wZXJhdGVzIHVwb24gdGhlbS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU2l6ZVN5c3RlbSAoKSB7XG4gICAgU3lzdGVtLmNhbGwodGhpcyk7XG59XG5cblNpemVTeXN0ZW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTeXN0ZW0ucHJvdG90eXBlKTtcblNpemVTeXN0ZW0ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gU2l6ZVN5c3RlbTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSBzaXplIGNvbXBvbmVudCB0byBhIGdpdmUgcGF0aC4gQSBzaXplIGNvbXBvbmVudCBjYW4gYmUgcGFzc2VkIGFzIHRoZSBzZWNvbmQgYXJndW1lbnRcbiAqIG9yIGEgZGVmYXVsdCBvbmUgd2lsbCBiZSBjcmVhdGVkLiBUaHJvd3MgaWYgbm8gc2l6ZSBjb21wb25lbnQgaGFzIGJlZW4gYWRkZWQgYXQgdGhlIHBhcmVudCBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCBhdCB3aGljaCB0byByZWdpc3RlciB0aGUgc2l6ZSBjb21wb25lbnRcbiAqIEBwYXJhbSB7U2l6ZSB8IHVuZGVmaW5lZH0gc2l6ZSBUaGUgc2l6ZSBjb21wb25lbnQgdG8gYmUgcmVnaXN0ZXJlZCBvciB1bmRlZmluZWQuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuU2l6ZVN5c3RlbS5wcm90b3R5cGUucmVnaXN0ZXJTaXplQXRQYXRoID0gZnVuY3Rpb24gcmVnaXN0ZXJTaXplQXRQYXRoIChwYXRoLCBzaXplKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycsICdwYXRoIG5lZWRzIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIGFzc2VydChzaXplID09PSB1bmRlZmluZWQgfHwgc2l6ZS5jb25zdHJ1Y3RvciA9PT0gU2l6ZSwgJ3NpemUgbmVlZHMgdG8gYmUgYSBTaXplIGluc3RhbmNlIG9yIHVuZGVmaW5lZCcpO1xuICAgIH1cblxuICAgIGlmICghUGF0aFV0aWxzLmRlcHRoKHBhdGgpKSByZXR1cm4gdGhpcy5pbnNlcnQocGF0aCwgc2l6ZSA/IHNpemUgOiBuZXcgU2l6ZSgpKTtcblxuICAgIHZhciBwYXJlbnQgPSB0aGlzLmdldChQYXRoVXRpbHMucGFyZW50KHBhdGgpKTtcblxuICAgIGlmICghcGFyZW50KSB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdObyBwYXJlbnQgc2l6ZSByZWdpc3RlcmVkIGF0IGV4cGVjdGVkIHBhdGg6ICcgKyBQYXRoVXRpbHMucGFyZW50KHBhdGgpXG4gICAgKTtcblxuICAgIGlmIChzaXplKSBzaXplLnNldFBhcmVudChwYXJlbnQpO1xuXG4gICAgdGhpcy5pbnNlcnQocGF0aCwgc2l6ZSA/IHNpemUgOiBuZXcgU2l6ZShwYXJlbnQpKTtcbn07XG5cbi8qKlxuICogUmVtb3ZlcyB0aGUgc2l6ZSBjb21wb25lbnQgZnJvbSB0aGUgZ2l2ZW4gcGF0aC4gV2lsbCB0aHJvdyBpZiBubyBjb21wb25lbnQgaXMgYXQgdGhhdFxuICogcGF0aFxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCBhdCB3aGljaCB0byByZW1vdmUgdGhlIHNpemUuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuU2l6ZVN5c3RlbS5wcm90b3R5cGUuZGVyZWdpc3RlclNpemVBdFBhdGggPSBTaXplU3lzdGVtLnByb3RvdHlwZS5yZW1vdmU7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgc2l6ZXMgaW4gdGhlIHNjZW5lIGdyYXBoLiBDYWxsZWQgaW50ZXJuYWxseSBieSB0aGUgZmFtb3VzIGVuZ2luZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuU2l6ZVN5c3RlbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgICB2YXIgc2l6ZXMgPSB0aGlzLmdldEl0ZW1zKCk7XG4gICAgdmFyIHBhdGhzID0gdGhpcy5nZXRQYXRocygpO1xuICAgIHZhciBub2RlO1xuICAgIHZhciBzaXplO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGNvbXBvbmVudHM7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSBzaXplcy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSBEaXNwYXRjaC5nZXROb2RlKHBhdGhzW2ldKTtcbiAgICAgICAgY29tcG9uZW50cyA9IG5vZGUuZ2V0Q29tcG9uZW50cygpO1xuICAgICAgICBpZiAoIW5vZGUpIGNvbnRpbnVlO1xuICAgICAgICBzaXplID0gc2l6ZXNbaV07XG4gICAgICAgIGlmIChzaXplLnNpemVNb2RlQ2hhbmdlZCkgc2l6ZU1vZGVDaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHNpemUpO1xuICAgICAgICBpZiAoc2l6ZS5hYnNvbHV0ZVNpemVDaGFuZ2VkKSBhYnNvbHV0ZVNpemVDaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHNpemUpO1xuICAgICAgICBpZiAoc2l6ZS5wcm9wb3J0aW9uYWxTaXplQ2hhbmdlZCkgcHJvcG9ydGlvbmFsU2l6ZUNoYW5nZWQobm9kZSwgY29tcG9uZW50cywgc2l6ZSk7XG4gICAgICAgIGlmIChzaXplLmRpZmZlcmVudGlhbFNpemVDaGFuZ2VkKSBkaWZmZXJlbnRpYWxTaXplQ2hhbmdlZChub2RlLCBjb21wb25lbnRzLCBzaXplKTtcbiAgICAgICAgaWYgKHNpemUucmVuZGVyU2l6ZUNoYW5nZWQpIHJlbmRlclNpemVDaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHNpemUpO1xuICAgICAgICBpZiAoc2l6ZS5mcm9tQ29tcG9uZW50cyhjb21wb25lbnRzKSkgc2l6ZUNoYW5nZWQobm9kZSwgY29tcG9uZW50cywgc2l6ZSwgcGF0aHNbaV0sIGkgPT09IGxlbiAtMSk7XG4gICAgfVxufTtcblxuLy8gcHJpdmF0ZSBtZXRob2RzXG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gYWxlcnQgdGhlIG5vZGUgYW5kIGNvbXBvbmVudHMgdGhhdCBzaXplIG1vZGUgY2hhbmdlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBvdGVudGlhbGx5IGNhbGwgc2l6ZU1vZGVDaGFuZ2VkIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIGEgbGlzdCBvZiB0aGUgbm9kZXMnIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSB0aGUgc2l6ZSBjbGFzcyBmb3IgdGhlIE5vZGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBzaXplTW9kZUNoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIHNpemUpIHtcbiAgICB2YXIgc2l6ZU1vZGUgPSBzaXplLmdldFNpemVNb2RlKCk7XG4gICAgdmFyIHggPSBzaXplTW9kZVswXTtcbiAgICB2YXIgeSA9IHNpemVNb2RlWzFdO1xuICAgIHZhciB6ID0gc2l6ZU1vZGVbMl07XG4gICAgaWYgKG5vZGUub25TaXplTW9kZUNoYW5nZSkgbm9kZS5vblNpemVNb2RlQ2hhbmdlKHgsIHksIHopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25TaXplTW9kZUNoYW5nZSlcbiAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25TaXplTW9kZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBzaXplLnNpemVNb2RlQ2hhbmdlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGFsZXJ0IHRoZSBub2RlIGFuZCBjb21wb25lbnRzIHRoYXQgYWJzb2x1dGVTaXplIGNoYW5nZWQuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgTm9kZSB0byBwb3RlbnRpYWxseSBjYWxsIG9uQWJzb2x1dGVTaXplQ2hhbmdlIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIGEgbGlzdCBvZiB0aGUgbm9kZXMnIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSB0aGUgc2l6ZSBjbGFzcyBmb3IgdGhlIE5vZGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBhYnNvbHV0ZVNpemVDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBzaXplKSB7XG4gICAgdmFyIGFic29sdXRlU2l6ZSA9IHNpemUuZ2V0QWJzb2x1dGUoKTtcbiAgICB2YXIgeCA9IGFic29sdXRlU2l6ZVswXTtcbiAgICB2YXIgeSA9IGFic29sdXRlU2l6ZVsxXTtcbiAgICB2YXIgeiA9IGFic29sdXRlU2l6ZVsyXTtcbiAgICBpZiAobm9kZS5vbkFic29sdXRlU2l6ZUNoYW5nZSkgbm9kZS5vbkFic29sdXRlU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uQWJzb2x1dGVTaXplQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbkFic29sdXRlU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBzaXplLmFic29sdXRlU2l6ZUNoYW5nZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byBhbGVydCB0aGUgbm9kZSBhbmQgY29tcG9uZW50cyB0aGF0IHRoZSBwcm9wb3J0aW9uYWwgc2l6ZSBjaGFuZ2VkLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcG90ZW50aWFsbHkgY2FsbCBvblByb3BvcnRpb25hbFNpemVDaGFuZ2Ugb25cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgYSBsaXN0IG9mIHRoZSBub2RlcycgY29tcG9uZW50c1xuICogQHBhcmFtIHtTaXplfSBzaXplIHRoZSBzaXplIGNsYXNzIGZvciB0aGUgTm9kZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHByb3BvcnRpb25hbFNpemVDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBzaXplKSB7XG4gICAgdmFyIHByb3BvcnRpb25hbFNpemUgPSBzaXplLmdldFByb3BvcnRpb25hbCgpO1xuICAgIHZhciB4ID0gcHJvcG9ydGlvbmFsU2l6ZVswXTtcbiAgICB2YXIgeSA9IHByb3BvcnRpb25hbFNpemVbMV07XG4gICAgdmFyIHogPSBwcm9wb3J0aW9uYWxTaXplWzJdO1xuICAgIGlmIChub2RlLm9uUHJvcG9ydGlvbmFsU2l6ZUNoYW5nZSkgbm9kZS5vblByb3BvcnRpb25hbFNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vblByb3BvcnRpb25hbFNpemVDaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uUHJvcG9ydGlvbmFsU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBzaXplLnByb3BvcnRpb25hbFNpemVDaGFuZ2VkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gYWxlcnQgdGhlIG5vZGUgYW5kIGNvbXBvbmVudHMgdGhhdCBkaWZmZXJlbnRpYWwgc2l6ZSBjaGFuZ2VkLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcG90ZW50aWFsbHkgY2FsbCBvbkRpZmZlcmVudGlhbFNpemUgb25cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgYSBsaXN0IG9mIHRoZSBub2RlcycgY29tcG9uZW50c1xuICogQHBhcmFtIHtTaXplfSBzaXplIHRoZSBzaXplIGNsYXNzIGZvciB0aGUgTm9kZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGRpZmZlcmVudGlhbFNpemVDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBzaXplKSB7XG4gICAgdmFyIGRpZmZlcmVudGlhbFNpemUgPSBzaXplLmdldERpZmZlcmVudGlhbCgpO1xuICAgIHZhciB4ID0gZGlmZmVyZW50aWFsU2l6ZVswXTtcbiAgICB2YXIgeSA9IGRpZmZlcmVudGlhbFNpemVbMV07XG4gICAgdmFyIHogPSBkaWZmZXJlbnRpYWxTaXplWzJdO1xuICAgIGlmIChub2RlLm9uRGlmZmVyZW50aWFsU2l6ZUNoYW5nZSkgbm9kZS5vbkRpZmZlcmVudGlhbFNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vbkRpZmZlcmVudGlhbFNpemVDaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uRGlmZmVyZW50aWFsU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBzaXplLmRpZmZlcmVudGlhbFNpemVDaGFuZ2VkID0gZmFsc2U7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gYWxlcnQgdGhlIG5vZGUgYW5kIGNvbXBvbmVudHMgdGhhdCByZW5kZXIgc2l6ZSBjaGFuZ2VkLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIE5vZGUgdG8gcG90ZW50aWFsbHkgY2FsbCBvblJlbmRlclNpemVDaGFuZ2Ugb25cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgYSBsaXN0IG9mIHRoZSBub2RlcycgY29tcG9uZW50c1xuICogQHBhcmFtIHtTaXplfSBzaXplIHRoZSBzaXplIGNsYXNzIGZvciB0aGUgTm9kZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNpemVDaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCBzaXplKSB7XG4gICAgdmFyIHJlbmRlclNpemUgPSBzaXplLmdldFJlbmRlclNpemUoKTtcbiAgICB2YXIgeCA9IHJlbmRlclNpemVbMF07XG4gICAgdmFyIHkgPSByZW5kZXJTaXplWzFdO1xuICAgIHZhciB6ID0gcmVuZGVyU2l6ZVsyXTtcbiAgICBpZiAobm9kZS5vblJlbmRlclNpemVDaGFuZ2UpIG5vZGUub25SZW5kZXJTaXplQ2hhbmdlKHgsIHksIHopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25SZW5kZXJTaXplQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vblJlbmRlclNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgc2l6ZS5yZW5kZXJTaXplQ2hhbmdlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGFsZXJ0IHRoZSBub2RlIGFuZCBjb21wb25lbnRzIHRoYXQgdGhlIHNpemUgY2hhbmdlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSBOb2RlIHRvIHBvdGVudGlhbGx5IGNhbGwgb25TaXplQ2hhbmdlIG9uXG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIGEgbGlzdCBvZiB0aGUgbm9kZXMnIGNvbXBvbmVudHNcbiAqIEBwYXJhbSB7U2l6ZX0gc2l6ZSB0aGUgc2l6ZSBjbGFzcyBmb3IgdGhlIE5vZGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBzaXplQ2hhbmdlZCAobm9kZSwgY29tcG9uZW50cywgc2l6ZSwgcGF0aCwgZG9JdCkge1xuICAgIHZhciBmaW5hbFNpemUgPSBzaXplLmdldCgpO1xuICAgIHZhciB4ID0gZmluYWxTaXplWzBdO1xuICAgIHZhciB5ID0gZmluYWxTaXplWzFdO1xuICAgIHZhciB6ID0gZmluYWxTaXplWzJdO1xuICAgIGlmIChub2RlLm9uU2l6ZUNoYW5nZSkgbm9kZS5vblNpemVDaGFuZ2UoeCwgeSwgeik7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vblNpemVDaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uU2l6ZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBzaXplLnNpemVDaGFuZ2VkID0gZmFsc2U7XG5cbiAgICB2YXIgdHJhbnNmb3JtID0gVHJhbnNmb3JtU3lzdGVtLmdldChwYXRoKTtcbiAgICB0cmFuc2Zvcm0uX2RpcnR5RnJvbVNpemVDaGFuZ2UgPSB0cnVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBTaXplU3lzdGVtKCk7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGgnKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvYXNzZXJ0Jyk7XG5cbi8qKlxuICogQSBjbGFzcyB0aGF0IGNhbiBiZSB1c2VkIHRvIGFzc29jaWF0ZSBhbnkgaXRlbSB3aXRoIGEgcGF0aC5cbiAqIEl0ZW1zIGFuZCBwYXRocyBhcmUga2VwdCBpbiBmbGF0IGFycmF5cyBmb3IgZWFzeSBpdGVyYXRpb25cbiAqIGFuZCBhIG1lbW8gaXMgdXNlZCB0byBwcm92aWRlIGNvbnN0YW50IHRpbWUgbG9va3VwLlxuICpcbiAqIEBjbGFzc1xuICpcbiAqL1xuZnVuY3Rpb24gU3lzdGVtICgpIHtcbiAgICB0aGlzLml0ZW1zID0gW107XG4gICAgdGhpcy5wYXRocyA9IFtdO1xuICAgIHRoaXMubWVtbyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc29jaWF0ZXMgYW4gaXRlbSB3aXRoIHRoZSBnaXZlbiBwYXRoLiBFcnJvcnMgaWYgYW4gaXRlbVxuICogYWxyZWFkeSBleGlzdHMgYXQgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIGF0IHdoaWNoIHRvIGluc2VydCB0aGUgaXRlbVxuICogQHBhcmFtIHtBbnl9IGl0ZW0gVGhlIGl0ZW0gdG8gYXNzb2NpYXRlIHdpdGggdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuU3lzdGVtLnByb3RvdHlwZS5pbnNlcnQgPSBmdW5jdGlvbiBpbnNlcnQgKHBhdGgsIGl0ZW0pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpIHtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJywgJ3BhdGggbmVlZHMgdG8gYmUgYSBzdHJpbmcnKTtcbiAgICAgICAgYXNzZXJ0KHR5cGVvZiBpdGVtICE9PSAnc3RyaW5nJywgJ2l0ZW0gbmVlZHMgdG8gYmUgZ2l2ZW4nKTtcbiAgICB9XG5cbiAgICB2YXIgcGF0aHMgPSB0aGlzLnBhdGhzO1xuICAgIHZhciBpbmRleCA9IHBhdGhzLmluZGV4T2YocGF0aCk7XG4gICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpdGVtIGFscmVhZHkgZXhpc3RzIGF0IHBhdGg6ICcgKyBwYXRoKTtcblxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgdGFyZ2V0RGVwdGggPSBQYXRoVXRpbHMuZGVwdGgocGF0aCk7XG4gICAgdmFyIHRhcmdldEluZGV4ID0gUGF0aFV0aWxzLmluZGV4KHBhdGgpO1xuXG4gICAgLy8gVGhlIGl0ZW0gd2lsbCBiZSBpbnNlcnRlZCBhdCBhIHBvaW50IGluIHRoZSBhcnJheVxuICAgIC8vIHN1Y2ggdGhhdCBpdCBpcyB3aXRoaW4gaXRzIG93biBicmVhZHRoIGluIHRoZSB0cmVlXG4gICAgLy8gdGhhdCB0aGUgcGF0aHMgcmVwcmVzZW50XG4gICAgd2hpbGUgKFxuICAgICAgICBwYXRoc1tpXSAmJlxuICAgICAgICB0YXJnZXREZXB0aCA+PSBQYXRoVXRpbHMuZGVwdGgocGF0aHNbaV0pXG4gICAgKSBpKys7XG5cbiAgICAvLyBUaGUgaXRlbSB3aWxsIGJlIHNvcnRlZCB3aXRoaW4gaXRzIGJyZWFkdGggYnkgaW5kZXhcbiAgICAvLyBpbiByZWdhcmQgdG8gaXRzIHNpYmxpbmdzLlxuICAgIHdoaWxlIChcbiAgICAgICAgcGF0aHNbaV0gJiZcbiAgICAgICAgdGFyZ2V0RGVwdGggPT09IFBhdGhVdGlscy5kZXB0aChwYXRoc1tpXSkgJiZcbiAgICAgICAgdGFyZ2V0SW5kZXggPCBQYXRoVXRpbHMuaW5kZXgocGF0aHNbaV0pXG4gICAgKSBpKys7XG5cbiAgICAvLyBpbnNlcnQgdGhlIGl0ZW1zIGluIHRoZSBwYXRoXG4gICAgcGF0aHMuc3BsaWNlKGksIDAsIHBhdGgpO1xuICAgIHRoaXMuaXRlbXMuc3BsaWNlKGksIDAsIGl0ZW0pO1xuXG4gICAgLy8gc3RvcmUgdGhlIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIHBhdGggYW5kIGluZGV4IGluIHRoZSBtZW1vXG4gICAgdGhpcy5tZW1vW3BhdGhdID0gaTtcblxuICAgIC8vIGFsbCBpdGVtcyBiZWhpbmQgdGhlIGluc2VydGVkIGl0ZW0gYXJlIG5vdyBubyBsb25nZXJcbiAgICAvLyBhY2N1cmF0ZWx5IHN0b3JlZCBpbiB0aGUgbWVtby4gVGh1cyB0aGUgbWVtbyBtdXN0IGJlIGNsZWFyZWQgZm9yXG4gICAgLy8gdGhlc2UgaXRlbXMuXG4gICAgZm9yICh2YXIgbGVuID0gdGhpcy5wYXRocy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICB0aGlzLm1lbW9bdGhpcy5wYXRoc1tpXV0gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIHRoZSB0aGUgaXRlbSBmcm9tIHRoZSBzdG9yZSBhdCB0aGUgZ2l2ZW4gcGF0aC5cbiAqIEVycm9ycyBpZiBubyBpdGVtIGV4aXN0cyBhdCB0aGUgZ2l2ZW4gcGF0aC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggVGhlIHBhdGggYXQgd2hpY2ggdG8gcmVtb3ZlIHRoZSBpdGVtLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblN5c3RlbS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gcmVtb3ZlIChwYXRoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuXG4gICAgdmFyIHBhdGhzID0gdGhpcy5wYXRocztcbiAgICB2YXIgaW5kZXggPSB0aGlzLm1lbW9bcGF0aF0gPyB0aGlzLm1lbW9bcGF0aF0gOiBwYXRocy5pbmRleE9mKHBhdGgpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHJlbW92ZS4gTm8gaXRlbSBleGlzdHMgYXQgcGF0aDogJyArIHBhdGgpO1xuXG4gICAgcGF0aHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB0aGlzLml0ZW1zLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICB0aGlzLm1lbW9bcGF0aF0gPSBudWxsO1xuXG4gICAgZm9yICh2YXIgbGVuID0gdGhpcy5wYXRocy5sZW5ndGggOyBpbmRleCA8IGxlbiA7IGluZGV4KyspXG4gICAgICAgIHRoaXMubWVtb1t0aGlzLnBhdGhzW2luZGV4XV0gPSBudWxsO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBpdGVtIHN0b3JlZCBhdCB0aGUgY3VycmVudCBwYXRoLiBSZXR1cm5zIHVuZGVmaW5lZFxuICogaWYgbm8gaXRlbSBpcyBzdG9yZWQgYXQgdGhhdCBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBsb29rdXAgdGhlIGl0ZW0gZm9yXG4gKlxuICogQHJldHVybiB7QW55IHwgdW5kZWZpbmVkfSB0aGUgaXRlbSBzdG9yZWQgb3IgdW5kZWZpbmVkXG4gKi9cblN5c3RlbS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gZ2V0IChwYXRoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuXG4gICAgaWYgKHRoaXMubWVtb1twYXRoXSkgcmV0dXJuIHRoaXMuaXRlbXNbdGhpcy5tZW1vW3BhdGhdXTtcblxuICAgIHZhciBpbmRleCA9IHRoaXMucGF0aHMuaW5kZXhPZihwYXRoKTtcblxuICAgIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB2b2lkIDA7XG5cbiAgICB0aGlzLm1lbW9bcGF0aF0gPSBpbmRleDtcblxuICAgIHJldHVybiB0aGlzLml0ZW1zW2luZGV4XTtcbn07XG5cbi8qKlxuICogUmV0dXJucyBhbiBhcnJheSBvZiB0aGUgaXRlbXMgY3VycmVudGx5IHN0b3JlZCBpbiB0aGlzXG4gKiBTeXN0ZW0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBpdGVtcyBjdXJyZW50bHkgc3RvcmVkXG4gKi9cblN5c3RlbS5wcm90b3R5cGUuZ2V0SXRlbXMgPSBmdW5jdGlvbiBnZXRJdGVtcyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXRlbXM7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gYXJyYXkgb2YgdGhlIHBhdGhzIGN1cnJlbnRseSBzdG9yZWQgaW4gdGhpc1xuICogU3lzdGVtLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gcGF0aHMgY3VycmVudGx5IHN0b3JlZFxuICovXG5TeXN0ZW0ucHJvdG90eXBlLmdldFBhdGhzID0gZnVuY3Rpb24gZ2V0UGF0aHMgKCkge1xuICAgIHJldHVybiB0aGlzLnBhdGhzO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeXN0ZW07XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBRVUFUID0gWzAsIDAsIDAsIDFdO1xudmFyIE9ORVMgPSBbMSwgMSwgMV07XG5cbi8qKlxuICogVGhlIHRyYW5zZm9ybSBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgY2FsY3VsYXRpbmcgdGhlIHRyYW5zZm9ybSBvZiBhIHBhcnRpY3VsYXJcbiAqIG5vZGUgZnJvbSB0aGUgZGF0YSBvbiB0aGUgbm9kZSBhbmQgaXRzIHBhcmVudFxuICpcbiAqIEBjb25zdHJ1Y3RvciBUcmFuc2Zvcm1cbiAqXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gcGFyZW50IHRoZSBwYXJlbnQgVHJhbnNmb3JtXG4gKi9cbmZ1bmN0aW9uIFRyYW5zZm9ybSAocGFyZW50KSB7XG4gICAgdGhpcy5sb2NhbCA9IG5ldyBGbG9hdDMyQXJyYXkoVHJhbnNmb3JtLklERU5UKTtcbiAgICB0aGlzLmdsb2JhbCA9IG5ldyBGbG9hdDMyQXJyYXkoVHJhbnNmb3JtLklERU5UKTtcbiAgICB0aGlzLm9mZnNldHMgPSB7XG4gICAgICAgIGFsaWduOiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICBhbGlnbkNoYW5nZWQ6IGZhbHNlLFxuICAgICAgICBtb3VudFBvaW50OiBuZXcgRmxvYXQzMkFycmF5KDMpLFxuICAgICAgICBtb3VudFBvaW50Q2hhbmdlZDogZmFsc2UsXG4gICAgICAgIG9yaWdpbjogbmV3IEZsb2F0MzJBcnJheSgzKSxcbiAgICAgICAgb3JpZ2luQ2hhbmdlZDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMudmVjdG9ycyA9IHtcbiAgICAgICAgcG9zaXRpb246IG5ldyBGbG9hdDMyQXJyYXkoMyksXG4gICAgICAgIHBvc2l0aW9uQ2hhbmdlZDogZmFsc2UsXG4gICAgICAgIHJvdGF0aW9uOiBuZXcgRmxvYXQzMkFycmF5KFFVQVQpLFxuICAgICAgICByb3RhdGlvbkNoYW5nZWQ6IGZhbHNlLFxuICAgICAgICBzY2FsZTogbmV3IEZsb2F0MzJBcnJheShPTkVTKSxcbiAgICAgICAgc2NhbGVDaGFuZ2VkOiBmYWxzZVxuICAgIH07XG4gICAgdGhpcy5fbGFzdEV1bGVyVmFscyA9IFswLCAwLCAwXTtcbiAgICB0aGlzLl9sYXN0RXVsZXIgPSBmYWxzZTtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudCA/IHBhcmVudCA6IG51bGw7XG4gICAgdGhpcy5icmVha1BvaW50ID0gZmFsc2U7XG4gICAgdGhpcy5jYWxjdWxhdGluZ1dvcmxkTWF0cml4ID0gZmFsc2U7XG4gICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcbn1cblxuVHJhbnNmb3JtLklERU5UID0gWyAxLCAwLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAxLCAwLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAxLCAwLFxuICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAxIF07XG5cblRyYW5zZm9ybS5XT1JMRF9DSEFOR0VEID0gMTtcblRyYW5zZm9ybS5MT0NBTF9DSEFOR0VEID0gMjtcblxuLyoqXG4gKiByZXNldHMgdGhlIHRyYW5zZm9ybSBzdGF0ZSBzdWNoIHRoYXQgaXQgbm8gbG9uZ2VyIGhhcyBhIHBhcmVudFxuICogYW5kIGlzIG5vdCBhIGJyZWFrcG9pbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiByZXNldCAoKSB7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuYnJlYWtQb2ludCA9IGZhbHNlO1xuICAgIHRoaXMuY2FsY3VsYXRpbmdXb3JsZE1hdHJpeCA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBzZXRzIHRoZSBwYXJlbnQgb2YgdGhpcyB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7VHJhbnNmb3JtfSBwYXJlbnQgVGhlIHRyYW5zZm9ybSBjbGFzcyB0aGF0IHBhcmVudHMgdGhpcyBjbGFzc1xuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0UGFyZW50ID0gZnVuY3Rpb24gc2V0UGFyZW50IChwYXJlbnQpIHtcbiAgICB0aGlzLnBhcmVudCA9IHBhcmVudDtcbn07XG5cbi8qKlxuICogcmV0dXJucyB0aGUgcGFyZW50IG9mIHRoaXMgdHJhbnNmb3JtXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1RyYW5zZm9ybSB8IG51bGx9IHRoZSBwYXJlbnQgb2YgdGhpcyB0cmFuc2Zvcm0gaWYgb25lIGV4aXN0c1xuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFBhcmVudCA9IGZ1bmN0aW9uIGdldFBhcmVudCAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGFyZW50O1xufTtcblxuLyoqXG4gKiBNYWtlcyB0aGlzIHRyYW5zZm9ybSBhIGJyZWFrcG9pbnQuIFRoaXMgd2lsbCBjYXVzZSBpdCB0byBjYWxjdWxhdGVcbiAqIGJvdGggYSBsb2NhbCAocmVsYXRpdmUgdG8gdGhlIG5lYXJlc3QgYW5jZXN0b3IgYnJlYWtwb2ludCkgYW5kIGEgd29ybGRcbiAqIG1hdHJpeCAocmVsYXRpdmUgdG8gdGhlIHNjZW5lKS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRCcmVha1BvaW50ID0gZnVuY3Rpb24gc2V0QnJlYWtQb2ludCAoKSB7XG4gICAgdGhpcy5icmVha1BvaW50ID0gdHJ1ZTtcbiAgICB0aGlzLmNhbGN1bGF0aW5nV29ybGRNYXRyaXggPSB0cnVlO1xufTtcblxuLyoqXG4gKiBTZXQgdGhpcyBub2RlIHRvIGNhbGN1bGF0ZSB0aGUgd29ybGQgbWF0cml4LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldENhbGN1bGF0ZVdvcmxkTWF0cml4ID0gZnVuY3Rpb24gc2V0Q2FsY3VsYXRlV29ybGRNYXRyaXggKCkge1xuICAgIHRoaXMuY2FsY3VsYXRpbmdXb3JsZE1hdHJpeCA9IHRydWU7XG59O1xuXG4vKipcbiAqIHJldHVybnMgd2hldGhlciBvciBub3QgdGhpcyB0cmFuc2Zvcm0gaXMgYSBicmVha3BvaW50LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHRoaXMgdHJhbnNmb3JtIGlzIGEgYnJlYWtwb2ludFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmlzQnJlYWtQb2ludCA9IGZ1bmN0aW9uIGlzQnJlYWtQb2ludCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuYnJlYWtQb2ludDtcbn07XG5cbi8qKlxuICogcmV0dXJucyB0aGUgbG9jYWwgdHJhbnNmb3JtXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gbG9jYWwgdHJhbnNmb3JtXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0TG9jYWxUcmFuc2Zvcm0gPSBmdW5jdGlvbiBnZXRMb2NhbFRyYW5zZm9ybSAoKSB7XG4gICAgcmV0dXJuIHRoaXMubG9jYWw7XG59O1xuXG4vKipcbiAqIHJldHVybnMgdGhlIHdvcmxkIHRyYW5zZm9ybS4gUmVxdWlyZXMgdGhhdCB0aGlzIHRyYW5zZm9ybSBpcyBhIGJyZWFrcG9pbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gd29ybGQgdHJhbnNmb3JtLlxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldFdvcmxkVHJhbnNmb3JtID0gZnVuY3Rpb24gZ2V0V29ybGRUcmFuc2Zvcm0gKCkge1xuICAgIGlmICghdGhpcy5pc0JyZWFrUG9pbnQoKSAmJiAhdGhpcy5jYWxjdWxhdGluZ1dvcmxkTWF0cml4KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgdHJhbnNmb3JtIGlzIG5vdCBjYWxjdWxhdGluZyB3b3JsZCB0cmFuc2Zvcm1zJyk7XG4gICAgcmV0dXJuIHRoaXMuZ2xvYmFsO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhIG5vZGUgYW5kIGNhbGN1bGF0ZXMgdGhlIHByb3BlciB0cmFuc2Zvcm0gZnJvbSBpdC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIHRoZSBub2RlIHRvIGNhbGN1bGF0ZSB0aGUgdHJhbnNmb3JtIGZyb21cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmNhbGN1bGF0ZSA9IGZ1bmN0aW9uIGNhbGN1bGF0ZSAobm9kZSkge1xuICAgIGlmICghdGhpcy5wYXJlbnQgfHwgdGhpcy5wYXJlbnQuaXNCcmVha1BvaW50KCkpXG4gICAgICAgIHJldHVybiBmcm9tTm9kZShub2RlLCB0aGlzKTtcbiAgICBlbHNlIHJldHVybiBmcm9tTm9kZVdpdGhQYXJlbnQobm9kZSwgdGhpcyk7XG59O1xuXG4vKipcbiAqIEEgcHJpdmF0ZSBtZXRob2QgdG8gcG90ZW50aWFsbHkgc2V0IGEgdmFsdWUgd2l0aGluIGFuXG4gKiBhcnJheS4gV2lsbCBzZXQgdGhlIHZhbHVlIGlmIGEgdmFsdWUgd2FzIGdpdmVuXG4gKiBmb3IgdGhlIHRoaXJkIGFyZ3VtZW50IGFuZCBpZiB0aGF0IHZhbHVlIGlzIGRpZmZlcmVudFxuICogdGhhbiB0aGUgdmFsdWUgdGhhdCBpcyBjdXJyZW50bHkgaW4gdGhlIGFycmF5IGF0IHRoZSBnaXZlbiBpbmRleC5cbiAqIFJldHVybnMgdHJ1ZSBpZiBhIHZhbHVlIHdhcyBzZXQgYW5kIGZhbHNlIGlmIG5vdC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVjIFRoZSBhcnJheSB0byBzZXQgdGhlIHZhbHVlIHdpdGhpblxuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBhdCB3aGljaCB0byBzZXQgdGhlIHZhbHVlXG4gKiBAcGFyYW0ge0FueX0gdmFsIFRoZSB2YWx1ZSB0byBwb3RlbnRpYWxseSBzZXQgaW4gdGhlIGFycmF5XG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gd2hldGhlciBvciBub3QgYSB2YWx1ZSB3YXMgc2V0XG4gKi9cbmZ1bmN0aW9uIF92ZWNPcHRpb25hbFNldCAodmVjLCBpbmRleCwgdmFsKSB7XG4gICAgaWYgKHZhbCAhPSBudWxsICYmIHZlY1tpbmRleF0gIT09IHZhbCkge1xuICAgICAgICB2ZWNbaW5kZXhdID0gdmFsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIHByaXZhdGUgbWV0aG9kIHRvIHNldCB2YWx1ZXMgd2l0aGluIGFuIGFycmF5LlxuICogUmV0dXJucyB3aGV0aGVyIG9yIG5vdCB0aGUgYXJyYXkgaGFzIGJlZW4gY2hhbmdlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gdmVjIFRoZSB2ZWN0b3IgdG8gYmUgb3BlcmF0ZWQgdXBvblxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB4IFRoZSB4IHZhbHVlIG9mIHRoZSB2ZWN0b3JcbiAqIEBwYXJhbSB7TnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0geSBUaGUgeSB2YWx1ZSBvZiB0aGUgdmVjdG9yXG4gKiBAcGFyYW0ge051bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHogVGhlIHogdmFsdWUgb2YgdGhlIHZlY3RvclxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB3IHRoZSB3IHZhbHVlIG9mIHRoZSB2ZWN0b3JcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgYXJyYXkgd2FzIGNoYW5nZWRcbiAqL1xuZnVuY3Rpb24gc2V0VmVjICh2ZWMsIHgsIHksIHosIHcpIHtcbiAgICB2YXIgcHJvcGFnYXRlID0gZmFsc2U7XG5cbiAgICBwcm9wYWdhdGUgPSBfdmVjT3B0aW9uYWxTZXQodmVjLCAwLCB4KSB8fCBwcm9wYWdhdGU7XG4gICAgcHJvcGFnYXRlID0gX3ZlY09wdGlvbmFsU2V0KHZlYywgMSwgeSkgfHwgcHJvcGFnYXRlO1xuICAgIHByb3BhZ2F0ZSA9IF92ZWNPcHRpb25hbFNldCh2ZWMsIDIsIHopIHx8IHByb3BhZ2F0ZTtcbiAgICBpZiAodyAhPSBudWxsKVxuICAgICAgICBwcm9wYWdhdGUgPSBfdmVjT3B0aW9uYWxTZXQodmVjLCAzLCB3KSB8fCBwcm9wYWdhdGU7XG5cbiAgICByZXR1cm4gcHJvcGFnYXRlO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHBvc2l0aW9uIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gdGhlIHBvc2l0aW9uIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0UG9zaXRpb24gPSBmdW5jdGlvbiBnZXRQb3NpdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVjdG9ycy5wb3NpdGlvbjtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcG9zaXRpb24gY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSB4IFRoZSB4IGRpbWVuc2lvbiBvZiB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSB5IGRpbWVuc2lvbiBvZiB0aGUgcG9zaXRpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IFRoZSB6IGRpbWVuc2lvbiBvZiB0aGUgcG9zaXRpb25cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFBvc2l0aW9uID0gZnVuY3Rpb24gc2V0UG9zaXRpb24gKHgsIHksIHopIHtcbiAgICB0aGlzLnZlY3RvcnMucG9zaXRpb25DaGFuZ2VkID0gc2V0VmVjKHRoaXMudmVjdG9ycy5wb3NpdGlvbiwgeCwgeSwgeik7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHJvdGF0aW9uIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtLiBXaWxsIHJldHVybiBhIHF1YXRlcm5pb24uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gdGhlIHF1YXRlcm5pb24gcmVwcmVzZW50YXRpb24gb2YgdGhlIHRyYW5zZm9ybSdzIHJvdGF0aW9uXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0Um90YXRpb24gPSBmdW5jdGlvbiBnZXRSb3RhdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVjdG9ycy5yb3RhdGlvbjtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgcm90YXRpb24gY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uIENhbiB0YWtlIGVpdGhlciBFdWxlclxuICogYW5nbGVzIG9yIGEgcXVhdGVybmlvbi5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHggVGhlIHJvdGF0aW9uIGFib3V0IHRoZSB4IGF4aXMgb3IgdGhlIGV4dGVudCBpbiB0aGUgeCBkaW1lbnNpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB5IFRoZSByb3RhdGlvbiBhYm91dCB0aGUgeSBheGlzIG9yIHRoZSBleHRlbnQgaW4gdGhlIHkgZGltZW5zaW9uXG4gKiBAcGFyYW0ge051bWJlcn0geiBUaGUgcm90YXRpb24gYWJvdXQgdGhlIHogYXhpcyBvciB0aGUgZXh0ZW50IGluIHRoZSB6IGRpbWVuc2lvblxuICogQHBhcmFtIHtOdW1iZXJ9IHcgVGhlIHJvdGF0aW9uIGFib3V0IHRoZSBwcm9jZWVkaW5nIHZlY3RvclxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0Um90YXRpb24gPSBmdW5jdGlvbiBzZXRSb3RhdGlvbiAoeCwgeSwgeiwgdykge1xuICAgIHZhciBxdWF0ID0gdGhpcy52ZWN0b3JzLnJvdGF0aW9uO1xuICAgIHZhciBxeCwgcXksIHF6LCBxdztcblxuICAgIGlmICh3ICE9IG51bGwpIHtcbiAgICAgICAgcXggPSB4O1xuICAgICAgICBxeSA9IHk7XG4gICAgICAgIHF6ID0gejtcbiAgICAgICAgcXcgPSB3O1xuICAgICAgICB0aGlzLl9sYXN0RXVsZXJWYWxzWzBdID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdEV1bGVyVmFsc1sxXSA9IG51bGw7XG4gICAgICAgIHRoaXMuX2xhc3RFdWxlclZhbHNbMl0gPSBudWxsO1xuICAgICAgICB0aGlzLl9sYXN0RXVsZXIgPSBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICh4ID09IG51bGwgfHwgeSA9PSBudWxsIHx8IHogPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2xhc3RFdWxlcikge1xuICAgICAgICAgICAgICAgIHggPSB4ID09IG51bGwgPyB0aGlzLl9sYXN0RXVsZXJWYWxzWzBdIDogeDtcbiAgICAgICAgICAgICAgICB5ID0geSA9PSBudWxsID8gdGhpcy5fbGFzdEV1bGVyVmFsc1sxXSA6IHk7XG4gICAgICAgICAgICAgICAgeiA9IHogPT0gbnVsbCA/IHRoaXMuX2xhc3RFdWxlclZhbHNbMl0gOiB6O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHNwID0gLTIgKiAocXVhdFsxXSAqIHF1YXRbMl0gLSBxdWF0WzNdICogcXVhdFswXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoTWF0aC5hYnMoc3ApID4gMC45OTk5OSkge1xuICAgICAgICAgICAgICAgICAgICB5ID0geSA9PSBudWxsID8gTWF0aC5QSSAqIDAuNSAqIHNwIDogeTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IHggPT0gbnVsbCA/IE1hdGguYXRhbjIoLXF1YXRbMF0gKiBxdWF0WzJdICsgcXVhdFszXSAqIHF1YXRbMV0sIDAuNSAtIHF1YXRbMV0gKiBxdWF0WzFdIC0gcXVhdFsyXSAqIHF1YXRbMl0pIDogeDtcbiAgICAgICAgICAgICAgICAgICAgeiA9IHogPT0gbnVsbCA/IDAgOiB6O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgeSA9IHkgPT0gbnVsbCA/IE1hdGguYXNpbihzcCkgOiB5O1xuICAgICAgICAgICAgICAgICAgICB4ID0geCA9PSBudWxsID8gTWF0aC5hdGFuMihxdWF0WzBdICogcXVhdFsyXSArIHF1YXRbM10gKiBxdWF0WzFdLCAwLjUgLSBxdWF0WzBdICogcXVhdFswXSAtIHF1YXRbMV0gKiBxdWF0WzFdKSA6IHg7XG4gICAgICAgICAgICAgICAgICAgIHogPSB6ID09IG51bGwgPyBNYXRoLmF0YW4yKHF1YXRbMF0gKiBxdWF0WzFdICsgcXVhdFszXSAqIHF1YXRbMl0sIDAuNSAtIHF1YXRbMF0gKiBxdWF0WzBdIC0gcXVhdFsyXSAqIHF1YXRbMl0pIDogejtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaHggPSB4ICogMC41O1xuICAgICAgICB2YXIgaHkgPSB5ICogMC41O1xuICAgICAgICB2YXIgaHogPSB6ICogMC41O1xuXG4gICAgICAgIHZhciBzeCA9IE1hdGguc2luKGh4KTtcbiAgICAgICAgdmFyIHN5ID0gTWF0aC5zaW4oaHkpO1xuICAgICAgICB2YXIgc3ogPSBNYXRoLnNpbihoeik7XG4gICAgICAgIHZhciBjeCA9IE1hdGguY29zKGh4KTtcbiAgICAgICAgdmFyIGN5ID0gTWF0aC5jb3MoaHkpO1xuICAgICAgICB2YXIgY3ogPSBNYXRoLmNvcyhoeik7XG5cbiAgICAgICAgdmFyIHN5c3ogPSBzeSAqIHN6O1xuICAgICAgICB2YXIgY3lzeiA9IGN5ICogc3o7XG4gICAgICAgIHZhciBzeWN6ID0gc3kgKiBjejtcbiAgICAgICAgdmFyIGN5Y3ogPSBjeSAqIGN6O1xuXG4gICAgICAgIHF4ID0gc3ggKiBjeWN6ICsgY3ggKiBzeXN6O1xuICAgICAgICBxeSA9IGN4ICogc3ljeiAtIHN4ICogY3lzejtcbiAgICAgICAgcXogPSBjeCAqIGN5c3ogKyBzeCAqIHN5Y3o7XG4gICAgICAgIHF3ID0gY3ggKiBjeWN6IC0gc3ggKiBzeXN6O1xuXG4gICAgICAgIHRoaXMuX2xhc3RFdWxlciA9IHRydWU7XG4gICAgICAgIHRoaXMuX2xhc3RFdWxlclZhbHNbMF0gPSB4O1xuICAgICAgICB0aGlzLl9sYXN0RXVsZXJWYWxzWzFdID0geTtcbiAgICAgICAgdGhpcy5fbGFzdEV1bGVyVmFsc1syXSA9IHo7XG4gICAgfVxuXG4gICAgdGhpcy52ZWN0b3JzLnJvdGF0aW9uQ2hhbmdlZCA9IHNldFZlYyhxdWF0LCBxeCwgcXksIHF6LCBxdyk7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIHNjYWxlIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gdGhlIHNjYWxlIGNvbXBvbmVudCBvZiB0aGUgdHJhbnNmb3JtXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0U2NhbGUgPSBmdW5jdGlvbiBnZXRTY2FsZSAoKSB7XG4gICAgcmV0dXJuIHRoaXMudmVjdG9ycy5zY2FsZTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgc2NhbGUgY29tcG9uZW50IG9mIHRoZSB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0geCBUaGUgeCBkaW1lbnNpb24gb2YgdGhlIHNjYWxlXG4gKiBAcGFyYW0ge051bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHkgVGhlIHkgZGltZW5zaW9uIG9mIHRoZSBzY2FsZVxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB6IFRoZSB6IGRpbWVuc2lvbiBvZiB0aGUgc2NhbGVcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldFNjYWxlID0gZnVuY3Rpb24gc2V0U2NhbGUgKHgsIHksIHopIHtcbiAgICB0aGlzLnZlY3RvcnMuc2NhbGVDaGFuZ2VkID0gc2V0VmVjKHRoaXMudmVjdG9ycy5zY2FsZSwgeCwgeSwgeik7XG59O1xuXG4vKipcbiAqIEdldHMgdGhlIGFsaWduIHZhbHVlIG9mIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7RmxvYXQzMkFycmF5fSB0aGUgYWxpZ24gdmFsdWUgb2YgdGhlIHRyYW5zZm9ybVxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldEFsaWduID0gZnVuY3Rpb24gZ2V0QWxpZ24gKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldHMuYWxpZ247XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIGFsaWduIHZhbHVlIG9mIHRoZSB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7TnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0geCBUaGUgeCBkaW1lbnNpb24gb2YgdGhlIGFsaWduXG4gKiBAcGFyYW0ge051bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHkgVGhlIHkgZGltZW5zaW9uIG9mIHRoZSBhbGlnblxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB6IFRoZSB6IGRpbWVuc2lvbiBvZiB0aGUgYWxpZ25cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnNldEFsaWduID0gZnVuY3Rpb24gc2V0QWxpZ24gKHgsIHksIHopIHtcbiAgICB0aGlzLm9mZnNldHMuYWxpZ25DaGFuZ2VkID0gc2V0VmVjKHRoaXMub2Zmc2V0cy5hbGlnbiwgeCwgeSwgeiAhPSBudWxsID8geiAtIDAuNSA6IHopO1xufTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtb3VudCBwb2ludCB2YWx1ZSBvZiB0aGUgdHJhbnNmb3JtLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtGbG9hdDMyQXJyYXl9IHRoZSBtb3VudCBwb2ludCBvZiB0aGUgdHJhbnNmb3JtXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0TW91bnRQb2ludCA9IGZ1bmN0aW9uIGdldE1vdW50UG9pbnQgKCkge1xuICAgIHJldHVybiB0aGlzLm9mZnNldHMubW91bnRQb2ludDtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgbW91bnQgcG9pbnQgdmFsdWUgb2YgdGhlIHRyYW5zZm9ybS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB4IHRoZSB4IGRpbWVuc2lvbiBvZiB0aGUgbW91bnQgcG9pbnRcbiAqIEBwYXJhbSB7TnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0geSB0aGUgeSBkaW1lbnNpb24gb2YgdGhlIG1vdW50IHBvaW50XG4gKiBAcGFyYW0ge051bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHogdGhlIHogZGltZW5zaW9uIG9mIHRoZSBtb3VudCBwb2ludFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblRyYW5zZm9ybS5wcm90b3R5cGUuc2V0TW91bnRQb2ludCA9IGZ1bmN0aW9uIHNldE1vdW50UG9pbnQgKHgsIHksIHopIHtcbiAgICB0aGlzLm9mZnNldHMubW91bnRQb2ludENoYW5nZWQgPSBzZXRWZWModGhpcy5vZmZzZXRzLm1vdW50UG9pbnQsIHgsIHksIHogIT0gbnVsbCA/IHogLSAwLjUgOiB6KTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgb3JpZ2luIG9mIHRoZSB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0Zsb2F0MzJBcnJheX0gdGhlIG9yaWdpblxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmdldE9yaWdpbiA9IGZ1bmN0aW9uIGdldE9yaWdpbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMub2Zmc2V0cy5vcmlnaW47XG59O1xuXG4vKipcbiAqIFNldHMgdGhlIG9yaWdpbiBvZiB0aGUgdHJhbnNmb3JtLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlciB8IG51bGwgfCB1bmRlZmluZWR9IHggdGhlIHggZGltZW5zaW9uIG9mIHRoZSBvcmlnaW5cbiAqIEBwYXJhbSB7TnVtYmVyIHwgbnVsbCB8IHVuZGVmaW5lZH0geSB0aGUgeSBkaW1lbnNpb24gb2YgdGhlIG9yaWdpblxuICogQHBhcmFtIHtOdW1iZXIgfCBudWxsIHwgdW5kZWZpbmVkfSB6IHRoZSB6IGRpbWVuc2lvbiBvZiB0aGUgb3JpZ2luXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuVHJhbnNmb3JtLnByb3RvdHlwZS5zZXRPcmlnaW4gPSBmdW5jdGlvbiBzZXRPcmlnaW4gKHgsIHksIHopIHtcbiAgICB0aGlzLm9mZnNldHMub3JpZ2luQ2hhbmdlZCA9IHNldFZlYyh0aGlzLm9mZnNldHMub3JpZ2luLCB4LCB5LCB6ICE9IG51bGwgPyB6IC0gMC41IDogeik7XG59O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIHdvcmxkIGZvciB0aGlzIHBhcnRpY3VsYXIgdHJhbnNmb3JtLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5UcmFuc2Zvcm0ucHJvdG90eXBlLmNhbGN1bGF0ZVdvcmxkTWF0cml4ID0gZnVuY3Rpb24gY2FsY3VsYXRlV29ybGRNYXRyaXggKCkge1xuICAgIHZhciBuZWFyZXN0QnJlYWtQb2ludCA9IHRoaXMucGFyZW50O1xuXG4gICAgd2hpbGUgKG5lYXJlc3RCcmVha1BvaW50ICYmICFuZWFyZXN0QnJlYWtQb2ludC5pc0JyZWFrUG9pbnQoKSlcbiAgICAgICAgbmVhcmVzdEJyZWFrUG9pbnQgPSBuZWFyZXN0QnJlYWtQb2ludC5wYXJlbnQ7XG5cbiAgICBpZiAobmVhcmVzdEJyZWFrUG9pbnQpIHJldHVybiBtdWx0aXBseSh0aGlzLmdsb2JhbCwgbmVhcmVzdEJyZWFrUG9pbnQuZ2V0V29ybGRUcmFuc2Zvcm0oKSwgdGhpcy5sb2NhbCk7XG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTYgOyBpKyspIHRoaXMuZ2xvYmFsW2ldID0gdGhpcy5sb2NhbFtpXTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn07XG5cblxuLyoqXG4gKiBQcml2YXRlIGZ1bmN0aW9uLiBDcmVhdGVzIGEgdHJhbnNmb3JtYXRpb24gbWF0cml4IGZyb20gYSBOb2RlJ3Mgc3BlYy5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdGhlIG5vZGUgdG8gY3JlYXRlIGEgdHJhbnNmb3JtIGZvclxuICogQHBhcmFtIHtUcmFuc2Zvcm19IHRyYW5zZm9ybSB0cmFuc2Zvcm0gdG8gYXBwbHlcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgdGFyZ2V0IGFycmF5IHdhcyBjaGFuZ2VkXG4gKi9cbmZ1bmN0aW9uIGZyb21Ob2RlIChub2RlLCB0cmFuc2Zvcm0pIHtcbiAgICB2YXIgdGFyZ2V0ID0gdHJhbnNmb3JtLmdldExvY2FsVHJhbnNmb3JtKCk7XG4gICAgdmFyIG15U2l6ZSA9IG5vZGUuZ2V0U2l6ZSgpO1xuICAgIHZhciB2ZWN0b3JzID0gdHJhbnNmb3JtLnZlY3RvcnM7XG4gICAgdmFyIG9mZnNldHMgPSB0cmFuc2Zvcm0ub2Zmc2V0cztcbiAgICB2YXIgcGFyZW50U2l6ZSA9IG5vZGUuZ2V0UGFyZW50KCkuZ2V0U2l6ZSgpO1xuICAgIHZhciBjaGFuZ2VkID0gMDtcblxuICAgIHZhciB0MDAgICAgICAgICA9IHRhcmdldFswXTtcbiAgICB2YXIgdDAxICAgICAgICAgPSB0YXJnZXRbMV07XG4gICAgdmFyIHQwMiAgICAgICAgID0gdGFyZ2V0WzJdO1xuICAgIHZhciB0MTAgICAgICAgICA9IHRhcmdldFs0XTtcbiAgICB2YXIgdDExICAgICAgICAgPSB0YXJnZXRbNV07XG4gICAgdmFyIHQxMiAgICAgICAgID0gdGFyZ2V0WzZdO1xuICAgIHZhciB0MjAgICAgICAgICA9IHRhcmdldFs4XTtcbiAgICB2YXIgdDIxICAgICAgICAgPSB0YXJnZXRbOV07XG4gICAgdmFyIHQyMiAgICAgICAgID0gdGFyZ2V0WzEwXTtcbiAgICB2YXIgdDMwICAgICAgICAgPSB0YXJnZXRbMTJdO1xuICAgIHZhciB0MzEgICAgICAgICA9IHRhcmdldFsxM107XG4gICAgdmFyIHQzMiAgICAgICAgID0gdGFyZ2V0WzE0XTtcbiAgICB2YXIgcG9zWCAgICAgICAgPSB2ZWN0b3JzLnBvc2l0aW9uWzBdO1xuICAgIHZhciBwb3NZICAgICAgICA9IHZlY3RvcnMucG9zaXRpb25bMV07XG4gICAgdmFyIHBvc1ogICAgICAgID0gdmVjdG9ycy5wb3NpdGlvblsyXTtcbiAgICB2YXIgcm90WCAgICAgICAgPSB2ZWN0b3JzLnJvdGF0aW9uWzBdO1xuICAgIHZhciByb3RZICAgICAgICA9IHZlY3RvcnMucm90YXRpb25bMV07XG4gICAgdmFyIHJvdFogICAgICAgID0gdmVjdG9ycy5yb3RhdGlvblsyXTtcbiAgICB2YXIgcm90VyAgICAgICAgPSB2ZWN0b3JzLnJvdGF0aW9uWzNdO1xuICAgIHZhciBzY2FsZVggICAgICA9IHZlY3RvcnMuc2NhbGVbMF07XG4gICAgdmFyIHNjYWxlWSAgICAgID0gdmVjdG9ycy5zY2FsZVsxXTtcbiAgICB2YXIgc2NhbGVaICAgICAgPSB2ZWN0b3JzLnNjYWxlWzJdO1xuICAgIHZhciBhbGlnblggICAgICA9IG9mZnNldHMuYWxpZ25bMF0gKiBwYXJlbnRTaXplWzBdO1xuICAgIHZhciBhbGlnblkgICAgICA9IG9mZnNldHMuYWxpZ25bMV0gKiBwYXJlbnRTaXplWzFdO1xuICAgIHZhciBhbGlnblogICAgICA9IG9mZnNldHMuYWxpZ25bMl0gKiBwYXJlbnRTaXplWzJdO1xuICAgIHZhciBtb3VudFBvaW50WCA9IG9mZnNldHMubW91bnRQb2ludFswXSAqIG15U2l6ZVswXTtcbiAgICB2YXIgbW91bnRQb2ludFkgPSBvZmZzZXRzLm1vdW50UG9pbnRbMV0gKiBteVNpemVbMV07XG4gICAgdmFyIG1vdW50UG9pbnRaID0gb2Zmc2V0cy5tb3VudFBvaW50WzJdICogbXlTaXplWzJdO1xuICAgIHZhciBvcmlnaW5YICAgICA9IG9mZnNldHMub3JpZ2luWzBdICogbXlTaXplWzBdO1xuICAgIHZhciBvcmlnaW5ZICAgICA9IG9mZnNldHMub3JpZ2luWzFdICogbXlTaXplWzFdO1xuICAgIHZhciBvcmlnaW5aICAgICA9IG9mZnNldHMub3JpZ2luWzJdICogbXlTaXplWzJdO1xuXG4gICAgdmFyIHd4ID0gcm90VyAqIHJvdFg7XG4gICAgdmFyIHd5ID0gcm90VyAqIHJvdFk7XG4gICAgdmFyIHd6ID0gcm90VyAqIHJvdFo7XG4gICAgdmFyIHh4ID0gcm90WCAqIHJvdFg7XG4gICAgdmFyIHl5ID0gcm90WSAqIHJvdFk7XG4gICAgdmFyIHp6ID0gcm90WiAqIHJvdFo7XG4gICAgdmFyIHh5ID0gcm90WCAqIHJvdFk7XG4gICAgdmFyIHh6ID0gcm90WCAqIHJvdFo7XG4gICAgdmFyIHl6ID0gcm90WSAqIHJvdFo7XG5cbiAgICB0YXJnZXRbMF0gPSAoMSAtIDIgKiAoeXkgKyB6eikpICogc2NhbGVYO1xuICAgIHRhcmdldFsxXSA9ICgyICogKHh5ICsgd3opKSAqIHNjYWxlWDtcbiAgICB0YXJnZXRbMl0gPSAoMiAqICh4eiAtIHd5KSkgKiBzY2FsZVg7XG4gICAgdGFyZ2V0WzNdID0gMDtcbiAgICB0YXJnZXRbNF0gPSAoMiAqICh4eSAtIHd6KSkgKiBzY2FsZVk7XG4gICAgdGFyZ2V0WzVdID0gKDEgLSAyICogKHh4ICsgenopKSAqIHNjYWxlWTtcbiAgICB0YXJnZXRbNl0gPSAoMiAqICh5eiArIHd4KSkgKiBzY2FsZVk7XG4gICAgdGFyZ2V0WzddID0gMDtcbiAgICB0YXJnZXRbOF0gPSAoMiAqICh4eiArIHd5KSkgKiBzY2FsZVo7XG4gICAgdGFyZ2V0WzldID0gKDIgKiAoeXogLSB3eCkpICogc2NhbGVaO1xuICAgIHRhcmdldFsxMF0gPSAoMSAtIDIgKiAoeHggKyB5eSkpICogc2NhbGVaO1xuICAgIHRhcmdldFsxMV0gPSAwO1xuICAgIHRhcmdldFsxMl0gPSBhbGlnblggKyBwb3NYIC0gbW91bnRQb2ludFggKyBvcmlnaW5YIC1cbiAgICAgICAgICAgICAgICAgKHRhcmdldFswXSAqIG9yaWdpblggKyB0YXJnZXRbNF0gKiBvcmlnaW5ZICsgdGFyZ2V0WzhdICogb3JpZ2luWik7XG4gICAgdGFyZ2V0WzEzXSA9IGFsaWduWSArIHBvc1kgLSBtb3VudFBvaW50WSArIG9yaWdpblkgLVxuICAgICAgICAgICAgICAgICAodGFyZ2V0WzFdICogb3JpZ2luWCArIHRhcmdldFs1XSAqIG9yaWdpblkgKyB0YXJnZXRbOV0gKiBvcmlnaW5aKTtcbiAgICB0YXJnZXRbMTRdID0gYWxpZ25aICsgcG9zWiAtIG1vdW50UG9pbnRaICsgb3JpZ2luWiAtXG4gICAgICAgICAgICAgICAgICh0YXJnZXRbMl0gKiBvcmlnaW5YICsgdGFyZ2V0WzZdICogb3JpZ2luWSArIHRhcmdldFsxMF0gKiBvcmlnaW5aKTtcbiAgICB0YXJnZXRbMTVdID0gMTtcblxuICAgIGlmICh0cmFuc2Zvcm0uY2FsY3VsYXRpbmdXb3JsZE1hdHJpeCAmJiB0cmFuc2Zvcm0uY2FsY3VsYXRlV29ybGRNYXRyaXgoKSlcbiAgICAgICAgY2hhbmdlZCB8PSBUcmFuc2Zvcm0uV09STERfQ0hBTkdFRDtcblxuICAgIGlmICh0MDAgIT09IHRhcmdldFswXSB8fFxuICAgICAgICB0MDEgIT09IHRhcmdldFsxXSB8fFxuICAgICAgICB0MDIgIT09IHRhcmdldFsyXSB8fFxuICAgICAgICB0MTAgIT09IHRhcmdldFs0XSB8fFxuICAgICAgICB0MTEgIT09IHRhcmdldFs1XSB8fFxuICAgICAgICB0MTIgIT09IHRhcmdldFs2XSB8fFxuICAgICAgICB0MjAgIT09IHRhcmdldFs4XSB8fFxuICAgICAgICB0MjEgIT09IHRhcmdldFs5XSB8fFxuICAgICAgICB0MjIgIT09IHRhcmdldFsxMF0gfHxcbiAgICAgICAgdDMwICE9PSB0YXJnZXRbMTJdIHx8XG4gICAgICAgIHQzMSAhPT0gdGFyZ2V0WzEzXSB8fFxuICAgICAgICB0MzIgIT09IHRhcmdldFsxNF0pIGNoYW5nZWQgfD0gVHJhbnNmb3JtLkxPQ0FMX0NIQU5HRUQ7XG5cbiAgICByZXR1cm4gY2hhbmdlZDtcbn1cblxuLyoqXG4gKiBQcml2YXRlIGZ1bmN0aW9uLiBVc2VzIHRoZSBwYXJlbnQgdHJhbnNmb3JtLCB0aGUgbm9kZSdzIHNwZWMsIHRoZSBub2RlJ3Mgc2l6ZSwgYW5kIHRoZSBwYXJlbnQncyBzaXplXG4gKiB0byBjYWxjdWxhdGUgYSBmaW5hbCB0cmFuc2Zvcm0gZm9yIHRoZSBub2RlLiBSZXR1cm5zIHRydWUgaWYgdGhlIHRyYW5zZm9ybSBoYXMgY2hhbmdlZC5cbiAqXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0aGUgbm9kZSB0byBjcmVhdGUgYSB0cmFuc2Zvcm0gZm9yXG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtIHRyYW5zZm9ybSB0byBhcHBseVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgb3Igbm90IHRoZSB0cmFuc2Zvcm0gY2hhbmdlZFxuICovXG5mdW5jdGlvbiBmcm9tTm9kZVdpdGhQYXJlbnQgKG5vZGUsIHRyYW5zZm9ybSkge1xuICAgIHZhciB0YXJnZXQgPSB0cmFuc2Zvcm0uZ2V0TG9jYWxUcmFuc2Zvcm0oKTtcbiAgICB2YXIgcGFyZW50TWF0cml4ID0gdHJhbnNmb3JtLnBhcmVudC5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuICAgIHZhciBteVNpemUgPSBub2RlLmdldFNpemUoKTtcbiAgICB2YXIgdmVjdG9ycyA9IHRyYW5zZm9ybS52ZWN0b3JzO1xuICAgIHZhciBvZmZzZXRzID0gdHJhbnNmb3JtLm9mZnNldHM7XG4gICAgdmFyIHBhcmVudFNpemUgPSBub2RlLmdldFBhcmVudCgpLmdldFNpemUoKTtcbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuXG4gICAgLy8gbG9jYWwgY2FjaGUgb2YgZXZlcnl0aGluZ1xuICAgIHZhciB0MDAgICAgICAgICA9IHRhcmdldFswXTtcbiAgICB2YXIgdDAxICAgICAgICAgPSB0YXJnZXRbMV07XG4gICAgdmFyIHQwMiAgICAgICAgID0gdGFyZ2V0WzJdO1xuICAgIHZhciB0MTAgICAgICAgICA9IHRhcmdldFs0XTtcbiAgICB2YXIgdDExICAgICAgICAgPSB0YXJnZXRbNV07XG4gICAgdmFyIHQxMiAgICAgICAgID0gdGFyZ2V0WzZdO1xuICAgIHZhciB0MjAgICAgICAgICA9IHRhcmdldFs4XTtcbiAgICB2YXIgdDIxICAgICAgICAgPSB0YXJnZXRbOV07XG4gICAgdmFyIHQyMiAgICAgICAgID0gdGFyZ2V0WzEwXTtcbiAgICB2YXIgdDMwICAgICAgICAgPSB0YXJnZXRbMTJdO1xuICAgIHZhciB0MzEgICAgICAgICA9IHRhcmdldFsxM107XG4gICAgdmFyIHQzMiAgICAgICAgID0gdGFyZ2V0WzE0XTtcbiAgICB2YXIgcDAwICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMF07XG4gICAgdmFyIHAwMSAgICAgICAgID0gcGFyZW50TWF0cml4WzFdO1xuICAgIHZhciBwMDIgICAgICAgICA9IHBhcmVudE1hdHJpeFsyXTtcbiAgICB2YXIgcDEwICAgICAgICAgPSBwYXJlbnRNYXRyaXhbNF07XG4gICAgdmFyIHAxMSAgICAgICAgID0gcGFyZW50TWF0cml4WzVdO1xuICAgIHZhciBwMTIgICAgICAgICA9IHBhcmVudE1hdHJpeFs2XTtcbiAgICB2YXIgcDIwICAgICAgICAgPSBwYXJlbnRNYXRyaXhbOF07XG4gICAgdmFyIHAyMSAgICAgICAgID0gcGFyZW50TWF0cml4WzldO1xuICAgIHZhciBwMjIgICAgICAgICA9IHBhcmVudE1hdHJpeFsxMF07XG4gICAgdmFyIHAzMCAgICAgICAgID0gcGFyZW50TWF0cml4WzEyXTtcbiAgICB2YXIgcDMxICAgICAgICAgPSBwYXJlbnRNYXRyaXhbMTNdO1xuICAgIHZhciBwMzIgICAgICAgICA9IHBhcmVudE1hdHJpeFsxNF07XG4gICAgdmFyIHBvc1ggICAgICAgID0gdmVjdG9ycy5wb3NpdGlvblswXTtcbiAgICB2YXIgcG9zWSAgICAgICAgPSB2ZWN0b3JzLnBvc2l0aW9uWzFdO1xuICAgIHZhciBwb3NaICAgICAgICA9IHZlY3RvcnMucG9zaXRpb25bMl07XG4gICAgdmFyIHJvdFggICAgICAgID0gdmVjdG9ycy5yb3RhdGlvblswXTtcbiAgICB2YXIgcm90WSAgICAgICAgPSB2ZWN0b3JzLnJvdGF0aW9uWzFdO1xuICAgIHZhciByb3RaICAgICAgICA9IHZlY3RvcnMucm90YXRpb25bMl07XG4gICAgdmFyIHJvdFcgICAgICAgID0gdmVjdG9ycy5yb3RhdGlvblszXTtcbiAgICB2YXIgc2NhbGVYICAgICAgPSB2ZWN0b3JzLnNjYWxlWzBdO1xuICAgIHZhciBzY2FsZVkgICAgICA9IHZlY3RvcnMuc2NhbGVbMV07XG4gICAgdmFyIHNjYWxlWiAgICAgID0gdmVjdG9ycy5zY2FsZVsyXTtcbiAgICB2YXIgYWxpZ25YICAgICAgPSBvZmZzZXRzLmFsaWduWzBdICogcGFyZW50U2l6ZVswXTtcbiAgICB2YXIgYWxpZ25ZICAgICAgPSBvZmZzZXRzLmFsaWduWzFdICogcGFyZW50U2l6ZVsxXTtcbiAgICB2YXIgYWxpZ25aICAgICAgPSBvZmZzZXRzLmFsaWduWzJdICogcGFyZW50U2l6ZVsyXTtcbiAgICB2YXIgbW91bnRQb2ludFggPSBvZmZzZXRzLm1vdW50UG9pbnRbMF0gKiBteVNpemVbMF07XG4gICAgdmFyIG1vdW50UG9pbnRZID0gb2Zmc2V0cy5tb3VudFBvaW50WzFdICogbXlTaXplWzFdO1xuICAgIHZhciBtb3VudFBvaW50WiA9IG9mZnNldHMubW91bnRQb2ludFsyXSAqIG15U2l6ZVsyXTtcbiAgICB2YXIgb3JpZ2luWCAgICAgPSBvZmZzZXRzLm9yaWdpblswXSAqIG15U2l6ZVswXTtcbiAgICB2YXIgb3JpZ2luWSAgICAgPSBvZmZzZXRzLm9yaWdpblsxXSAqIG15U2l6ZVsxXTtcbiAgICB2YXIgb3JpZ2luWiAgICAgPSBvZmZzZXRzLm9yaWdpblsyXSAqIG15U2l6ZVsyXTtcblxuICAgIHZhciB3eCA9IHJvdFcgKiByb3RYO1xuICAgIHZhciB3eSA9IHJvdFcgKiByb3RZO1xuICAgIHZhciB3eiA9IHJvdFcgKiByb3RaO1xuICAgIHZhciB4eCA9IHJvdFggKiByb3RYO1xuICAgIHZhciB5eSA9IHJvdFkgKiByb3RZO1xuICAgIHZhciB6eiA9IHJvdFogKiByb3RaO1xuICAgIHZhciB4eSA9IHJvdFggKiByb3RZO1xuICAgIHZhciB4eiA9IHJvdFggKiByb3RaO1xuICAgIHZhciB5eiA9IHJvdFkgKiByb3RaO1xuXG4gICAgdmFyIHJzMCA9ICgxIC0gMiAqICh5eSArIHp6KSkgKiBzY2FsZVg7XG4gICAgdmFyIHJzMSA9ICgyICogKHh5ICsgd3opKSAqIHNjYWxlWDtcbiAgICB2YXIgcnMyID0gKDIgKiAoeHogLSB3eSkpICogc2NhbGVYO1xuICAgIHZhciByczMgPSAoMiAqICh4eSAtIHd6KSkgKiBzY2FsZVk7XG4gICAgdmFyIHJzNCA9ICgxIC0gMiAqICh4eCArIHp6KSkgKiBzY2FsZVk7XG4gICAgdmFyIHJzNSA9ICgyICogKHl6ICsgd3gpKSAqIHNjYWxlWTtcbiAgICB2YXIgcnM2ID0gKDIgKiAoeHogKyB3eSkpICogc2NhbGVaO1xuICAgIHZhciByczcgPSAoMiAqICh5eiAtIHd4KSkgKiBzY2FsZVo7XG4gICAgdmFyIHJzOCA9ICgxIC0gMiAqICh4eCArIHl5KSkgKiBzY2FsZVo7XG5cbiAgICB2YXIgdHggPSBhbGlnblggKyBwb3NYIC0gbW91bnRQb2ludFggKyBvcmlnaW5YIC0gKHJzMCAqIG9yaWdpblggKyByczMgKiBvcmlnaW5ZICsgcnM2ICogb3JpZ2luWik7XG4gICAgdmFyIHR5ID0gYWxpZ25ZICsgcG9zWSAtIG1vdW50UG9pbnRZICsgb3JpZ2luWSAtIChyczEgKiBvcmlnaW5YICsgcnM0ICogb3JpZ2luWSArIHJzNyAqIG9yaWdpblopO1xuICAgIHZhciB0eiA9IGFsaWduWiArIHBvc1ogLSBtb3VudFBvaW50WiArIG9yaWdpblogLSAocnMyICogb3JpZ2luWCArIHJzNSAqIG9yaWdpblkgKyByczggKiBvcmlnaW5aKTtcblxuICAgIHRhcmdldFswXSA9IHAwMCAqIHJzMCArIHAxMCAqIHJzMSArIHAyMCAqIHJzMjtcbiAgICB0YXJnZXRbMV0gPSBwMDEgKiByczAgKyBwMTEgKiByczEgKyBwMjEgKiByczI7XG4gICAgdGFyZ2V0WzJdID0gcDAyICogcnMwICsgcDEyICogcnMxICsgcDIyICogcnMyO1xuICAgIHRhcmdldFszXSA9IDA7XG4gICAgdGFyZ2V0WzRdID0gcDAwICogcnMzICsgcDEwICogcnM0ICsgcDIwICogcnM1O1xuICAgIHRhcmdldFs1XSA9IHAwMSAqIHJzMyArIHAxMSAqIHJzNCArIHAyMSAqIHJzNTtcbiAgICB0YXJnZXRbNl0gPSBwMDIgKiByczMgKyBwMTIgKiByczQgKyBwMjIgKiByczU7XG4gICAgdGFyZ2V0WzddID0gMDtcbiAgICB0YXJnZXRbOF0gPSBwMDAgKiByczYgKyBwMTAgKiByczcgKyBwMjAgKiByczg7XG4gICAgdGFyZ2V0WzldID0gcDAxICogcnM2ICsgcDExICogcnM3ICsgcDIxICogcnM4O1xuICAgIHRhcmdldFsxMF0gPSBwMDIgKiByczYgKyBwMTIgKiByczcgKyBwMjIgKiByczg7XG4gICAgdGFyZ2V0WzExXSA9IDA7XG4gICAgdGFyZ2V0WzEyXSA9IHAwMCAqIHR4ICsgcDEwICogdHkgKyBwMjAgKiB0eiArIHAzMDtcbiAgICB0YXJnZXRbMTNdID0gcDAxICogdHggKyBwMTEgKiB0eSArIHAyMSAqIHR6ICsgcDMxO1xuICAgIHRhcmdldFsxNF0gPSBwMDIgKiB0eCArIHAxMiAqIHR5ICsgcDIyICogdHogKyBwMzI7XG4gICAgdGFyZ2V0WzE1XSA9IDE7XG5cbiAgICBpZiAodHJhbnNmb3JtLmNhbGN1bGF0aW5nV29ybGRNYXRyaXggJiYgdHJhbnNmb3JtLmNhbGN1bGF0ZVdvcmxkTWF0cml4KCkpXG4gICAgICAgIGNoYW5nZWQgfD0gVHJhbnNmb3JtLldPUkxEX0NIQU5HRUQ7XG5cbiAgICBpZiAodDAwICE9PSB0YXJnZXRbMF0gfHxcbiAgICAgICAgdDAxICE9PSB0YXJnZXRbMV0gfHxcbiAgICAgICAgdDAyICE9PSB0YXJnZXRbMl0gfHxcbiAgICAgICAgdDEwICE9PSB0YXJnZXRbNF0gfHxcbiAgICAgICAgdDExICE9PSB0YXJnZXRbNV0gfHxcbiAgICAgICAgdDEyICE9PSB0YXJnZXRbNl0gfHxcbiAgICAgICAgdDIwICE9PSB0YXJnZXRbOF0gfHxcbiAgICAgICAgdDIxICE9PSB0YXJnZXRbOV0gfHxcbiAgICAgICAgdDIyICE9PSB0YXJnZXRbMTBdIHx8XG4gICAgICAgIHQzMCAhPT0gdGFyZ2V0WzEyXSB8fFxuICAgICAgICB0MzEgIT09IHRhcmdldFsxM10gfHxcbiAgICAgICAgdDMyICE9PSB0YXJnZXRbMTRdKSBjaGFuZ2VkIHw9IFRyYW5zZm9ybS5MT0NBTF9DSEFOR0VEO1xuXG4gICAgcmV0dXJuIGNoYW5nZWQ7XG59XG5cbi8qKlxuICogcHJpdmF0ZSBtZXRob2QgdG8gbXVsdGlwbHkgdHdvIHRyYW5zZm9ybXMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IG91dCBUaGUgYXJyYXkgdG8gd3JpdGUgdGhlIHJlc3VsdCB0b1xuICogQHBhcmFtIHtBcnJheX0gYSB0aGUgbGVmdCBoYW5kIHRyYW5zZm9ybVxuICogQHBhcmFtIHtBcnJheX0gYiB0aGUgcmlnaHQgaGFuZCB0cmFuc2Zvcm1cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBtdWx0aXBseSAob3V0LCBhLCBiKSB7XG4gICAgdmFyIGEwMCA9IGFbMF0sIGEwMSA9IGFbMV0sIGEwMiA9IGFbMl0sXG4gICAgICAgIGExMCA9IGFbNF0sIGExMSA9IGFbNV0sIGExMiA9IGFbNl0sXG4gICAgICAgIGEyMCA9IGFbOF0sIGEyMSA9IGFbOV0sIGEyMiA9IGFbMTBdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdO1xuXG4gICAgdmFyIGNoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgcmVzO1xuXG4gICAgLy8gQ2FjaGUgb25seSB0aGUgY3VycmVudCBsaW5lIG9mIHRoZSBzZWNvbmQgbWF0cml4XG4gICAgdmFyIGIwICA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM107XG5cbiAgICByZXMgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogb3V0WzBdID09PSByZXM7XG4gICAgb3V0WzBdID0gcmVzO1xuXG4gICAgcmVzID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkID8gY2hhbmdlZCA6IG91dFsxXSA9PT0gcmVzO1xuICAgIG91dFsxXSA9IHJlcztcblxuICAgIHJlcyA9IGIwKmEwMiArIGIxKmExMiArIGIyKmEyMiArIGIzKmEzMjtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/IGNoYW5nZWQgOiBvdXRbMl0gPT09IHJlcztcbiAgICBvdXRbMl0gPSByZXM7XG5cbiAgICBvdXRbM10gPSAwO1xuXG4gICAgYjAgPSBiWzRdOyBiMSA9IGJbNV07IGIyID0gYls2XTsgYjMgPSBiWzddO1xuXG4gICAgcmVzID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkID8gY2hhbmdlZCA6IG91dFs0XSA9PT0gcmVzO1xuICAgIG91dFs0XSA9IHJlcztcblxuICAgIHJlcyA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/IGNoYW5nZWQgOiBvdXRbNV0gPT09IHJlcztcbiAgICBvdXRbNV0gPSByZXM7XG5cbiAgICByZXMgPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogb3V0WzZdID09PSByZXM7XG4gICAgb3V0WzZdID0gcmVzO1xuXG4gICAgb3V0WzddID0gMDtcblxuICAgIGIwID0gYls4XTsgYjEgPSBiWzldOyBiMiA9IGJbMTBdOyBiMyA9IGJbMTFdO1xuXG4gICAgcmVzID0gYjAqYTAwICsgYjEqYTEwICsgYjIqYTIwICsgYjMqYTMwO1xuICAgIGNoYW5nZWQgPSBjaGFuZ2VkID8gY2hhbmdlZCA6IG91dFs4XSA9PT0gcmVzO1xuICAgIG91dFs4XSA9IHJlcztcblxuICAgIHJlcyA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/IGNoYW5nZWQgOiBvdXRbOV0gPT09IHJlcztcbiAgICBvdXRbOV0gPSByZXM7XG5cbiAgICByZXMgPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogb3V0WzEwXSA9PT0gcmVzO1xuICAgIG91dFsxMF0gPSByZXM7XG5cbiAgICBvdXRbMTFdID0gMDtcblxuICAgIGIwID0gYlsxMl07IGIxID0gYlsxM107IGIyID0gYlsxNF07IGIzID0gYlsxNV07XG5cbiAgICByZXMgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogb3V0WzEyXSA9PT0gcmVzO1xuICAgIG91dFsxMl0gPSByZXM7XG5cbiAgICByZXMgPSBiMCphMDEgKyBiMSphMTEgKyBiMiphMjEgKyBiMyphMzE7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogb3V0WzEzXSA9PT0gcmVzO1xuICAgIG91dFsxM10gPSByZXM7XG5cbiAgICByZXMgPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgY2hhbmdlZCA9IGNoYW5nZWQgPyBjaGFuZ2VkIDogb3V0WzE0XSA9PT0gcmVzO1xuICAgIG91dFsxNF0gPSByZXM7XG5cbiAgICBvdXRbMTVdID0gMTtcblxuICAgIHJldHVybiBjaGFuZ2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aCcpO1xudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vVHJhbnNmb3JtJyk7XG52YXIgRGlzcGF0Y2ggPSByZXF1aXJlKCcuL0Rpc3BhdGNoJyk7XG52YXIgU3lzdGVtID0gcmVxdWlyZSgnLi9TeXN0ZW0nKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvYXNzZXJ0Jyk7XG5cbi8qKlxuICogVGhlIHRyYW5zZm9ybSBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgY2FsY3VsYXRpbmcgdGhlIHRyYW5zZm9ybSBvZiBhIHBhcnRpY3VsYXJcbiAqIG5vZGUgZnJvbSB0aGUgZGF0YSBvbiB0aGUgbm9kZSBhbmQgaXRzIHBhcmVudFxuICpcbiAqIEBjb25zdHJ1Y3RvciB7VHJhbnNmb3JtU3lzdGVtfVxuICovXG5mdW5jdGlvbiBUcmFuc2Zvcm1TeXN0ZW0gKCkge1xuICAgIFN5c3RlbS5jYWxsKHRoaXMpO1xufVxuXG5UcmFuc2Zvcm1TeXN0ZW0ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTeXN0ZW0ucHJvdG90eXBlKTtcblRyYW5zZm9ybVN5c3RlbS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUcmFuc2Zvcm1TeXN0ZW07XG5cbi8qKlxuICogcmVnaXN0ZXJzIGEgbmV3IFRyYW5zZm9ybSBmb3IgdGhlIGdpdmVuIHBhdGguIFRoaXMgdHJhbnNmb3JtIHdpbGwgYmUgdXBkYXRlZFxuICogd2hlbiB0aGUgVHJhbnNmb3JtU3lzdGVtIHVwZGF0ZXMuXG4gKlxuICogQG1ldGhvZCByZWdpc3RlclRyYW5zZm9ybUF0UGF0aFxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBmb3IgdGhlIHRyYW5zZm9ybSB0byBiZSByZWdpc3RlcmVkIHRvLlxuICogQHBhcmFtIHtUcmFuc2Zvcm0gfCB1bmRlZmluZWR9IHRyYW5zZm9ybSBvcHRpb25hbCB0cmFuc2Zvcm0gdG8gcmVnaXN0ZXIuXG4gKi9cblRyYW5zZm9ybVN5c3RlbS5wcm90b3R5cGUucmVnaXN0ZXJUcmFuc2Zvcm1BdFBhdGggPSBmdW5jdGlvbiByZWdpc3RlclRyYW5zZm9ybUF0UGF0aCAocGF0aCwgdHJhbnNmb3JtKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKSB7XG4gICAgICAgIGFzc2VydCh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycsICdwYXRoIG5lZWRzIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgICAgIGFzc2VydCh0cmFuc2Zvcm0gPT09IHVuZGVmaW5lZCB8fCB0cmFuc2Zvcm0uY29uc3RydWN0b3IgPT09IFRyYW5zZm9ybSwgJ3RyYW5zZm9ybSBuZWVkcyB0byBiZSBhIFRyYW5zZm9ybSBpbnN0YW5jZSBvciB1bmRlZmluZWQnKTtcbiAgICB9XG5cbiAgICBpZiAoIVBhdGhVdGlscy5kZXB0aChwYXRoKSlcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5zZXJ0KHBhdGgsIHRyYW5zZm9ybSA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0oKSk7XG5cbiAgICB2YXIgcGFyZW50ID0gdGhpcy5nZXQoUGF0aFV0aWxzLnBhcmVudChwYXRoKSk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydChwYXJlbnQsICd0cmFuc2Zvcm0gbmVlZHMgdG8gYmUgcmVnaXN0ZXJlZCBhdCBwYXRoICcgKyBQYXRoVXRpbHMucGFyZW50KHBhdGgpKTtcblxuICAgIGlmICh0cmFuc2Zvcm0pIHRyYW5zZm9ybS5zZXRQYXJlbnQocGFyZW50KTtcblxuICAgIHRoaXMuaW5zZXJ0KHBhdGgsIHRyYW5zZm9ybSA/IHRyYW5zZm9ybSA6IG5ldyBUcmFuc2Zvcm0ocGFyZW50KSk7XG59O1xuXG4vKipcbiAqIGRlcmVnaXN0ZXJzIGEgdHJhbnNmb3JtIHJlZ2lzdGVyZWQgYXQgdGhlIGdpdmVuIHBhdGguXG4gKlxuICogQG1ldGhvZCBkZXJlZ2lzdGVyVHJhbnNmb3JtQXRQYXRoXG4gKiBAcmV0dXJuIHt2b2lkfVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIGF0IHdoaWNoIHRvIHJlZ2lzdGVyIHRoZSB0cmFuc2Zvcm1cbiAqL1xuVHJhbnNmb3JtU3lzdGVtLnByb3RvdHlwZS5kZXJlZ2lzdGVyVHJhbnNmb3JtQXRQYXRoID0gVHJhbnNmb3JtU3lzdGVtLnByb3RvdHlwZS5yZW1vdmU7XG5cbi8qKlxuICogTWV0aG9kIHdoaWNoIHdpbGwgbWFrZSB0aGUgdHJhbnNmb3JtIGN1cnJlbnRseSBzdG9yZWQgYXQgdGhlIGdpdmVuIHBhdGggYSBicmVha3BvaW50LlxuICogQSB0cmFuc2Zvcm0gYmVpbmcgYSBicmVha3BvaW50IG1lYW5zIHRoYXQgYm90aCBhIGxvY2FsIGFuZCB3b3JsZCB0cmFuc2Zvcm0gd2lsbCBiZSBjYWxjdWxhdGVkXG4gKiBmb3IgdGhhdCBwb2ludC4gVGhlIGxvY2FsIHRyYW5zZm9ybSBiZWluZyB0aGUgY29uY2F0aW5hdGVkIHRyYW5zZm9ybSBvZiBhbGwgYW5jZXN0b3IgdHJhbnNmb3JtcyB1cFxuICogdW50aWwgdGhlIG5lYXJlc3QgYnJlYWtwb2ludCwgYW5kIHRoZSB3b3JsZCBiZWluZyB0aGUgY29uY2F0aW5hdGVkIHRyYW5zZm9ybSBvZiBhbGwgYW5jZXN0b3IgdHJhbnNmb3Jtcy5cbiAqIFRoaXMgbWV0aG9kIHRocm93cyBpZiBubyB0cmFuc2Zvcm0gaXMgYXQgdGhlIHByb3ZpZGVkIHBhdGguXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFRoZSBwYXRoIGF0IHdoaWNoIHRvIHR1cm4gdGhlIHRyYW5zZm9ybSBpbnRvIGEgYnJlYWtwb2ludFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblRyYW5zZm9ybVN5c3RlbS5wcm90b3R5cGUubWFrZUJyZWFrUG9pbnRBdCA9IGZ1bmN0aW9uIG1ha2VCcmVha1BvaW50QXQgKHBhdGgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydCh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycsICdwYXRoIG5lZWRzIHRvIGJlIGEgc3RyaW5nJyk7XG4gICAgdmFyIHRyYW5zZm9ybSA9IHRoaXMuZ2V0KHBhdGgpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHRyYW5zZm9ybSwgJ3RyYW5zZm9ybSBuZWVkcyB0byBiZSByZWdpc3RlcmVkIGF0IHBhdGggJyArIHBhdGgpO1xuICAgIHRyYW5zZm9ybS5zZXRCcmVha1BvaW50KCk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0aGF0IHdpbGwgbWFrZSB0aGUgdHJhbnNmb3JtIGF0IHRoaXMgbG9jYXRpb24gY2FsY3VsYXRlIGEgd29ybGQgbWF0cml4LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBUaGUgcGF0aCBhdCB3aGljaCB0byBtYWtlIHRoZSB0cmFuc2Zvcm0gY2FsY3VsYXRlIGEgd29ybGQgbWF0cml4XG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuVHJhbnNmb3JtU3lzdGVtLnByb3RvdHlwZS5tYWtlQ2FsY3VsYXRlV29ybGRNYXRyaXhBdCA9IGZ1bmN0aW9uIG1ha2VDYWxjdWxhdGVXb3JsZE1hdHJpeEF0IChwYXRoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnLCAncGF0aCBuZWVkcyB0byBiZSBhIHN0cmluZycpO1xuICAgIHZhciB0cmFuc2Zvcm0gPSB0aGlzLmdldChwYXRoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydCh0cmFuc2Zvcm0sICd0cmFuc2Zvcm0gbmVlZHMgdG8gYmUgcmVnaXN0ZXJlZCBhdCBwYXRoICcgKyBwYXRoKTtcbiAgICB0cmFuc2Zvcm0uc2V0Q2FsY3VsYXRlV29ybGRNYXRyaXgoKTtcbn07XG5cbi8qKlxuICogdXBkYXRlIGlzIGNhbGxlZCB3aGVuIHRoZSB0cmFuc2Zvcm0gc3lzdGVtIHJlcXVpcmVzIGFuIHVwZGF0ZS5cbiAqIEl0IHRyYXZlcnNlcyB0aGUgdHJhbnNmb3JtIGFycmF5IGFuZCBldmFsdWF0ZXMgdGhlIG5lY2Vzc2FyeSB0cmFuc2Zvcm1zXG4gKiBpbiB0aGUgc2NlbmUgZ3JhcGggd2l0aCB0aGUgaW5mb3JtYXRpb24gZnJvbSB0aGUgY29ycmVzcG9uZGluZyBub2RlXG4gKiBpbiB0aGUgc2NlbmUgZ3JhcGhcbiAqXG4gKiBAbWV0aG9kIHVwZGF0ZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblRyYW5zZm9ybVN5c3RlbS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgICB2YXIgdHJhbnNmb3JtcyA9IHRoaXMuZ2V0SXRlbXMoKTtcbiAgICB2YXIgcGF0aHMgPSB0aGlzLmdldFBhdGhzKCk7XG4gICAgdmFyIHRyYW5zZm9ybTtcbiAgICB2YXIgY2hhbmdlZDtcbiAgICB2YXIgbm9kZTtcbiAgICB2YXIgdmVjdG9ycztcbiAgICB2YXIgb2Zmc2V0cztcbiAgICB2YXIgY29tcG9uZW50cztcbiAgICB2YXIgbmVlZHNSZWNhbGMgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspIHtcbiAgICAgICAgbm9kZSA9IERpc3BhdGNoLmdldE5vZGUocGF0aHNbaV0pO1xuICAgICAgICBpZiAoIW5vZGUpIGNvbnRpbnVlO1xuICAgICAgICBjb21wb25lbnRzID0gbm9kZS5nZXRDb21wb25lbnRzKCk7XG4gICAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbaV07XG4gICAgICAgIHZlY3RvcnMgPSB0cmFuc2Zvcm0udmVjdG9ycztcbiAgICAgICAgb2Zmc2V0cyA9IHRyYW5zZm9ybS5vZmZzZXRzO1xuXG4gICAgICAgIG5lZWRzUmVjYWxjID1cbiAgICAgICAgICAgIG9mZnNldHMuYWxpZ25DaGFuZ2VkIHx8XG4gICAgICAgICAgICBvZmZzZXRzLm1vdW50UG9pbnRDaGFuZ2VkIHx8XG4gICAgICAgICAgICBvZmZzZXRzLm9yaWdpbkNoYW5nZWQgfHxcbiAgICAgICAgICAgIHZlY3RvcnMucG9zaXRpb25DaGFuZ2VkIHx8XG4gICAgICAgICAgICB2ZWN0b3JzLnJvdGF0aW9uQ2hhbmdlZCB8fFxuICAgICAgICAgICAgdmVjdG9ycy5zY2FsZUNoYW5nZWQgfHxcbiAgICAgICAgICAgICh0cmFuc2Zvcm0ucGFyZW50ICYmIHRyYW5zZm9ybS5wYXJlbnQuX25lZWRzUmVjYWxjKSB8fFxuICAgICAgICAgICAgdHJhbnNmb3JtLl9kaXJ0eUZyb21TaXplQ2hhbmdlO1xuXG4gICAgICAgIHRyYW5zZm9ybS5fZGlydHlGcm9tU2l6ZUNoYW5nZSA9IGZhbHNlO1xuICAgICAgICB0cmFuc2Zvcm0uX25lZWRzUmVjYWxjID0gbmVlZHNSZWNhbGM7XG5cbiAgICAgICAgaWYgKG9mZnNldHMuYWxpZ25DaGFuZ2VkKSBhbGlnbkNoYW5nZWQobm9kZSwgY29tcG9uZW50cywgb2Zmc2V0cyk7XG4gICAgICAgIGlmIChvZmZzZXRzLm1vdW50UG9pbnRDaGFuZ2VkKSBtb3VudFBvaW50Q2hhbmdlZChub2RlLCBjb21wb25lbnRzLCBvZmZzZXRzKTtcbiAgICAgICAgaWYgKG9mZnNldHMub3JpZ2luQ2hhbmdlZCkgb3JpZ2luQ2hhbmdlZChub2RlLCBjb21wb25lbnRzLCBvZmZzZXRzKTtcbiAgICAgICAgaWYgKHZlY3RvcnMucG9zaXRpb25DaGFuZ2VkKSBwb3NpdGlvbkNoYW5nZWQobm9kZSwgY29tcG9uZW50cywgdmVjdG9ycyk7XG4gICAgICAgIGlmICh2ZWN0b3JzLnJvdGF0aW9uQ2hhbmdlZCkgcm90YXRpb25DaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHZlY3RvcnMpO1xuICAgICAgICBpZiAodmVjdG9ycy5zY2FsZUNoYW5nZWQpIHNjYWxlQ2hhbmdlZChub2RlLCBjb21wb25lbnRzLCB2ZWN0b3JzKTtcblxuICAgICAgICBpZiAobmVlZHNSZWNhbGMpIHtcbiAgICAgICAgICAgIGlmICgoY2hhbmdlZCA9IHRyYW5zZm9ybS5jYWxjdWxhdGUobm9kZSkpKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNmb3JtQ2hhbmdlZChub2RlLCBjb21wb25lbnRzLCB0cmFuc2Zvcm0pO1xuICAgICAgICAgICAgICAgIGlmIChjaGFuZ2VkICYgVHJhbnNmb3JtLkxPQ0FMX0NIQU5HRUQpIGxvY2FsVHJhbnNmb3JtQ2hhbmdlZChub2RlLCBjb21wb25lbnRzLCB0cmFuc2Zvcm0uZ2V0TG9jYWxUcmFuc2Zvcm0oKSk7XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5nZWQgJiBUcmFuc2Zvcm0uV09STERfQ0hBTkdFRCkgd29ybGRUcmFuc2Zvcm1DaGFuZ2VkKG5vZGUsIGNvbXBvbmVudHMsIHRyYW5zZm9ybS5nZXRXb3JsZFRyYW5zZm9ybSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gY2FsbCB3aGVuIGFsaWduIGNoYW5nZXMuIFRyaWdnZXJzICdvbkFsaWduQ2hhbmdlJyBtZXRob2RzXG4gKiBvbiB0aGUgbm9kZSBhbmQgYWxsIG9mIHRoZSBub2RlJ3MgY29tcG9uZW50c1xuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIHRoZSBub2RlIG9uIHdoaWNoIHRvIGNhbGwgb25BbGlnbkNoYW5nZSBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgdGhlIGNvbXBvbmVudHMgb24gd2hpY2ggdG8gY2FsbCBvbkFsaWduQ2hhbmdlIGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtPYmplY3R9IG9mZnNldHMgdGhlIHNldCBvZiBvZmZzZXRzIGZyb20gdGhlIHRyYW5zZm9ybVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGFsaWduQ2hhbmdlZCAobm9kZSwgY29tcG9uZW50cywgb2Zmc2V0cykge1xuICAgIHZhciB4ID0gb2Zmc2V0cy5hbGlnblswXTtcbiAgICB2YXIgeSA9IG9mZnNldHMuYWxpZ25bMV07XG4gICAgdmFyIHogPSBvZmZzZXRzLmFsaWduWzJdO1xuICAgIGlmIChub2RlLm9uQWxpZ25DaGFuZ2UpIG5vZGUub25BbGlnbkNoYW5nZSh4LCB5LCB6KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uQWxpZ25DaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uQWxpZ25DaGFuZ2UoeCwgeSwgeik7XG4gICAgb2Zmc2V0cy5hbGlnbkNoYW5nZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byBjYWxsIHdoZW4gTW91bnRQb2ludCBjaGFuZ2VzLiBUcmlnZ2VycyAnb25Nb3VudFBvaW50Q2hhbmdlJyBtZXRob2RzXG4gKiBvbiB0aGUgbm9kZSBhbmQgYWxsIG9mIHRoZSBub2RlJ3MgY29tcG9uZW50c1xuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIHRoZSBub2RlIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIHRoZSBjb21wb25lbnRzIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0cyB0aGUgc2V0IG9mIG9mZnNldHMgZnJvbSB0aGUgdHJhbnNmb3JtXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gbW91bnRQb2ludENoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIG9mZnNldHMpIHtcbiAgICB2YXIgeCA9IG9mZnNldHMubW91bnRQb2ludFswXTtcbiAgICB2YXIgeSA9IG9mZnNldHMubW91bnRQb2ludFsxXTtcbiAgICB2YXIgeiA9IG9mZnNldHMubW91bnRQb2ludFsyXTtcbiAgICBpZiAobm9kZS5vbk1vdW50UG9pbnRDaGFuZ2UpIG5vZGUub25Nb3VudFBvaW50Q2hhbmdlKHgsIHksIHopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25Nb3VudFBvaW50Q2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbk1vdW50UG9pbnRDaGFuZ2UoeCwgeSwgeik7XG4gICAgb2Zmc2V0cy5tb3VudFBvaW50Q2hhbmdlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGNhbGwgd2hlbiBPcmlnaW4gY2hhbmdlcy4gVHJpZ2dlcnMgJ29uT3JpZ2luQ2hhbmdlJyBtZXRob2RzXG4gKiBvbiB0aGUgbm9kZSBhbmQgYWxsIG9mIHRoZSBub2RlJ3MgY29tcG9uZW50c1xuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIHRoZSBub2RlIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIHRoZSBjb21wb25lbnRzIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge09iamVjdH0gb2Zmc2V0cyB0aGUgc2V0IG9mIG9mZnNldHMgZnJvbSB0aGUgdHJhbnNmb3JtXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gb3JpZ2luQ2hhbmdlZCAobm9kZSwgY29tcG9uZW50cywgb2Zmc2V0cykge1xuICAgIHZhciB4ID0gb2Zmc2V0cy5vcmlnaW5bMF07XG4gICAgdmFyIHkgPSBvZmZzZXRzLm9yaWdpblsxXTtcbiAgICB2YXIgeiA9IG9mZnNldHMub3JpZ2luWzJdO1xuICAgIGlmIChub2RlLm9uT3JpZ2luQ2hhbmdlKSBub2RlLm9uT3JpZ2luQ2hhbmdlKHgsIHksIHopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25PcmlnaW5DaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uT3JpZ2luQ2hhbmdlKHgsIHksIHopO1xuICAgIG9mZnNldHMub3JpZ2luQ2hhbmdlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGNhbGwgd2hlbiBQb3NpdGlvbiBjaGFuZ2VzLiBUcmlnZ2VycyAnb25Qb3NpdGlvbkNoYW5nZScgbWV0aG9kc1xuICogb24gdGhlIG5vZGUgYW5kIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHNcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0aGUgbm9kZSBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50cyB0aGUgY29tcG9uZW50cyBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtPYmplY3R9IHZlY3RvcnMgdGhlIHNldCBvZiB2ZWN0b3JzIGZyb20gdGhlIHRyYW5zZm9ybVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHBvc2l0aW9uQ2hhbmdlZCAobm9kZSwgY29tcG9uZW50cywgdmVjdG9ycykge1xuICAgIHZhciB4ID0gdmVjdG9ycy5wb3NpdGlvblswXTtcbiAgICB2YXIgeSA9IHZlY3RvcnMucG9zaXRpb25bMV07XG4gICAgdmFyIHogPSB2ZWN0b3JzLnBvc2l0aW9uWzJdO1xuICAgIGlmIChub2RlLm9uUG9zaXRpb25DaGFuZ2UpIG5vZGUub25Qb3NpdGlvbkNoYW5nZSh4LCB5LCB6KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uUG9zaXRpb25DaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uUG9zaXRpb25DaGFuZ2UoeCwgeSwgeik7XG4gICAgdmVjdG9ycy5wb3NpdGlvbkNoYW5nZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byBjYWxsIHdoZW4gUm90YXRpb24gY2hhbmdlcy4gVHJpZ2dlcnMgJ29uUm90YXRpb25DaGFuZ2UnIG1ldGhvZHNcbiAqIG9uIHRoZSBub2RlIGFuZCBhbGwgb2YgdGhlIG5vZGUncyBjb21wb25lbnRzXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdGhlIG5vZGUgb24gd2hpY2ggdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgdGhlIGNvbXBvbmVudHMgb24gd2hpY2ggdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7T2JqZWN0fSB2ZWN0b3JzIHRoZSBzZXQgb2YgdmVjdG9ycyBmcm9tIHRoZSB0cmFuc2Zvcm1cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiByb3RhdGlvbkNoYW5nZWQgKG5vZGUsIGNvbXBvbmVudHMsIHZlY3RvcnMpIHtcbiAgICB2YXIgeCA9IHZlY3RvcnMucm90YXRpb25bMF07XG4gICAgdmFyIHkgPSB2ZWN0b3JzLnJvdGF0aW9uWzFdO1xuICAgIHZhciB6ID0gdmVjdG9ycy5yb3RhdGlvblsyXTtcbiAgICB2YXIgdyA9IHZlY3RvcnMucm90YXRpb25bM107XG4gICAgaWYgKG5vZGUub25Sb3RhdGlvbkNoYW5nZSkgbm9kZS5vblJvdGF0aW9uQ2hhbmdlKHgsIHksIHosIHcpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBjb21wb25lbnRzLmxlbmd0aCA7IGkgPCBsZW4gOyBpKyspXG4gICAgICAgIGlmIChjb21wb25lbnRzW2ldICYmIGNvbXBvbmVudHNbaV0ub25Sb3RhdGlvbkNoYW5nZSlcbiAgICAgICAgICAgIGNvbXBvbmVudHNbaV0ub25Sb3RhdGlvbkNoYW5nZSh4LCB5LCB6LCB3KTtcbiAgICB2ZWN0b3JzLnJvdGF0aW9uQ2hhbmdlZCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGNhbGwgd2hlbiBTY2FsZSBjaGFuZ2VzLiBUcmlnZ2VycyAnb25TY2FsZUNoYW5nZScgbWV0aG9kc1xuICogb24gdGhlIG5vZGUgYW5kIGFsbCBvZiB0aGUgbm9kZSdzIGNvbXBvbmVudHNcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7Tm9kZX0gbm9kZSB0aGUgbm9kZSBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtBcnJheX0gY29tcG9uZW50cyB0aGUgY29tcG9uZW50cyBvbiB3aGljaCB0byB0cmlnZ2VyIGEgY2hhbmdlIGV2ZW50IGlmIG5lY2Vzc2FyeVxuICogQHBhcmFtIHtPYmplY3R9IHZlY3RvcnMgdGhlIHNldCBvZiB2ZWN0b3JzIGZyb20gdGhlIHRyYW5zZm9ybVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIHNjYWxlQ2hhbmdlZCAobm9kZSwgY29tcG9uZW50cywgdmVjdG9ycykge1xuICAgIHZhciB4ID0gdmVjdG9ycy5zY2FsZVswXTtcbiAgICB2YXIgeSA9IHZlY3RvcnMuc2NhbGVbMV07XG4gICAgdmFyIHogPSB2ZWN0b3JzLnNjYWxlWzJdO1xuICAgIGlmIChub2RlLm9uU2NhbGVDaGFuZ2UpIG5vZGUub25TY2FsZUNoYW5nZSh4LCB5LCB6KTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uU2NhbGVDaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uU2NhbGVDaGFuZ2UoeCwgeSwgeik7XG4gICAgdmVjdG9ycy5zY2FsZUNoYW5nZWQgPSBmYWxzZTtcbn1cblxuLyoqXG4gKiBQcml2YXRlIG1ldGhvZCB0byBjYWxsIHdoZW4gZWl0aGVyIHRoZSBMb2NhbCBvciBXb3JsZCBUcmFuc2Zvcm0gY2hhbmdlcy5cbiAqIFRyaWdnZXJzICdvblRyYW5zZm9ybUNoYW5nZScgbWV0aG9kcyBvbiB0aGUgbm9kZSBhbmQgYWxsIG9mIHRoZSBub2RlJ3MgY29tcG9uZW50c1xuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIHRoZSBub2RlIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIHRoZSBjb21wb25lbnRzIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge1RyYW5zZm9ybX0gdHJhbnNmb3JtIHRoZSB0cmFuc2Zvcm0gY2xhc3MgdGhhdCBjaGFuZ2VkXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQ2hhbmdlZCAobm9kZSwgY29tcG9uZW50cywgdHJhbnNmb3JtKSB7XG4gICAgaWYgKG5vZGUub25UcmFuc2Zvcm1DaGFuZ2UpIG5vZGUub25UcmFuc2Zvcm1DaGFuZ2UodHJhbnNmb3JtKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uVHJhbnNmb3JtQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vblRyYW5zZm9ybUNoYW5nZSh0cmFuc2Zvcm0pO1xufVxuXG4vKipcbiAqIFByaXZhdGUgbWV0aG9kIHRvIGNhbGwgd2hlbiB0aGUgbG9jYWwgdHJhbnNmb3JtIGNoYW5nZXMuIFRyaWdnZXJzICdvbkxvY2FsVHJhbnNmb3JtQ2hhbmdlJyBtZXRob2RzXG4gKiBvbiB0aGUgbm9kZSBhbmQgYWxsIG9mIHRoZSBub2RlJ3MgY29tcG9uZW50c1xuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlIHRoZSBub2RlIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge0FycmF5fSBjb21wb25lbnRzIHRoZSBjb21wb25lbnRzIG9uIHdoaWNoIHRvIHRyaWdnZXIgYSBjaGFuZ2UgZXZlbnQgaWYgbmVjZXNzYXJ5XG4gKiBAcGFyYW0ge0FycmF5fSB0cmFuc2Zvcm0gdGhlIGxvY2FsIHRyYW5zZm9ybVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbmZ1bmN0aW9uIGxvY2FsVHJhbnNmb3JtQ2hhbmdlZCAobm9kZSwgY29tcG9uZW50cywgdHJhbnNmb3JtKSB7XG4gICAgaWYgKG5vZGUub25Mb2NhbFRyYW5zZm9ybUNoYW5nZSkgbm9kZS5vbkxvY2FsVHJhbnNmb3JtQ2hhbmdlKHRyYW5zZm9ybSk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvbXBvbmVudHMubGVuZ3RoIDsgaSA8IGxlbiA7IGkrKylcbiAgICAgICAgaWYgKGNvbXBvbmVudHNbaV0gJiYgY29tcG9uZW50c1tpXS5vbkxvY2FsVHJhbnNmb3JtQ2hhbmdlKVxuICAgICAgICAgICAgY29tcG9uZW50c1tpXS5vbkxvY2FsVHJhbnNmb3JtQ2hhbmdlKHRyYW5zZm9ybSk7XG59XG5cbi8qKlxuICogUHJpdmF0ZSBtZXRob2QgdG8gY2FsbCB3aGVuIHRoZSB3b3JsZCB0cmFuc2Zvcm0gY2hhbmdlcy4gVHJpZ2dlcnMgJ29uV29ybGRUcmFuc2Zvcm1DaGFuZ2UnIG1ldGhvZHNcbiAqIG9uIHRoZSBub2RlIGFuZCBhbGwgb2YgdGhlIG5vZGUncyBjb21wb25lbnRzXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgdGhlIG5vZGUgb24gd2hpY2ggdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7QXJyYXl9IGNvbXBvbmVudHMgdGhlIGNvbXBvbmVudHMgb24gd2hpY2ggdG8gdHJpZ2dlciBhIGNoYW5nZSBldmVudCBpZiBuZWNlc3NhcnlcbiAqIEBwYXJhbSB7QXJyYXl9IHRyYW5zZm9ybSB0aGUgd29ybGQgdHJhbnNmb3JtXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuZnVuY3Rpb24gd29ybGRUcmFuc2Zvcm1DaGFuZ2VkIChub2RlLCBjb21wb25lbnRzLCB0cmFuc2Zvcm0pIHtcbiAgICBpZiAobm9kZS5vbldvcmxkVHJhbnNmb3JtQ2hhbmdlKSBub2RlLm9uV29ybGRUcmFuc2Zvcm1DaGFuZ2UodHJhbnNmb3JtKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY29tcG9uZW50cy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICBpZiAoY29tcG9uZW50c1tpXSAmJiBjb21wb25lbnRzW2ldLm9uV29ybGRUcmFuc2Zvcm1DaGFuZ2UpXG4gICAgICAgICAgICBjb21wb25lbnRzW2ldLm9uV29ybGRUcmFuc2Zvcm1DaGFuZ2UodHJhbnNmb3JtKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBuZXcgVHJhbnNmb3JtU3lzdGVtKCk7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvRXZlbnRFbWl0dGVyJyk7XG52YXIgVHJhbnNmb3JtU3lzdGVtID0gcmVxdWlyZSgnLi4vY29yZS9UcmFuc2Zvcm1TeXN0ZW0nKTtcbnZhciBPcGFjaXR5U3lzdGVtID0gcmVxdWlyZSgnLi4vY29yZS9PcGFjaXR5U3lzdGVtJyk7XG52YXIgQ29tbWFuZHMgPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1hbmRzJyk7XG52YXIgU2l6ZSA9IHJlcXVpcmUoJy4uL2NvcmUvU2l6ZScpO1xuXG4vKipcbiAqIEEgRE9NRWxlbWVudCBpcyBhIGNvbXBvbmVudCB0aGF0IGNhbiBiZSBhZGRlZCB0byBhIE5vZGUgd2l0aCB0aGVcbiAqIHB1cnBvc2Ugb2Ygc2VuZGluZyBkcmF3IGNvbW1hbmRzIHRvIHRoZSByZW5kZXJlci4gUmVuZGVyYWJsZXMgc2VuZCBkcmF3IGNvbW1hbmRzXG4gKiB0byB0aHJvdWdoIHRoZWlyIE5vZGVzIHRvIHRoZSBDb21wb3NpdG9yIHdoZXJlIHRoZXkgYXJlIGFjdGVkIHVwb24uXG4gKlxuICogQGNsYXNzIERPTUVsZW1lbnRcbiAqXG4gKiBAcGFyYW0ge05vZGV9IFtub2RlXSAgICAgICAgICAgICAgICAgVGhlIE5vZGUgdG8gd2hpY2ggdGhlIGBET01FbGVtZW50YFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlcmFibGUgc2hvdWxkIGJlIGF0dGFjaGVkIHRvLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgICAgICAgICAgICAgIEluaXRpYWwgb3B0aW9ucyB1c2VkIGZvciBpbnN0YW50aWF0aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIE5vZGUuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5zdHlsZSAgICAgICAgQ1NTIHN0eWxlIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGFjdHVhbCBET01FbGVtZW50IG9uIHRoZSBpbml0aWFsIGRyYXcuXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucy5hdHRyaWJ1dGVzICAgRWxlbWVudCBhdHRyaWJ1dGVzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIGFjdHVhbCBET01FbGVtZW50LlxuICogQHBhcmFtIHtTdHJpbmd9IG9wdGlvbnMuaWQgICAgICAgICAgIFN0cmluZyB0byBiZSBhcHBsaWVkIGFzICdpZCcgb2YgdGhlIGFjdHVhbFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIERPTUVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gb3B0aW9ucy5jb250ZW50ICAgICAgU3RyaW5nIHRvIGJlIGFwcGxpZWQgYXMgdGhlIGNvbnRlbnQgb2YgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsIERPTUVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIERPTUVsZW1lbnQobm9kZSwgb3B0aW9ucykge1xuICAgIGlmIChub2RlICYmIG5vZGUuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICBvcHRpb25zID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZSA9IFtdO1xuXG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3JlbmRlclNpemVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVxdWVzdFJlbmRlclNpemUgPSBmYWxzZTtcblxuICAgIHRoaXMuX1VJRXZlbnRzID0gW107XG4gICAgdGhpcy5fY2xhc3NlcyA9IFsnZmFtb3VzLWRvbS1lbGVtZW50J10uY29uY2F0KG9wdGlvbnMuY2xhc3Nlcyk7XG4gICAgdGhpcy5fcmVxdWVzdGluZ0V2ZW50TGlzdGVuZXJzID0gW107XG5cbiAgICBpZiAob3B0aW9ucy5wcm9wZXJ0aWVzKVxuICAgICAgICBjb25zb2xlLndhcm4oJ0RPTUVsZW1lbnQgcHJvcGVydGllcyBoYXZlIGJlZW4gcmVuYW1lZCB0byBzdHlsZScpO1xuXG4gICAgdGhpcy5fc3R5bGUgPSBvcHRpb25zLnByb3BlcnRpZXMgfHwgb3B0aW9ucy5zdHlsZSB8fCB7fTtcbiAgICB0aGlzLl9hdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuXG4gICAgaWYgKG9wdGlvbnMuaWQgIT0gbnVsbClcbiAgICAgICAgdGhpcy5fYXR0cmlidXRlcy5pZCA9IG9wdGlvbnMuaWQ7XG5cbiAgICB0aGlzLl9jb250ZW50ID0gb3B0aW9ucy5jb250ZW50IHx8ICcnO1xuICAgIHRoaXMuX3RhZ05hbWUgPSBvcHRpb25zLnRhZ05hbWUgfHwgJ2Rpdic7XG4gICAgdGhpcy5fcmVuZGVyU2l6ZSA9IFswLCAwLCAwXTtcblxuICAgIHRoaXMuX25vZGUgPSBudWxsO1xuICAgIHRoaXMuX2lkID0gbnVsbDtcblxuICAgIHRoaXMuX2V2ZW50cyA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIGlmIChvcHRpb25zLmRvY3VtZW50RmxvdyAhPSBudWxsKVxuICAgICAgICB0aGlzLmRvY3VtZW50RmxvdyhvcHRpb25zLmRvY3VtZW50Rmxvdyk7XG5cbiAgICBpZiAobm9kZSkgbm9kZS5hZGRDb21wb25lbnQodGhpcyk7XG59XG5cbi8qKlxuICogU2VyaWFsaXplcyB0aGUgc3RhdGUgb2YgdGhlIERPTUVsZW1lbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gc2VyaWFsaXplZCBpbnRlcmFsIHN0YXRlXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gZ2V0VmFsdWUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2xhc3NlczogdGhpcy5fY2xhc3NlcyxcbiAgICAgICAgc3R5bGU6IHRoaXMuX3N0eWxlLFxuICAgICAgICBhdHRyaWJ1dGVzOiB0aGlzLl9hdHRyaWJ1dGVzLFxuICAgICAgICBjb250ZW50OiB0aGlzLl9jb250ZW50LFxuICAgICAgICBpZDogdGhpcy5fYXR0cmlidXRlcy5pZCxcbiAgICAgICAgdGFnTmFtZTogdGhpcy5fdGFnTmFtZVxuICAgIH07XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgYW4gdXBkYXRlIG9jY3Vycy4gVGhpcyBhbGxvd3NcbiAqIHRoZSBET01FbGVtZW50IHJlbmRlcmFibGUgdG8gZHluYW1pY2FsbHkgcmVhY3QgdG8gc3RhdGUgY2hhbmdlcyBvbiB0aGUgTm9kZS5cbiAqXG4gKiBUaGlzIGZsdXNoZXMgdGhlIGludGVybmFsIGRyYXcgY29tbWFuZCBxdWV1ZSBieSBzZW5kaW5nIGluZGl2aWR1YWwgY29tbWFuZHNcbiAqIHRvIHRoZSBub2RlIHVzaW5nIGBzZW5kRHJhd0NvbW1hbmRgLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblVwZGF0ZSA9IGZ1bmN0aW9uIG9uVXBkYXRlICgpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMuX25vZGU7XG4gICAgdmFyIHF1ZXVlID0gdGhpcy5fY2hhbmdlUXVldWU7XG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcblxuICAgIGlmIChsZW4gJiYgbm9kZSkge1xuICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZChDb21tYW5kcy5XSVRIKTtcbiAgICAgICAgbm9kZS5zZW5kRHJhd0NvbW1hbmQobm9kZS5nZXRMb2NhdGlvbigpKTtcblxuICAgICAgICB3aGlsZSAobGVuLS0pIG5vZGUuc2VuZERyYXdDb21tYW5kKHF1ZXVlLnNoaWZ0KCkpO1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdFJlbmRlclNpemUpIHtcbiAgICAgICAgICAgIG5vZGUuc2VuZERyYXdDb21tYW5kKENvbW1hbmRzLkRPTV9SRU5ERVJfU0laRSk7XG4gICAgICAgICAgICBub2RlLnNlbmREcmF3Q29tbWFuZChub2RlLmdldExvY2F0aW9uKCkpO1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFJlbmRlclNpemUgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgfVxuXG4gICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgTm9kZSBhcyBzb29uIGFzIHRoZSBub2RlIChvciBhbnkgb2YgaXRzXG4gKiBhbmNlc3RvcnMpIGlzIGJlaW5nIG1vdW50ZWQuXG4gKlxuICogQG1ldGhvZCBvbk1vdW50XG4gKlxuICogQHBhcmFtIHtOb2RlfSBub2RlICAgICAgUGFyZW50IG5vZGUgdG8gd2hpY2ggdGhlIGNvbXBvbmVudCBzaG91bGQgYmUgYWRkZWQuXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgICAgICBQYXRoIGF0IHdoaWNoIHRoZSBjb21wb25lbnQgKG9yIG5vZGUpIGlzIGJlaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0YWNoZWQuIFRoZSBwYXRoIGlzIGJlaW5nIHNldCBvbiB0aGUgYWN0dWFsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgRE9NRWxlbWVudCBhcyBhIGBkYXRhLWZhLXBhdGhgLWF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vbk1vdW50ID0gZnVuY3Rpb24gb25Nb3VudChub2RlLCBpZCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGtleTtcblxuICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgdGhpcy5fVUlFdmVudHMgPSBub2RlLmdldFVJRXZlbnRzKCkuc2xpY2UoMCk7XG5cbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLklOSVRfRE9NLCB0aGlzLl90YWdOYW1lKTtcblxuICAgIFRyYW5zZm9ybVN5c3RlbS5tYWtlQnJlYWtQb2ludEF0KG5vZGUuZ2V0TG9jYXRpb24oKSk7XG4gICAgT3BhY2l0eVN5c3RlbS5tYWtlQnJlYWtQb2ludEF0KG5vZGUuZ2V0TG9jYXRpb24oKSk7XG5cbiAgICB0aGlzLl9pbkRyYXcgPSB0cnVlO1xuICAgIHRoaXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIHRoaXMub25TaXplTW9kZUNoYW5nZS5hcHBseSh0aGlzLCBub2RlLmdldFNpemVNb2RlKCkpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdkYXRhLWZhLXBhdGgnLCBub2RlLmdldExvY2F0aW9uKCkpO1xuXG4gICAgdGhpcy5vblRyYW5zZm9ybUNoYW5nZShUcmFuc2Zvcm1TeXN0ZW0uZ2V0KHRoaXMuX25vZGUuZ2V0TG9jYXRpb24oKSkpO1xuICAgIHRoaXMub25PcGFjaXR5Q2hhbmdlKE9wYWNpdHlTeXN0ZW0uZ2V0KHRoaXMuX25vZGUuZ2V0TG9jYXRpb24oKSkpO1xuXG4gICAgZm9yIChpID0gMCwgbGVuID0gdGhpcy5fY2xhc3Nlcy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgdGhpcy5hZGRDbGFzcyh0aGlzLl9jbGFzc2VzW2ldKTtcblxuICAgIGZvciAoa2V5IGluIHRoaXMuX2F0dHJpYnV0ZXMpXG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKGtleSwgdGhpcy5fYXR0cmlidXRlc1trZXldKTtcblxuICAgIGZvciAoa2V5IGluIHRoaXMuX3N0eWxlKVxuICAgICAgICB0aGlzLnNldFN0eWxlKGtleSwgdGhpcy5fc3R5bGVba2V5XSk7XG5cbiAgICB0aGlzLnNldENvbnRlbnQodGhpcy5fY29udGVudCk7XG5cbiAgICBmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9VSUV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKylcbiAgICAgICAgdGhpcy5vbkFkZFVJRXZlbnQodGhpcy5fVUlFdmVudHNbaV0pO1xuXG4gICAgdGhpcy5faW5EcmF3ID0gZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIE5vZGUgYXMgc29vbiBhcyB0aGUgbm9kZSBpcyBiZWluZyBkaXNtb3VudGVkXG4gKiBlaXRoZXIgZGlyZWN0bHkgb3IgYnkgZGlzbW91bnRpbmcgb25lIG9mIGl0cyBhbmNlc3RvcnMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uRGlzbW91bnQgPSBmdW5jdGlvbiBvbkRpc21vdW50KCkge1xuICAgIHRoaXMuc2V0U3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdkYXRhLWZhLXBhdGgnLCAnJyk7XG5cbiAgICB0aGlzLm9uVXBkYXRlKCk7XG4gICAgdGhpcy5faW5pdGlhbGl6ZWQgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIG5vZGUgYXMgc29vbiBhcyB0aGUgRE9NRWxlbWVudCBpcyBiZWluZyBzaG93bi5cbiAqIFRoaXMgcmVzdWx0cyBpbnRvIHRoZSBET01FbGVtZW50IHNldHRpbmcgdGhlIGBkaXNwbGF5YCBwcm9wZXJ0eSB0byBgYmxvY2tgXG4gKiBhbmQgdGhlcmVmb3JlIHZpc3VhbGx5IHNob3dpbmcgdGhlIGNvcnJlc3BvbmRpbmcgRE9NRWxlbWVudCAoYWdhaW4pLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblNob3cgPSBmdW5jdGlvbiBvblNob3coKSB7XG4gICAgdGhpcy5zZXRTdHlsZSgnZGlzcGxheScsICdibG9jaycpO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgbm9kZSBhcyBzb29uIGFzIHRoZSBET01FbGVtZW50IGlzIGJlaW5nIGhpZGRlbi5cbiAqIFRoaXMgcmVzdWx0cyBpbnRvIHRoZSBET01FbGVtZW50IHNldHRpbmcgdGhlIGBkaXNwbGF5YCBwcm9wZXJ0eSB0byBgbm9uZWBcbiAqIGFuZCB0aGVyZWZvcmUgdmlzdWFsbHkgaGlkaW5nIHRoZSBjb3JyZXNwb25kaW5nIERPTUVsZW1lbnQgKGFnYWluKS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25IaWRlID0gZnVuY3Rpb24gb25IaWRlKCkge1xuICAgIHRoaXMuc2V0U3R5bGUoJ2Rpc3BsYXknLCAnbm9uZScpO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdGhhdCByZW1vdmVzIHRoZSBhYnNvbHV0ZSBwb3NpdGlvbmluZyBhbmQgRE9NIHN0eWxpbmcgb24gdGhlIERPTUVsZW1lbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25vZmYgd2hldGhlciBvciBub3QgdGhlIERPTUVsZW1lbnQgc2hvdWxkIGhhdmUgZG9jdW1lbnQgZmxvd1xuICpcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoaXNcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuZG9jdW1lbnRGbG93ID0gZnVuY3Rpb24gZG9jdW1lbnRGbG93KG9ub2ZmKSB7XG4gICAgaWYgKG9ub2ZmKSB0aGlzLnJlbW92ZUNsYXNzKCdmYW1vdXMtZG9tLWVsZW1lbnQnKTtcbiAgICBlbHNlIHRoaXMuYWRkQ2xhc3MoJ2ZhbW91cy1kb20tZWxlbWVudCcpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgbm9kZSBhcyBzb29uIGFzIHRoZSB0cmFuc2Zvcm0gbWF0cml4IGFzc29jaWF0ZWRcbiAqIHdpdGggdGhlIG5vZGUgY2hhbmdlcy4gVGhlIERPTUVsZW1lbnQgd2lsbCByZWFjdCB0byB0cmFuc2Zvcm0gY2hhbmdlcyBieSBzZW5kaW5nXG4gKiBgQ0hBTkdFX1RSQU5TRk9STWAgY29tbWFuZHMgdG8gdGhlIGBET01SZW5kZXJlcmAuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB0cmFuc2Zvcm0gVGhlIGZpbmFsIHRyYW5zZm9ybSBtYXRyaXhcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblRyYW5zZm9ybUNoYW5nZSA9IGZ1bmN0aW9uIG9uVHJhbnNmb3JtQ2hhbmdlICh0cmFuc2Zvcm0pIHtcbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLkNIQU5HRV9UUkFOU0ZPUk0pO1xuICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5nZXRMb2NhbFRyYW5zZm9ybSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRyYW5zZm9ybS5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKVxuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKHRyYW5zZm9ybVtpXSk7XG5cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIGludm9rZWQgYnkgdGhlIG5vZGUgYXMgc29vbiBhcyBpdHMgY29tcHV0ZWQgc2l6ZSBjaGFuZ2VzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCB3aWR0aCBvZiB0aGUgTm9kZSB0aGUgRE9NRWxlbWVudCBpcyBhdHRhY2hlZCB0b1xuICogQHBhcmFtIHtOdW1iZXJ9IHkgaGVpZ2h0IG9mIHRoZSBOb2RlIHRoZSBET01FbGVtZW50IGlzIGF0dGFjaGVkIHRvXG4gKlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblNpemVDaGFuZ2UgPSBmdW5jdGlvbiBvblNpemVDaGFuZ2UoeCwgeSkge1xuICAgIHZhciBzaXplTW9kZSA9IHRoaXMuX25vZGUuZ2V0U2l6ZU1vZGUoKTtcbiAgICB2YXIgc2l6ZWRYID0gc2l6ZU1vZGVbMF0gIT09IFNpemUuUkVOREVSO1xuICAgIHZhciBzaXplZFkgPSBzaXplTW9kZVsxXSAhPT0gU2l6ZS5SRU5ERVI7XG4gICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKVxuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLkNIQU5HRV9TSVpFLFxuICAgICAgICAgICAgc2l6ZWRYID8geCA6IHNpemVkWCxcbiAgICAgICAgICAgIHNpemVkWSA/IHkgOiBzaXplZFkpO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgaXRzIG9wYWNpdHkgY2hhbmdlc1xuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gb3BhY2l0eSBUaGUgbmV3IG9wYWNpdHksIGFzIGEgc2NhbGFyIGZyb20gMCB0byAxXG4gKlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vbk9wYWNpdHlDaGFuZ2UgPSBmdW5jdGlvbiBvbk9wYWNpdHlDaGFuZ2Uob3BhY2l0eSkge1xuICAgIG9wYWNpdHkgPSBvcGFjaXR5LmdldExvY2FsT3BhY2l0eSgpO1xuICAgIHJldHVybiB0aGlzLnNldFN0eWxlKCdvcGFjaXR5Jywgb3BhY2l0eSk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgYSBuZXcgVUlFdmVudCBpcyBiZWluZyBhZGRlZC5cbiAqIFRoaXMgcmVzdWx0cyBpbnRvIGFuIGBBRERfRVZFTlRfTElTVEVORVJgIGNvbW1hbmQgYmVpbmcgc2VudC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdWlFdmVudCB1aUV2ZW50IHRvIGJlIHN1YnNjcmliZWQgdG8gKGUuZy4gYGNsaWNrYClcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vbkFkZFVJRXZlbnQgPSBmdW5jdGlvbiBvbkFkZFVJRXZlbnQodWlFdmVudCkge1xuICAgIGlmICh0aGlzLl9VSUV2ZW50cy5pbmRleE9mKHVpRXZlbnQpID09PSAtMSkge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmUodWlFdmVudCk7XG4gICAgICAgIHRoaXMuX1VJRXZlbnRzLnB1c2godWlFdmVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHRoaXMuX2luRHJhdykge1xuICAgICAgICB0aGlzLl9zdWJzY3JpYmUodWlFdmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gYmUgaW52b2tlZCBieSB0aGUgbm9kZSBhcyBzb29uIGFzIGEgVUlFdmVudCBpcyByZW1vdmVkIGZyb21cbiAqIHRoZSBub2RlLiAgVGhpcyByZXN1bHRzIGludG8gYW4gYFVOU1VCU0NSSUJFYCBjb21tYW5kIGJlaW5nIHNlbnQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IFVJRXZlbnQgVUlFdmVudCB0byBiZSByZW1vdmVkIChlLmcuIGBtb3VzZWRvd25gKVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uUmVtb3ZlVUlFdmVudCA9IGZ1bmN0aW9uIG9uUmVtb3ZlVUlFdmVudChVSUV2ZW50KSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fVUlFdmVudHMuaW5kZXhPZihVSUV2ZW50KTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIHRoaXMuX3Vuc3Vic2NyaWJlKFVJRXZlbnQpO1xuICAgICAgICB0aGlzLl9VSUV2ZW50cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgdGhpcy5fdW5zdWJzY3JpYmUoVUlFdmVudCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGFuIGBTVUJTQ1JJQkVgIGNvbW1hbmQgdG8gdGhlIGNvbW1hbmQgcXVldWUuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdWlFdmVudCBFdmVudCB0eXBlIChlLmcuIGBjbGlja2ApXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuX3N1YnNjcmliZSA9IGZ1bmN0aW9uIF9zdWJzY3JpYmUgKHVpRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5TVUJTQ1JJQkUsIHVpRXZlbnQpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBXaGVuIHJ1bm5pbmcgaW4gYSB3b3JrZXIsIHRoZSBicm93c2VyJ3MgZGVmYXVsdCBhY3Rpb24gZm9yIHNwZWNpZmljIGV2ZW50c1xuICogY2FuJ3QgYmUgcHJldmVudGVkIG9uIGEgY2FzZSBieSBjYXNlIGJhc2lzICh2aWEgYGUucHJldmVudERlZmF1bHQoKWApLlxuICogSW5zdGVhZCB0aGlzIGZ1bmN0aW9uIHNob3VsZCBiZSB1c2VkIHRvIHJlZ2lzdGVyIGFuIGV2ZW50IHRvIGJlIHByZXZlbnRlZCBieVxuICogZGVmYXVsdC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB1aUV2ZW50ICAgICBVSSBFdmVudCAoZS5nLiB3aGVlbCkgZm9yIHdoaWNoIHRvIHByZXZlbnQgdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyb3dzZXIncyBkZWZhdWx0IGFjdGlvbiAoZS5nLiBmb3JtIHN1Ym1pc3Npb24sXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbGluZylcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICAgICAgdW5kZWZpbmVkXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLnByZXZlbnREZWZhdWx0ID0gZnVuY3Rpb24gcHJldmVudERlZmF1bHQgKHVpRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5QUkVWRU5UX0RFRkFVTFQsIHVpRXZlbnQpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbn07XG5cbi8qKlxuICogT3Bwb3NpdGUgb2Yge0BsaW5rIERPTUVsZW1lbnQjcHJldmVudERlZmF1bHR9LiBObyBsb25nZXIgcHJldmVudCB0aGVcbiAqIGJyb3dzZXIncyBkZWZhdWx0IGFjdGlvbiBvbiBzdWJzZXF1ZW50IGV2ZW50cyBvZiB0aGlzIHR5cGUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSAge3R5cGV9IHVpRXZlbnQgICAgICAgVUkgRXZlbnQgcHJldmlvdXNseSByZWdpc3RlcmVkIHVzaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBET01FbGVtZW50I3ByZXZlbnREZWZhdWx0fS5cbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gICAgICAgICAgdW5kZWZpbmVkXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLmFsbG93RGVmYXVsdCA9IGZ1bmN0aW9uIGFsbG93RGVmYXVsdCAodWlFdmVudCkge1xuICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkge1xuICAgICAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLkFMTE9XX0RFRkFVTFQsIHVpRXZlbnQpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xufTtcblxuLyoqXG4gKiBBcHBlbmRzIGFuIGBVTlNVQlNDUklCRWAgY29tbWFuZCB0byB0aGUgY29tbWFuZCBxdWV1ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBVSUV2ZW50IEV2ZW50IHR5cGUgKGUuZy4gYGNsaWNrYClcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5fdW5zdWJzY3JpYmUgPSBmdW5jdGlvbiBfdW5zdWJzY3JpYmUgKFVJRXZlbnQpIHtcbiAgICBpZiAodGhpcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5VTlNVQlNDUklCRSwgVUlFdmVudCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG59O1xuXG4vKipcbiAqIE1ldGhvZCB0byBiZSBpbnZva2VkIGJ5IHRoZSBub2RlIGFzIHNvb24gYXMgdGhlIHVuZGVybHlpbmcgc2l6ZSBtb2RlXG4gKiBjaGFuZ2VzLiBUaGlzIHJlc3VsdHMgaW50byB0aGUgc2l6ZSBiZWluZyBmZXRjaGVkIGZyb20gdGhlIG5vZGUgaW5cbiAqIG9yZGVyIHRvIHVwZGF0ZSB0aGUgYWN0dWFsLCByZW5kZXJlZCBzaXplLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0geCB0aGUgc2l6aW5nIG1vZGUgaW4gdXNlIGZvciBkZXRlcm1pbmluZyBzaXplIGluIHRoZSB4IGRpcmVjdGlvblxuICogQHBhcmFtIHtOdW1iZXJ9IHkgdGhlIHNpemluZyBtb2RlIGluIHVzZSBmb3IgZGV0ZXJtaW5pbmcgc2l6ZSBpbiB0aGUgeSBkaXJlY3Rpb25cbiAqIEBwYXJhbSB7TnVtYmVyfSB6IHRoZSBzaXppbmcgbW9kZSBpbiB1c2UgZm9yIGRldGVybWluaW5nIHNpemUgaW4gdGhlIHogZGlyZWN0aW9uXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUub25TaXplTW9kZUNoYW5nZSA9IGZ1bmN0aW9uIG9uU2l6ZU1vZGVDaGFuZ2UoeCwgeSwgeikge1xuICAgIGlmICh4ID09PSBTaXplLlJFTkRFUiB8fCB5ID09PSBTaXplLlJFTkRFUiB8fCB6ID09PSBTaXplLlJFTkRFUikge1xuICAgICAgICB0aGlzLl9yZW5kZXJTaXplZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RSZW5kZXJTaXplID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIHNpemUgPSB0aGlzLl9ub2RlLmdldFNpemUoKTtcbiAgICB0aGlzLm9uU2l6ZUNoYW5nZShzaXplWzBdLCBzaXplWzFdKTtcbn07XG5cbi8qKlxuICogTWV0aG9kIHRvIGJlIHJldHJpZXZlIHRoZSByZW5kZXJlZCBzaXplIG9mIHRoZSBET00gZWxlbWVudCB0aGF0IGlzXG4gKiBkcmF3biBmb3IgdGhpcyBub2RlLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gc2l6ZSBvZiB0aGUgcmVuZGVyZWQgRE9NIGVsZW1lbnQgaW4gcGl4ZWxzXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLmdldFJlbmRlclNpemUgPSBmdW5jdGlvbiBnZXRSZW5kZXJTaXplKCkge1xuICAgIHJldHVybiB0aGlzLl9yZW5kZXJTaXplO1xufTtcblxuLyoqXG4gKiBNZXRob2QgdG8gaGF2ZSB0aGUgY29tcG9uZW50IHJlcXVlc3QgYW4gdXBkYXRlIGZyb20gaXRzIE5vZGVcbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLl9yZXF1ZXN0VXBkYXRlID0gZnVuY3Rpb24gX3JlcXVlc3RVcGRhdGUoKSB7XG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlICYmIHRoaXMuX2lkICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5fbm9kZS5yZXF1ZXN0VXBkYXRlKHRoaXMuX2lkKTtcbiAgICAgICAgdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSA9IHRydWU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBpZCBhdHRyaWJ1dGUgb2YgdGhlIERPTUVsZW1lbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBpZCBOZXcgaWQgdG8gYmUgc2V0XG4gKlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5zZXRJZCA9IGZ1bmN0aW9uIHNldElkIChpZCkge1xuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogQWRkcyBhIG5ldyBjbGFzcyB0byB0aGUgaW50ZXJuYWwgY2xhc3MgbGlzdCBvZiB0aGUgdW5kZXJseWluZyBFbGVtZW50IGluIHRoZVxuICogRE9NLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgTmV3IGNsYXNzIG5hbWUgdG8gYmUgYWRkZWRcbiAqXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGlzXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLmFkZENsYXNzID0gZnVuY3Rpb24gYWRkQ2xhc3MgKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2NsYXNzZXMuaW5kZXhPZih2YWx1ZSkgPCAwKSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5BRERfQ0xBU1MsIHZhbHVlKTtcbiAgICAgICAgdGhpcy5fY2xhc3Nlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJTaXplZCkgdGhpcy5fcmVxdWVzdFJlbmRlclNpemUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5faW5EcmF3KSB7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5BRERfQ0xBU1MsIHZhbHVlKTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgY2xhc3MgZnJvbSB0aGUgRE9NRWxlbWVudCdzIGNsYXNzTGlzdC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIENsYXNzIG5hbWUgdG8gYmUgcmVtb3ZlZFxuICpcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoaXNcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyAodmFsdWUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLl9jbGFzc2VzLmluZGV4T2YodmFsdWUpO1xuXG4gICAgaWYgKGluZGV4IDwgMCkgcmV0dXJuIHRoaXM7XG5cbiAgICB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLlJFTU9WRV9DTEFTUywgdmFsdWUpO1xuXG4gICAgdGhpcy5fY2xhc3Nlcy5zcGxpY2UoaW5kZXgsIDEpO1xuXG4gICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBET01FbGVtZW50IGhhcyB0aGUgcGFzc2VkIGluIGNsYXNzLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgVGhlIGNsYXNzIG5hbWVcbiAqXG4gKiBAcmV0dXJuIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGluZGljYXRpbmcgd2hldGhlciB0aGUgcGFzc2VkIGluIGNsYXNzIG5hbWUgaXMgaW4gdGhlIERPTUVsZW1lbnQncyBjbGFzcyBsaXN0LlxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5oYXNDbGFzcyA9IGZ1bmN0aW9uIGhhc0NsYXNzICh2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLl9jbGFzc2VzLmluZGV4T2YodmFsdWUpICE9PSAtMTtcbn07XG5cbi8qKlxuICogU2V0cyBhbiBhdHRyaWJ1dGUgb2YgdGhlIERPTUVsZW1lbnQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIEF0dHJpYnV0ZSBrZXkgKGUuZy4gYHNyY2ApXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgQXR0cmlidXRlIHZhbHVlIChlLmcuIGBodHRwOi8vZmFtby51c2ApXG4gKlxuICogQHJldHVybiB7RE9NRWxlbWVudH0gdGhpc1xuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5zZXRBdHRyaWJ1dGUgPSBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUgKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX2F0dHJpYnV0ZXNbbmFtZV0gIT09IHZhbHVlIHx8IHRoaXMuX2luRHJhdykge1xuICAgICAgICB0aGlzLl9hdHRyaWJ1dGVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5DSEFOR0VfQVRUUklCVVRFLCBuYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdFVwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBTZXRzIGEgQ1NTIHByb3BlcnR5LlxuICpcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAgTmFtZSBvZiB0aGUgQ1NTIHJ1bGUgKGUuZy4gYGJhY2tncm91bmQtY29sb3JgKVxuICogQHBhcmFtIHtTdHJpbmd9IHZhbHVlIFZhbHVlIG9mIENTUyBwcm9wZXJ0eSAoZS5nLiBgcmVkYClcbiAqXG4gKiBAcmV0dXJuIHtET01FbGVtZW50fSB0aGlzXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLnNldFN0eWxlID0gZnVuY3Rpb24gc2V0U3R5bGUgKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuX3N0eWxlW25hbWVdICE9PSB2YWx1ZSB8fCB0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgdGhpcy5fc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuX2luaXRpYWxpemVkKSB0aGlzLl9jaGFuZ2VRdWV1ZS5wdXNoKENvbW1hbmRzLkNIQU5HRV9TVFlMRSwgbmFtZSwgdmFsdWUpO1xuICAgICAgICBpZiAoIXRoaXMuX3JlcXVlc3RpbmdVcGRhdGUpIHRoaXMuX3JlcXVlc3RVcGRhdGUoKTtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclNpemVkKSB0aGlzLl9yZXF1ZXN0UmVuZGVyU2l6ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgRE9NRWxlbWVudCNzZXRTdHlsZX0gaW5zdGVhZCFcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc29sZS53YXJuKFxuICAgICAgICAnRE9NRWxlbWVudCNzZXRQcm9wZXJ0eSBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgJyArXG4gICAgICAgICdET01FbGVtZW50I3NldFN0eWxlIGluc3RlYWQuJ1xuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuc2V0U3R5bGUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG5cbi8qKlxuICogU2V0cyB0aGUgY29udGVudCBvZiB0aGUgRE9NRWxlbWVudC4gVGhpcyBpcyB1c2luZyBgaW5uZXJIVE1MYCwgZXNjYXBpbmcgdXNlclxuICogZ2VuZXJhdGVkIGNvbnRlbnQgaXMgdGhlcmVmb3JlIGVzc2VudGlhbCBmb3Igc2VjdXJpdHkgcHVycG9zZXMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBjb250ZW50IENvbnRlbnQgdG8gYmUgc2V0IHVzaW5nIGAuaW5uZXJIVE1MID0gLi4uYFxuICpcbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IHRoaXNcbiAqL1xuRE9NRWxlbWVudC5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIHNldENvbnRlbnQgKGNvbnRlbnQpIHtcbiAgICBpZiAodGhpcy5fY29udGVudCAhPT0gY29udGVudCB8fCB0aGlzLl9pbkRyYXcpIHtcbiAgICAgICAgdGhpcy5fY29udGVudCA9IGNvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLl9pbml0aWFsaXplZCkgdGhpcy5fY2hhbmdlUXVldWUucHVzaChDb21tYW5kcy5DSEFOR0VfQ09OVEVOVCwgY29udGVudCk7XG4gICAgICAgIGlmICghdGhpcy5fcmVxdWVzdGluZ1VwZGF0ZSkgdGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyU2l6ZWQpIHRoaXMuX3JlcXVlc3RSZW5kZXJTaXplID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogU3Vic2NyaWJlcyB0byBhIERPTUVsZW1lbnQgdXNpbmcuXG4gKlxuICogQG1ldGhvZCBvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudCAgICAgICBUaGUgZXZlbnQgdHlwZSAoZS5nLiBgY2xpY2tgKS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyICBIYW5kbGVyIGZ1bmN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50IHR5cGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gd2hpY2ggdGhlIHBheWxvYWQgZXZlbnQgb2JqZWN0IHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFzc2VkIGludG8uXG4gKlxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdG8gY2FsbCBpZiB5b3Ugd2FudCB0byByZW1vdmUgdGhlIGNhbGxiYWNrXG4gKi9cbkRPTUVsZW1lbnQucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24gKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIHJldHVybiB0aGlzLl9ldmVudHMub24oZXZlbnQsIGxpc3RlbmVyKTtcbn07XG5cbi8qKlxuICogRnVuY3Rpb24gdG8gYmUgaW52b2tlZCBieSB0aGUgTm9kZSB3aGVuZXZlciBhbiBldmVudCBpcyBiZWluZyByZWNlaXZlZC5cbiAqIFRoZXJlIGFyZSB0d28gZGlmZmVyZW50IHdheXMgdG8gc3Vic2NyaWJlIGZvciB0aG9zZSBldmVudHM6XG4gKlxuICogMS4gQnkgb3ZlcnJpZGluZyB0aGUgb25SZWNlaXZlIG1ldGhvZCAoYW5kIHBvc3NpYmx5IHVzaW5nIGBzd2l0Y2hgIGluIG9yZGVyXG4gKiAgICAgdG8gZGlmZmVyZW50aWF0ZSBiZXR3ZWVuIHRoZSBkaWZmZXJlbnQgZXZlbnQgdHlwZXMpLlxuICogMi4gQnkgdXNpbmcgRE9NRWxlbWVudCBhbmQgdXNpbmcgdGhlIGJ1aWx0LWluIEV2ZW50RW1pdHRlci5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IEV2ZW50IHR5cGUgKGUuZy4gYGNsaWNrYClcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIEV2ZW50IG9iamVjdC5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01FbGVtZW50LnByb3RvdHlwZS5vblJlY2VpdmUgPSBmdW5jdGlvbiBvblJlY2VpdmUgKGV2ZW50LCBwYXlsb2FkKSB7XG4gICAgc3dpdGNoIChldmVudCkge1xuICAgICAgICBjYXNlICdyZXNpemUnOlxuICAgICAgICB0aGlzLl9yZW5kZXJTaXplWzBdID0gcGF5bG9hZC52YWxbMF07XG4gICAgICAgIHRoaXMuX3JlbmRlclNpemVbMV0gPSBwYXlsb2FkLnZhbFsxXTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXF1ZXN0aW5nVXBkYXRlKSB0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fZXZlbnRzLnRyaWdnZXIoZXZlbnQsIHBheWxvYWQpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01FbGVtZW50O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRWxlbWVudENhY2hlID0gcmVxdWlyZSgnLi9FbGVtZW50Q2FjaGUnKTtcbnZhciBtYXRoID0gcmVxdWlyZSgnLi9NYXRoJyk7XG52YXIgUGF0aFV0aWxzID0gcmVxdWlyZSgnLi4vY29yZS9QYXRoJyk7XG52YXIgdmVuZG9yUHJlZml4ID0gcmVxdWlyZSgnLi4vdXRpbGl0aWVzL3ZlbmRvclByZWZpeCcpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJy4uL3V0aWxpdGllcy9hc3NlcnQnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuLi91dGlsaXRpZXMvRXZlbnRFbWl0dGVyJyk7XG52YXIgZXZlbnRNYXAgPSByZXF1aXJlKCcuL2V2ZW50cy9FdmVudE1hcCcpO1xuXG52YXIgVFJBTlNGT1JNID0gbnVsbDtcblxuLyoqXG4gKiBET01SZW5kZXJlciBpcyBhIGNsYXNzIHJlc3BvbnNpYmxlIGZvciBhZGRpbmcgZWxlbWVudHNcbiAqIHRvIHRoZSBET00gYW5kIHdyaXRpbmcgdG8gdGhvc2UgZWxlbWVudHMuXG4gKiBUaGVyZSBpcyBhIERPTVJlbmRlcmVyIHBlciBjb250ZXh0LCByZXByZXNlbnRlZCBhcyBhblxuICogZWxlbWVudCBhbmQgYSBzZWxlY3Rvci4gSXQgaXMgaW5zdGFudGlhdGVkIGluIHRoZVxuICogY29udGV4dCBjbGFzcy5cbiAqXG4gKiBAY2xhc3MgRE9NUmVuZGVyZXJcbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3IgdGhlIHNlbGVjdG9yIG9mIHRoZSBlbGVtZW50LlxuICogQHBhcmFtIHtDb21wb3NpdG9yfSBjb21wb3NpdG9yIHRoZSBjb21wb3NpdG9yIGNvbnRyb2xsaW5nIHRoZSByZW5kZXJlclxuICovXG5mdW5jdGlvbiBET01SZW5kZXJlciAoZWxlbWVudCwgc2VsZWN0b3IsIGNvbXBvc2l0b3IpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKCdmYW1vdXMtZG9tLXJlbmRlcmVyJyk7XG5cbiAgICBUUkFOU0ZPUk0gPSBUUkFOU0ZPUk0gfHwgdmVuZG9yUHJlZml4KCd0cmFuc2Zvcm0nKTtcbiAgICB0aGlzLl9jb21wb3NpdG9yID0gY29tcG9zaXRvcjsgLy8gYSByZWZlcmVuY2UgdG8gdGhlIGNvbXBvc2l0b3JcblxuICAgIHRoaXMuX3RhcmdldCA9IG51bGw7IC8vIGEgcmVnaXN0ZXIgZm9yIGhvbGRpbmcgdGhlIGN1cnJlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBlbGVtZW50IHRoYXQgdGhlIFJlbmRlcmVyIGlzIG9wZXJhdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHVwb25cblxuICAgIHRoaXMuX3BhcmVudCA9IG51bGw7IC8vIGEgcmVnaXN0ZXIgZm9yIGhvbGRpbmcgdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIHRoZSB0YXJnZXRcblxuICAgIHRoaXMuX3BhdGggPSBudWxsOyAvLyBhIHJlZ2lzdGVyIGZvciBob2xkaW5nIHRoZSBwYXRoIG9mIHRoZSB0YXJnZXRcbiAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyByZWdpc3RlciBtdXN0IGJlIHNldCBmaXJzdCwgYW5kIHRoZW5cbiAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hpbGRyZW4sIHRhcmdldCwgYW5kIHBhcmVudCBhcmUgYWxsIGxvb2tlZFxuICAgICAgICAgICAgICAgICAgICAgICAvLyB1cCBmcm9tIHRoYXQuXG5cbiAgICB0aGlzLl9jaGlsZHJlbiA9IFtdOyAvLyBhIHJlZ2lzdGVyIGZvciBob2xkaW5nIHRoZSBjaGlsZHJlbiBvZiB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IHRhcmdldC5cblxuICAgICB0aGlzLl9pbnNlcnRFbEV2ZW50RW1pdHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgdGhpcy5fcmVtb3ZlRWxFdmVudEVtaXR0ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICB0aGlzLl9yb290ID0gbmV3IEVsZW1lbnRDYWNoZShlbGVtZW50LCBzZWxlY3Rvcik7IC8vIHRoZSByb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvZiB0aGUgZG9tIHRyZWUgdGhhdCB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW5kZXJlciBpcyByZXNwb25zaWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZm9yXG5cbiAgICB0aGlzLl9ib3VuZFRyaWdnZXJFdmVudCA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICByZXR1cm4gX3RoaXMuX3RyaWdnZXJFdmVudChldik7XG4gICAgfTtcblxuICAgIHRoaXMuX3NlbGVjdG9yID0gc2VsZWN0b3I7XG5cbiAgICB0aGlzLl9lbGVtZW50cyA9IHt9O1xuXG4gICAgdGhpcy5fZWxlbWVudHNbc2VsZWN0b3JdID0gdGhpcy5fcm9vdDtcblxuICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm0gPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSk7XG4gICAgdGhpcy5fVlB0cmFuc2Zvcm0gPSBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSk7XG5cbiAgICB0aGlzLl9sYXN0RXYgPSBudWxsO1xufVxuXG5cbi8qKlxuICogQXR0YWNoZXMgYW4gRXZlbnRMaXN0ZW5lciB0byB0aGUgZWxlbWVudCBhc3NvY2lhdGVkIHdpdGggdGhlIHBhc3NlZCBpbiBwYXRoLlxuICogUHJldmVudHMgdGhlIGRlZmF1bHQgYnJvd3NlciBhY3Rpb24gb24gYWxsIHN1YnNlcXVlbnQgZXZlbnRzIGlmXG4gKiBgcHJldmVudERlZmF1bHRgIGlzIHRydXRoeS5cbiAqIEFsbCBpbmNvbWluZyBldmVudHMgd2lsbCBiZSBmb3J3YXJkZWQgdG8gdGhlIGNvbXBvc2l0b3IgYnkgaW52b2tpbmcgdGhlXG4gKiBgc2VuZEV2ZW50YCBtZXRob2QuXG4gKiBEZWxlZ2F0ZXMgZXZlbnRzIGlmIHBvc3NpYmxlIGJ5IGF0dGFjaGluZyB0aGUgZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbnRleHQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIERPTSBldmVudCB0eXBlIChlLmcuIGNsaWNrLCBtb3VzZW92ZXIpLlxuICogQHBhcmFtIHtCb29sZWFufSBwcmV2ZW50RGVmYXVsdCBXaGV0aGVyIG9yIG5vdCB0aGUgZGVmYXVsdCBicm93c2VyIGFjdGlvbiBzaG91bGQgYmUgcHJldmVudGVkLlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbiBzdWJzY3JpYmUodHlwZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHRoaXMuX3RhcmdldCwgJ05vIHRhcmdldCBsb2FkZWQnKTtcbiAgICB0aGlzLl9saXN0ZW4odHlwZSk7XG4gICAgdGhpcy5fdGFyZ2V0LnN1YnNjcmliZVt0eXBlXSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gcHJldmVudERlZmF1bHQgaWYgYW4gZXZlbnQgb2YgdGhlIHNwZWNpZmllZCB0eXBlIGlzIGJlaW5nIGVtaXR0ZWQgb25cbiAqIHRoZSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlICAgIFRoZSB0eXBlIG9mIGV2ZW50cyB0aGF0IHNob3VsZCBiZSBwcmV2ZW50ZWQuXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9ICAgICAgdW5kZWZpbmVkXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uIHByZXZlbnREZWZhdWx0KHR5cGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydCh0aGlzLl90YXJnZXQsICdObyB0YXJnZXQgbG9hZGVkJyk7XG4gICAgdGhpcy5fbGlzdGVuKHR5cGUpO1xuICAgIHRoaXMuX3RhcmdldC5wcmV2ZW50RGVmYXVsdFt0eXBlXSA9IHRydWU7XG59O1xuXG4vKipcbiAqIFVzZWQgdG8gdW5kbyBhIHByZXZpb3VzIGNhbGwgdG8gcHJldmVudERlZmF1bHQuIE5vIGxvbmdlciBgcHJldmVudERlZmF1bHRgXG4gKiBmb3IgdGhpcyBldmVudCBvbiB0aGUgbG9hZGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gdHlwZSAgICBUaGUgZXZlbnQgdHlwZSB0aGF0IHNob3VsZCBubyBsb25nZXIgYmUgYWZmZWN0ZWQgYnlcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICBgcHJldmVudERlZmF1bHRgLlxuICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgIHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuYWxsb3dEZWZhdWx0ID0gZnVuY3Rpb24gYWxsb3dEZWZhdWx0KHR5cGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydCh0aGlzLl90YXJnZXQsICdObyB0YXJnZXQgbG9hZGVkJyk7XG4gICAgdGhpcy5fbGlzdGVuKHR5cGUpO1xuICAgIHRoaXMuX3RhcmdldC5wcmV2ZW50RGVmYXVsdFt0eXBlXSA9IGZhbHNlO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdXNlZCBmb3IgYWRkaW5nIGFuIGV2ZW50IGxpc3RlbmVyIGZvciB0aGUgdGhlXG4gKiBjdXJyZW50bHkgbG9hZGVkIEVsZW1lbnRDYWNoZS5cbiAqXG4gKiBJZiB0aGUgZXZlbnQgY2FuIGJlIGRlbGVnYXRlZCBhcyBzcGVjaWZpZWQgaW4gdGhlIHtAbGluayBFdmVudE1hcH0sIHRoZVxuICogYm91bmQge0BsaW5rIF90cmlnZ2VyRXZlbnR9IGZ1bmN0aW9uIHdpbGwgYmUgYWRkZWQgYXMgYSBsaXN0ZW5lciBvbiB0aGVcbiAqIHJvb3QgZWxlbWVudC4gT3RoZXJ3aXNlLCB0aGUgbGlzdGVuZXIgd2lsbCBiZSBhZGRlZCBkaXJlY3RseSB0byB0aGUgdGFyZ2V0XG4gKiBlbGVtZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSB0eXBlICAgIFRoZSBldmVudCB0eXBlIHRvIGxpc3RlbiB0byAoZS5nLiBjbGljaykuXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9ICAgICAgdW5kZWZpbmVkXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5fbGlzdGVuID0gZnVuY3Rpb24gX2xpc3Rlbih0eXBlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodGhpcy5fdGFyZ2V0LCAnTm8gdGFyZ2V0IGxvYWRlZCcpO1xuXG4gICAgaWYgKFxuICAgICAgICAhdGhpcy5fdGFyZ2V0Lmxpc3RlbmVyc1t0eXBlXSAmJiAhdGhpcy5fcm9vdC5saXN0ZW5lcnNbdHlwZV1cbiAgICApIHtcbiAgICAgICAgLy8gRklYTUUgQWRkIHRvIGNvbnRlbnQgRElWIGlmIGF2YWlsYWJsZVxuICAgICAgICB2YXIgdGFyZ2V0ID0gZXZlbnRNYXBbdHlwZV1bMV0gPyB0aGlzLl9yb290IDogdGhpcy5fdGFyZ2V0O1xuICAgICAgICB0YXJnZXQubGlzdGVuZXJzW3R5cGVdID0gdGhpcy5fYm91bmRUcmlnZ2VyRXZlbnQ7XG4gICAgICAgIHRhcmdldC5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgdGhpcy5fYm91bmRUcmlnZ2VyRXZlbnQpO1xuICAgIH1cbn07XG5cbi8qKlxuICogVW5zdWJzY3JpYmVzIGZyb20gYWxsIGV2ZW50cyB0aGF0IGFyZSBvZiB0aGUgc3BlY2lmaWVkIHR5cGUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIERPTSBldmVudCB0eXBlIChlLmcuIGNsaWNrLCBtb3VzZW92ZXIpLlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnVuc3Vic2NyaWJlID0gZnVuY3Rpb24gdW5zdWJzY3JpYmUodHlwZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHRoaXMuX3RhcmdldCwgJ05vIHRhcmdldCBsb2FkZWQnKTtcbiAgICB0aGlzLl90YXJnZXQuc3Vic2NyaWJlW3R5cGVdID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIEZ1bmN0aW9uIHRvIGJlIGFkZGVkIHVzaW5nIGBhZGRFdmVudExpc3RlbmVyYCB0byB0aGUgY29ycmVzcG9uZGluZ1xuICogRE9NRWxlbWVudC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2IERPTSBFdmVudCBwYXlsb2FkXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLl90cmlnZ2VyRXZlbnQgPSBmdW5jdGlvbiBfdHJpZ2dlckV2ZW50KGV2KSB7XG4gICAgaWYgKHRoaXMuX2xhc3RFdiA9PT0gZXYpIHJldHVybjtcblxuICAgIC8vIFVzZSBldi5wYXRoLCB3aGljaCBpcyBhbiBhcnJheSBvZiBFbGVtZW50cyAocG9seWZpbGxlZCBpZiBuZWVkZWQpLlxuICAgIHZhciBldlBhdGggPSBldi5wYXRoID8gZXYucGF0aCA6IF9nZXRQYXRoKGV2KTtcbiAgICAvLyBGaXJzdCBlbGVtZW50IGluIHRoZSBwYXRoIGlzIHRoZSBlbGVtZW50IG9uIHdoaWNoIHRoZSBldmVudCBoYXMgYWN0dWFsbHlcbiAgICAvLyBiZWVuIGVtaXR0ZWQuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBldlBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgLy8gU2tpcCBub2RlcyB0aGF0IGRvbid0IGhhdmUgYSBkYXRhc2V0IHByb3BlcnR5IG9yIGRhdGEtZmEtcGF0aFxuICAgICAgICAvLyBhdHRyaWJ1dGUuXG4gICAgICAgIGlmICghZXZQYXRoW2ldLmRhdGFzZXQpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgcGF0aCA9IGV2UGF0aFtpXS5kYXRhc2V0LmZhUGF0aDtcbiAgICAgICAgaWYgKCFwYXRoKSBjb250aW51ZTtcblxuICAgICAgICAvLyBPcHRpb25hbGx5IHByZXZlbnREZWZhdWx0LiBUaGlzIG5lZWRzIGZvcnRoZXIgY29uc2lkZXJhdGlvbiBhbmRcbiAgICAgICAgLy8gc2hvdWxkIGJlIG9wdGlvbmFsLiBFdmVudHVhbGx5IHRoaXMgc2hvdWxkIGJlIGEgc2VwYXJhdGUgY29tbWFuZC9cbiAgICAgICAgLy8gbWV0aG9kLlxuICAgICAgICBpZiAodGhpcy5fZWxlbWVudHNbcGF0aF0ucHJldmVudERlZmF1bHRbZXYudHlwZV0pIHtcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9wIGZ1cnRoZXIgZXZlbnQgcHJvcG9nYXRpb24gYW5kIHBhdGggdHJhdmVyc2FsIGFzIHNvb24gYXMgdGhlXG4gICAgICAgIC8vIGZpcnN0IEVsZW1lbnRDYWNoZSBzdWJzY3JpYmluZyBmb3IgdGhlIGVtaXR0ZWQgZXZlbnQgaGFzIGJlZW4gZm91bmQuXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50c1twYXRoXSAmJiB0aGlzLl9lbGVtZW50c1twYXRoXS5zdWJzY3JpYmVbZXYudHlwZV0pIHtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RFdiA9IGV2O1xuXG4gICAgICAgICAgICB2YXIgTm9ybWFsaXplZEV2ZW50Q29uc3RydWN0b3IgPSBldmVudE1hcFtldi50eXBlXVswXTtcblxuICAgICAgICAgICAgLy8gRmluYWxseSBzZW5kIHRoZSBldmVudCB0byB0aGUgV29ya2VyIFRocmVhZCB0aHJvdWdoIHRoZVxuICAgICAgICAgICAgLy8gY29tcG9zaXRvci5cbiAgICAgICAgICAgIHRoaXMuX2NvbXBvc2l0b3Iuc2VuZEV2ZW50KHBhdGgsIGV2LnR5cGUsIG5ldyBOb3JtYWxpemVkRXZlbnRDb25zdHJ1Y3RvcihldikpO1xuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblxuLyoqXG4gKiBnZXRTaXplT2YgZ2V0cyB0aGUgZG9tIHNpemUgb2YgYSBwYXJ0aWN1bGFyIERPTSBlbGVtZW50LiAgVGhpcyBpc1xuICogbmVlZGVkIGZvciByZW5kZXIgc2l6aW5nIGluIHRoZSBzY2VuZSBncmFwaC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggcGF0aCBvZiB0aGUgTm9kZSBpbiB0aGUgc2NlbmUgZ3JhcGhcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gYSB2ZWMzIG9mIHRoZSBvZmZzZXQgc2l6ZSBvZiB0aGUgZG9tIGVsZW1lbnRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLmdldFNpemVPZiA9IGZ1bmN0aW9uIGdldFNpemVPZihwYXRoKSB7XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50c1twYXRoXTtcbiAgICBpZiAoIWVsZW1lbnQpIHJldHVybiBudWxsO1xuXG4gICAgdmFyIHJlcyA9IHt2YWw6IGVsZW1lbnQuc2l6ZX07XG4gICAgdGhpcy5fY29tcG9zaXRvci5zZW5kRXZlbnQocGF0aCwgJ3Jlc2l6ZScsIHJlcyk7XG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRQYXRoKGV2KSB7XG4gICAgLy8gVE9ETyBtb3ZlIGludG8gX3RyaWdnZXJFdmVudCwgYXZvaWQgb2JqZWN0IGFsbG9jYXRpb25cbiAgICB2YXIgcGF0aCA9IFtdO1xuICAgIHZhciBub2RlID0gZXYudGFyZ2V0O1xuICAgIHdoaWxlIChub2RlICE9PSBkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHBhdGgucHVzaChub2RlKTtcbiAgICAgICAgbm9kZSA9IG5vZGUucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdGg7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgdGhlIHJldHJpZXZlZCBkcmF3IGNvbW1hbmRzLiBEcmF3IGNvbW1hbmRzIG9ubHkgcmVmZXIgdG8gdGhlXG4gKiBjcm9zcy1icm93c2VyIG5vcm1hbGl6ZWQgYHRyYW5zZm9ybWAgcHJvcGVydHkuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZW5kZXJTdGF0ZSBkZXNjcmlwdGlvblxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gZHJhdyhyZW5kZXJTdGF0ZSkge1xuICAgIGlmIChyZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5KSB7XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVEaXJ0eSA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVswXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzBdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzFdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMV07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMl0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsyXTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVszXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzNdO1xuXG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bNF0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs0XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs1XSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzVdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzZdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bNl07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bN10gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs3XTtcblxuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzhdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bOF07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bOV0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVs5XTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMF0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMF07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTFdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTFdO1xuXG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTJdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTJdO1xuICAgICAgICB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzEzXSA9IHJlbmRlclN0YXRlLnBlcnNwZWN0aXZlVHJhbnNmb3JtWzEzXTtcbiAgICAgICAgdGhpcy5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxNF0gPSByZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxNF07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTVdID0gcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTVdO1xuICAgIH1cblxuICAgIGlmIChyZW5kZXJTdGF0ZS52aWV3RGlydHkgfHwgcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVEaXJ0eSkge1xuICAgICAgICBtYXRoLm11bHRpcGx5KHRoaXMuX1ZQdHJhbnNmb3JtLCB0aGlzLnBlcnNwZWN0aXZlVHJhbnNmb3JtLCByZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtKTtcbiAgICAgICAgdGhpcy5fcm9vdC5lbGVtZW50LnN0eWxlW1RSQU5TRk9STV0gPSB0aGlzLl9zdHJpbmdpZnlNYXRyaXgodGhpcy5fVlB0cmFuc2Zvcm0pO1xuICAgIH1cbn07XG5cbi8qKlxuICogRmluZHMgYW5kIHNldHMgdGhlIHBhcmVudCBvZiB0aGUgY3VycmVudGx5IGxvYWRlZCBlbGVtZW50IChwYXRoKS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge0VsZW1lbnRDYWNoZX0gUGFyZW50IGVsZW1lbnQuXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5maW5kUGFyZW50ID0gZnVuY3Rpb24gZmluZFBhcmVudCAoKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodGhpcy5fcGF0aCwgJ05vIHBhdGggbG9hZGVkJyk7XG5cbiAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFyIHBhcmVudDtcblxuICAgIHdoaWxlICghcGFyZW50ICYmIHBhdGgubGVuZ3RoKSB7XG4gICAgICAgIHBhdGggPSBwYXRoLnN1YnN0cmluZygwLCBwYXRoLmxhc3RJbmRleE9mKCcvJykpO1xuICAgICAgICBwYXJlbnQgPSB0aGlzLl9lbGVtZW50c1twYXRoXTtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXJlbnQgPSBwYXJlbnQ7XG4gICAgcmV0dXJuIHBhcmVudDtcbn07XG5cbi8qKlxuICogTG9hZHMgdGhlIHBhc3NlZCBpbiBwYXRoIGludG8gdGhlIERPTVJlbmRlcmVyLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGF0aCBQYXRoIHRvIGJlIGxvYWRlZFxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gTG9hZGVkIHBhdGhcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLmxvYWRQYXRoID0gZnVuY3Rpb24gbG9hZFBhdGggKHBhdGgpIHtcbiAgICB0aGlzLl9wYXRoID0gcGF0aDtcbiAgICB0aGlzLl90YXJnZXQgPSB0aGlzLl9lbGVtZW50c1t0aGlzLl9wYXRoXTtcbiAgICByZXR1cm4gdGhpcy5fcGF0aDtcbn07XG5cbi8qKlxuICogRmluZHMgY2hpbGRyZW4gb2YgYSBwYXJlbnQgZWxlbWVudCB0aGF0IGFyZSBkZXNjZW5kZW50cyBvZiBhIGluc2VydGVkIGVsZW1lbnQgaW4gdGhlIHNjZW5lXG4gKiBncmFwaC4gQXBwZW5kcyB0aG9zZSBjaGlsZHJlbiB0byB0aGUgaW5zZXJ0ZWQgZWxlbWVudC5cbiAqXG4gKiBAbWV0aG9kIHJlc29sdmVDaGlsZHJlblxuICogQHJldHVybiB7dm9pZH1cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IHRoZSBpbnNlcnRlZCBlbGVtZW50XG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwYXJlbnQgdGhlIHBhcmVudCBvZiB0aGUgaW5zZXJ0ZWQgZWxlbWVudFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUucmVzb2x2ZUNoaWxkcmVuID0gZnVuY3Rpb24gcmVzb2x2ZUNoaWxkcmVuIChlbGVtZW50LCBwYXJlbnQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGNoaWxkTm9kZTtcbiAgICB2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG4gICAgdmFyIGNoaWxkUGF0aDtcblxuICAgIHdoaWxlICgoY2hpbGROb2RlID0gcGFyZW50LmNoaWxkTm9kZXNbaV0pKSB7XG4gICAgICAgIGlmICghY2hpbGROb2RlLmRhdGFzZXQpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNoaWxkUGF0aCA9IGNoaWxkTm9kZS5kYXRhc2V0LmZhUGF0aDtcbiAgICAgICAgaWYgKCFjaGlsZFBhdGgpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChQYXRoVXRpbHMuaXNEZXNjZW5kZW50T2YoY2hpbGRQYXRoLCBwYXRoKSkgZWxlbWVudC5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuICAgICAgICBlbHNlIGkrKztcbiAgICB9XG59O1xuXG4vKipcbiAqIEluc2VydHMgYSBET01FbGVtZW50IGF0IHRoZSBjdXJyZW50bHkgbG9hZGVkIHBhdGgsIGFzc3VtaW5nIG5vIHRhcmdldCBpc1xuICogbG9hZGVkLiBPbmx5IG9uZSBET01FbGVtZW50IGNhbiBiZSBhc3NvY2lhdGVkIHdpdGggZWFjaCBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdGFnTmFtZSBUYWcgbmFtZSAoY2FwaXRhbGl6YXRpb24gd2lsbCBiZSBub3JtYWxpemVkKS5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuaW5zZXJ0RWwgPSBmdW5jdGlvbiBpbnNlcnRFbCAodGFnTmFtZSkge1xuICAgIHRoaXMuZmluZFBhcmVudCgpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodGhpcy5fcGFyZW50LCAnTm8gcGFyZW50IGxvYWRlZCcpO1xuXG4gICAgaWYgKHRoaXMuX3BhcmVudC52b2lkKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQucGF0aCArICcgaXMgYSB2b2lkIGVsZW1lbnQuICcgK1xuICAgICAgICAgICAgJ1ZvaWQgZWxlbWVudHMgYXJlIG5vdCBhbGxvd2VkIHRvIGhhdmUgY2hpbGRyZW4uJ1xuICAgICAgICApO1xuXG4gICAgaWYgKCF0aGlzLl90YXJnZXQpIHRoaXMuX3RhcmdldCA9IG5ldyBFbGVtZW50Q2FjaGUoZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKSwgdGhpcy5fcGF0aCk7XG5cbiAgICB2YXIgZWwgPSB0aGlzLl90YXJnZXQuZWxlbWVudDtcbiAgICB2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50LmVsZW1lbnQ7XG5cbiAgICB0aGlzLnJlc29sdmVDaGlsZHJlbihlbCwgcGFyZW50KTtcblxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChlbCk7XG4gICAgdGhpcy5fZWxlbWVudHNbdGhpcy5fcGF0aF0gPSB0aGlzLl90YXJnZXQ7XG5cbiAgICB0aGlzLl9jb21wb3NpdG9yLnNlbmRFdmVudCh0aGlzLl9wYXRoLCAnaW5zZXJ0RWwnLCB7fSk7XG4gICAgdGhpcy5faW5zZXJ0RWxFdmVudEVtaXR0ZXIudHJpZ2dlcih0aGlzLl9wYXRoLCB0aGlzLl90YXJnZXQpO1xufTtcblxuXG4vKipcbiAqIFNldHMgYSBwcm9wZXJ0eSBvbiB0aGUgY3VycmVudGx5IGxvYWRlZCB0YXJnZXQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIFByb3BlcnR5IG5hbWUgKGUuZy4gYmFja2dyb3VuZCwgY29sb3IsIGZvbnQpXG4gKiBAcGFyYW0ge1N0cmluZ30gdmFsdWUgUHJvcHJ0eSB2YWx1ZSAoZS5nLiBibGFjaywgMjBweClcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc2V0UHJvcGVydHkgPSBmdW5jdGlvbiBzZXRQcm9wZXJ0eSAobmFtZSwgdmFsdWUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydCh0aGlzLl90YXJnZXQsICdObyB0YXJnZXQgbG9hZGVkJyk7XG4gICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbn07XG5cblxuLyoqXG4gKiBTZXRzIHRoZSBzaXplIG9mIHRoZSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqIFJlbW92ZXMgYW55IGV4cGxpY2l0IHNpemluZyBjb25zdHJhaW50cyB3aGVuIHBhc3NlZCBpbiBgZmFsc2VgXG4gKiAoXCJ0cnVlLXNpemluZ1wiKS5cbiAqXG4gKiBJbnZva2luZyBzZXRTaXplIGlzIGVxdWl2YWxlbnQgdG8gYSBtYW51YWwgaW52b2NhdGlvbiBvZiBgc2V0V2lkdGhgIGZvbGxvd2VkXG4gKiBieSBgc2V0SGVpZ2h0YC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8ZmFsc2V9IHdpZHRoICAgV2lkdGggdG8gYmUgc2V0LlxuICogQHBhcmFtIHtOdW1iZXJ8ZmFsc2V9IGhlaWdodCAgSGVpZ2h0IHRvIGJlIHNldC5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc2V0U2l6ZSA9IGZ1bmN0aW9uIHNldFNpemUgKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydCh0aGlzLl90YXJnZXQsICdObyB0YXJnZXQgbG9hZGVkJyk7XG5cbiAgICB0aGlzLnNldFdpZHRoKHdpZHRoKTtcbiAgICB0aGlzLnNldEhlaWdodChoZWlnaHQpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSB3aWR0aCBvZiB0aGUgY3VycmVudGx5IGxvYWRlZCBFbGVtZW50Q2FjaGUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSAge051bWJlcnxmYWxzZX0gd2lkdGggICAgIFRoZSBleHBsaWNpdCB3aWR0aCB0byBiZSBzZXQgb24gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbGVtZW50Q2FjaGUncyB0YXJnZXQgKGFuZCBjb250ZW50KSBlbGVtZW50LlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYGZhbHNlYCByZW1vdmVzIGFueSBleHBsaWNpdCBzaXppbmdcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cmFpbnRzIGZyb20gdGhlIHVuZGVybHlpbmcgRE9NXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBFbGVtZW50cy5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc2V0V2lkdGggPSBmdW5jdGlvbiBzZXRXaWR0aCh3aWR0aCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHRoaXMuX3RhcmdldCwgJ05vIHRhcmdldCBsb2FkZWQnKTtcblxuICAgIHZhciBjb250ZW50V3JhcHBlciA9IHRoaXMuX3RhcmdldC5jb250ZW50O1xuXG4gICAgaWYgKHdpZHRoID09PSBmYWxzZSkge1xuICAgICAgICB0aGlzLl90YXJnZXQuZXhwbGljaXRXaWR0aCA9IHRydWU7XG4gICAgICAgIGlmIChjb250ZW50V3JhcHBlcikgY29udGVudFdyYXBwZXIuc3R5bGUud2lkdGggPSAnJztcbiAgICAgICAgd2lkdGggPSBjb250ZW50V3JhcHBlciA/IGNvbnRlbnRXcmFwcGVyLm9mZnNldFdpZHRoIDogMDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLl90YXJnZXQuZXhwbGljaXRXaWR0aCA9IGZhbHNlO1xuICAgICAgICBpZiAoY29udGVudFdyYXBwZXIpIGNvbnRlbnRXcmFwcGVyLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICB9XG5cbiAgICB0aGlzLl90YXJnZXQuc2l6ZVswXSA9IHdpZHRoO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBoZWlnaHQgb2YgdGhlIGN1cnJlbnRseSBsb2FkZWQgRWxlbWVudENhY2hlLlxuICpcbiAqIEBtZXRob2QgIHNldEhlaWdodFxuICpcbiAqIEBwYXJhbSAge051bWJlcnxmYWxzZX0gaGVpZ2h0ICAgIFRoZSBleHBsaWNpdCBoZWlnaHQgdG8gYmUgc2V0IG9uIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRWxlbWVudENhY2hlJ3MgdGFyZ2V0IChhbmQgY29udGVudCkgZWxlbWVudC5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBmYWxzZWAgcmVtb3ZlcyBhbnkgZXhwbGljaXQgc2l6aW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdHJhaW50cyBmcm9tIHRoZSB1bmRlcmx5aW5nIERPTVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRWxlbWVudHMuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldEhlaWdodCA9IGZ1bmN0aW9uIHNldEhlaWdodChoZWlnaHQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdkZXZlbG9wbWVudCcpXG4gICAgICAgIGFzc2VydCh0aGlzLl90YXJnZXQsICdObyB0YXJnZXQgbG9hZGVkJyk7XG5cbiAgICB2YXIgY29udGVudFdyYXBwZXIgPSB0aGlzLl90YXJnZXQuY29udGVudDtcblxuICAgIGlmIChoZWlnaHQgPT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5leHBsaWNpdEhlaWdodCA9IHRydWU7XG4gICAgICAgIGlmIChjb250ZW50V3JhcHBlcikgY29udGVudFdyYXBwZXIuc3R5bGUuaGVpZ2h0ID0gJyc7XG4gICAgICAgIGhlaWdodCA9IGNvbnRlbnRXcmFwcGVyID8gY29udGVudFdyYXBwZXIub2Zmc2V0SGVpZ2h0IDogMDtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuX3RhcmdldC5leHBsaWNpdEhlaWdodCA9IGZhbHNlO1xuICAgICAgICBpZiAoY29udGVudFdyYXBwZXIpIGNvbnRlbnRXcmFwcGVyLnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG4gICAgfVxuXG4gICAgdGhpcy5fdGFyZ2V0LnNpemVbMV0gPSBoZWlnaHQ7XG59O1xuXG4vKipcbiAqIFNldHMgYW4gYXR0cmlidXRlIG9uIHRoZSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgQXR0cmlidXRlIG5hbWUgKGUuZy4gaHJlZilcbiAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBBdHRyaWJ1dGUgdmFsdWUgKGUuZy4gaHR0cDovL2ZhbW91cy5vcmcpXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLnNldEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIHNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHRoaXMuX3RhcmdldCwgJ05vIHRhcmdldCBsb2FkZWQnKTtcbiAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpO1xufTtcblxuLyoqXG4gKiBTZXRzIHRoZSBgaW5uZXJIVE1MYCBjb250ZW50IG9mIHRoZSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRlbnQgQ29udGVudCB0byBiZSBzZXQgYXMgYGlubmVySFRNTGBcbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuc2V0Q29udGVudCA9IGZ1bmN0aW9uIHNldENvbnRlbnQoY29udGVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHRoaXMuX3RhcmdldCwgJ05vIHRhcmdldCBsb2FkZWQnKTtcblxuICAgIGlmICh0aGlzLl90YXJnZXQuZm9ybUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQudmFsdWUgPSBjb250ZW50O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKCF0aGlzLl90YXJnZXQuY29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5jb250ZW50LmNsYXNzTGlzdC5hZGQoJ2ZhbW91cy1kb20tZWxlbWVudC1jb250ZW50Jyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5pbnNlcnRCZWZvcmUoXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmNvbnRlbnQsXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmVsZW1lbnQuZmlyc3RDaGlsZFxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YXJnZXQuY29udGVudC5pbm5lckhUTUwgPSBjb250ZW50O1xuICAgIH1cblxuXG4gICAgdGhpcy5zZXRTaXplKFxuICAgICAgICB0aGlzLl90YXJnZXQuZXhwbGljaXRXaWR0aCA/IGZhbHNlIDogdGhpcy5fdGFyZ2V0LnNpemVbMF0sXG4gICAgICAgIHRoaXMuX3RhcmdldC5leHBsaWNpdEhlaWdodCA/IGZhbHNlIDogdGhpcy5fdGFyZ2V0LnNpemVbMV1cbiAgICApO1xufTtcblxuXG4vKipcbiAqIFNldHMgdGhlIHBhc3NlZCBpbiB0cmFuc2Zvcm0gbWF0cml4ICh3b3JsZCBzcGFjZSkuIEludmVydHMgdGhlIHBhcmVudCdzIHdvcmxkXG4gKiB0cmFuc2Zvcm0uXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7RmxvYXQzMkFycmF5fSB0cmFuc2Zvcm0gVGhlIHRyYW5zZm9ybSBmb3IgdGhlIGxvYWRlZCBET00gRWxlbWVudCBpbiB3b3JsZCBzcGFjZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5zZXRNYXRyaXggPSBmdW5jdGlvbiBzZXRNYXRyaXggKHRyYW5zZm9ybSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHRoaXMuX3RhcmdldCwgJ05vIHRhcmdldCBsb2FkZWQnKTtcbiAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5zdHlsZVtUUkFOU0ZPUk1dID0gdGhpcy5fc3RyaW5naWZ5TWF0cml4KHRyYW5zZm9ybSk7XG59O1xuXG5cbi8qKlxuICogQWRkcyBhIGNsYXNzIHRvIHRoZSBjbGFzc0xpc3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGRvbUNsYXNzIENsYXNzIG5hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGN1cnJlbnQgdGFyZ2V0LlxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5hZGRDbGFzcyA9IGZ1bmN0aW9uIGFkZENsYXNzKGRvbUNsYXNzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuICAgICAgICBhc3NlcnQodGhpcy5fdGFyZ2V0LCAnTm8gdGFyZ2V0IGxvYWRlZCcpO1xuICAgIHRoaXMuX3RhcmdldC5lbGVtZW50LmNsYXNzTGlzdC5hZGQoZG9tQ2xhc3MpO1xufTtcblxuXG4vKipcbiAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBjbGFzc0xpc3QgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50bHkgbG9hZGVkXG4gKiB0YXJnZXQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkb21DbGFzcyBDbGFzcyBuYW1lIHRvIGJlIHJlbW92ZWQgZnJvbSBjdXJyZW50bHkgbG9hZGVkIHRhcmdldC5cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUucmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiByZW1vdmVDbGFzcyhkb21DbGFzcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ2RldmVsb3BtZW50JylcbiAgICAgICAgYXNzZXJ0KHRoaXMuX3RhcmdldCwgJ05vIHRhcmdldCBsb2FkZWQnKTtcbiAgICB0aGlzLl90YXJnZXQuZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKGRvbUNsYXNzKTtcbn07XG5cblxuLyoqXG4gKiBTdHJpbmdpZmllcyB0aGUgcGFzc2VkIGluIG1hdHJpeCBmb3Igc2V0dGluZyB0aGUgYHRyYW5zZm9ybWAgcHJvcGVydHkuXG4gKlxuICogQG1ldGhvZCAgX3N0cmluZ2lmeU1hdHJpeFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBtICAgIE1hdHJpeCBhcyBhbiBhcnJheSBvciBhcnJheS1saWtlIG9iamVjdC5cbiAqIEByZXR1cm4ge1N0cmluZ30gICAgIFN0cmluZ2lmaWVkIG1hdHJpeCBhcyBgbWF0cml4M2RgLXByb3BlcnR5LlxuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUuX3N0cmluZ2lmeU1hdHJpeCA9IGZ1bmN0aW9uIF9zdHJpbmdpZnlNYXRyaXgobSkge1xuICAgIHZhciByID0gJ21hdHJpeDNkKCc7XG5cbiAgICByICs9IChtWzBdIDwgMC4wMDAwMDEgJiYgbVswXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVswXSArICcsJztcbiAgICByICs9IChtWzFdIDwgMC4wMDAwMDEgJiYgbVsxXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsxXSArICcsJztcbiAgICByICs9IChtWzJdIDwgMC4wMDAwMDEgJiYgbVsyXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVsyXSArICcsJztcbiAgICByICs9IChtWzNdIDwgMC4wMDAwMDEgJiYgbVszXSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVszXSArICcsJztcbiAgICByICs9IChtWzRdIDwgMC4wMDAwMDEgJiYgbVs0XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs0XSArICcsJztcbiAgICByICs9IChtWzVdIDwgMC4wMDAwMDEgJiYgbVs1XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs1XSArICcsJztcbiAgICByICs9IChtWzZdIDwgMC4wMDAwMDEgJiYgbVs2XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs2XSArICcsJztcbiAgICByICs9IChtWzddIDwgMC4wMDAwMDEgJiYgbVs3XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs3XSArICcsJztcbiAgICByICs9IChtWzhdIDwgMC4wMDAwMDEgJiYgbVs4XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs4XSArICcsJztcbiAgICByICs9IChtWzldIDwgMC4wMDAwMDEgJiYgbVs5XSA+IC0wLjAwMDAwMSkgPyAnMCwnIDogbVs5XSArICcsJztcbiAgICByICs9IChtWzEwXSA8IDAuMDAwMDAxICYmIG1bMTBdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzEwXSArICcsJztcbiAgICByICs9IChtWzExXSA8IDAuMDAwMDAxICYmIG1bMTFdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzExXSArICcsJztcbiAgICByICs9IChtWzEyXSA8IDAuMDAwMDAxICYmIG1bMTJdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzEyXSArICcsJztcbiAgICByICs9IChtWzEzXSA8IDAuMDAwMDAxICYmIG1bMTNdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzEzXSArICcsJztcbiAgICByICs9IChtWzE0XSA8IDAuMDAwMDAxICYmIG1bMTRdID4gLTAuMDAwMDAxKSA/ICcwLCcgOiBtWzE0XSArICcsJztcblxuICAgIHIgKz0gbVsxNV0gKyAnKSc7XG4gICAgcmV0dXJuIHI7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIHdoZW4gYSBuZXcgZWxlbWVudCBpcyBiZWluZyBpbnNlcnRlZCBhdFxuICogdGhlIHNwZWNpZmllZCBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgcGF0aCAgICAgIFBhdGggYXQgd2hpY2ggdG8gbGlzdGVuIGZvciBlbGVtZW50IGluc2VydGlvbi5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgRnVuY3Rpb24gdG8gYmUgZXhlY3V0ZWQgd2hlbiBhbiBpbnNlcnRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2NjdXJzLlxuICogQHJldHVybiB7RE9NUmVuZGVyZXJ9ICAgICAgICB0aGlzXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5vbkluc2VydEVsID0gZnVuY3Rpb24gb25JbnNlcnRFbChwYXRoLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2luc2VydEVsRXZlbnRFbWl0dGVyLm9uKHBhdGgsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVyZWdpc3RlcnMgYSBsaXN0ZW5lciBmdW5jdGlvbiB0byBiZSBubyBsb25nZXIgZXhlY3V0ZWQgb24gZnV0dXJlIGVsZW1lbnRcbiAqIGluc2VydGlvbnMgYXQgdGhlIHNwZWNpZmllZCBwYXRoLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgcGF0aCAgICAgIFBhdGggYXQgd2hpY2ggdGhlIGxpc3RlbmVyIGZ1bmN0aW9uIGhhcyBiZWVuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyZWQuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGRlcmVnaXN0ZXJlZC5cbiAqIEByZXR1cm4ge0RPTVJlbmRlcmVyfSAgICAgICAgdGhpc1xuICovXG5ET01SZW5kZXJlci5wcm90b3R5cGUub2ZmSW5zZXJ0RWwgPSBmdW5jdGlvbiBvZmZJbnNlcnRFbChwYXRoLCBjYWxsYmFjaykge1xuICAgIHRoaXMuX2luc2VydEVsRXZlbnRFbWl0dGVyLm9mZihwYXRoLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIHRvIGJlIHRyaWdnZXJlZCBhcyBzb29uIGFzIGFuIGVsZW1lbnQgYXQgdGhlXG4gKiBzcGVjaWZpZWQgcGF0aCBpcyBiZWluZyByZW1vdmVkLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgcGF0aCAgICAgIFBhdGggYXQgd2hpY2ggdG8gbGlzdGVuIGZvciB0aGUgcmVtb3ZhbCBvZiBhblxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrICBGdW5jdGlvbiB0byBiZSBleGVjdXRlZCB3aGVuIGFuIGVsZW1lbnQgaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmVpbmcgcmVtb3ZlZCBhdCB0aGUgc3BlY2lmaWVkIHBhdGguXG4gKiBAcmV0dXJuIHtET01SZW5kZXJlcn0gICAgICAgIHRoaXNcbiAqL1xuRE9NUmVuZGVyZXIucHJvdG90eXBlLm9uUmVtb3ZlRWwgPSBmdW5jdGlvbiBvblJlbW92ZUVsKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVtb3ZlRWxFdmVudEVtaXR0ZXIub24ocGF0aCwgY2FsbGJhY2spO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZXJlZ2lzdGVycyBhIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIGJlIG5vIGxvbmdlciBleGVjdXRlZCB3aGVuIGFuIGVsZW1lbnQgaXNcbiAqIGJlaW5nIHJlbW92ZWQgZnJvbSB0aGUgc3BlY2lmaWVkIHBhdGguXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gICBwYXRoICAgICAgUGF0aCBhdCB3aGljaCB0aGUgbGlzdGVuZXIgZnVuY3Rpb24gaGFzIGJlZW5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJlZC5cbiAqIEBwYXJhbSAge0Z1bmN0aW9ufSBjYWxsYmFjayAgQ2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgZGVyZWdpc3RlcmVkLlxuICogQHJldHVybiB7RE9NUmVuZGVyZXJ9ICAgICAgICB0aGlzXG4gKi9cbkRPTVJlbmRlcmVyLnByb3RvdHlwZS5vZmZSZW1vdmVFbCA9IGZ1bmN0aW9uIG9mZlJlbW92ZUVsKHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVtb3ZlRWxFdmVudEVtaXR0ZXIub2ZmKHBhdGgsIGNhbGxiYWNrKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRE9NUmVuZGVyZXI7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBWb2lkRWxlbWVudHMgPSByZXF1aXJlKCcuL1ZvaWRFbGVtZW50cycpO1xuXG4vKipcbiAqIEVsZW1lbnRDYWNoZSBpcyBiZWluZyB1c2VkIGZvciBrZWVwaW5nIHRyYWNrIG9mIGFuIGVsZW1lbnQncyBET00gRWxlbWVudCxcbiAqIHBhdGgsIHdvcmxkIHRyYW5zZm9ybSwgaW52ZXJ0ZWQgcGFyZW50LCBmaW5hbCB0cmFuc2Zvcm0gKGFzIGJlaW5nIHVzZWQgZm9yXG4gKiBzZXR0aW5nIHRoZSBhY3R1YWwgYHRyYW5zZm9ybWAtcHJvcGVydHkpIGFuZCBwb3N0IHJlbmRlciBzaXplIChmaW5hbCBzaXplIGFzXG4gKiBiZWluZyByZW5kZXJlZCB0byB0aGUgRE9NKS5cbiAqXG4gKiBAY2xhc3MgRWxlbWVudENhY2hlXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IERPTUVsZW1lbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXRoIFBhdGggdXNlZCBmb3IgdW5pcXVlbHkgaWRlbnRpZnlpbmcgdGhlIGxvY2F0aW9uIGluIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgc2NlbmUgZ3JhcGguXG4gKi9cbmZ1bmN0aW9uIEVsZW1lbnRDYWNoZSAoZWxlbWVudCwgcGF0aCkge1xuICAgIHRoaXMudGFnTmFtZSA9IGVsZW1lbnQudGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMudm9pZCA9IFZvaWRFbGVtZW50c1t0aGlzLnRhZ05hbWVdO1xuXG4gICAgdmFyIGNvbnN0cnVjdG9yID0gZWxlbWVudC5jb25zdHJ1Y3RvcjtcblxuICAgIHRoaXMuZm9ybUVsZW1lbnQgPSBjb25zdHJ1Y3RvciA9PT0gSFRNTElucHV0RWxlbWVudCB8fFxuICAgICAgICBjb25zdHJ1Y3RvciA9PT0gSFRNTFRleHRBcmVhRWxlbWVudCB8fFxuICAgICAgICBjb25zdHJ1Y3RvciA9PT0gSFRNTFNlbGVjdEVsZW1lbnQ7XG5cbiAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgIHRoaXMucGF0aCA9IHBhdGg7XG4gICAgdGhpcy5jb250ZW50ID0gbnVsbDtcbiAgICB0aGlzLnNpemUgPSBuZXcgSW50MTZBcnJheSgzKTtcbiAgICB0aGlzLmV4cGxpY2l0SGVpZ2h0ID0gZmFsc2U7XG4gICAgdGhpcy5leHBsaWNpdFdpZHRoID0gZmFsc2U7XG4gICAgdGhpcy5wb3N0UmVuZGVyU2l6ZSA9IG5ldyBGbG9hdDMyQXJyYXkoMik7XG4gICAgdGhpcy5saXN0ZW5lcnMgPSB7fTtcbiAgICB0aGlzLnByZXZlbnREZWZhdWx0ID0ge307XG4gICAgdGhpcy5zdWJzY3JpYmUgPSB7fTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbGVtZW50Q2FjaGU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBtZXRob2QgZm9yIGludmVydGluZyBhIHRyYW5zZm9ybSBtYXRyaXhcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtBcnJheX0gb3V0IGFycmF5IHRvIHN0b3JlIHRoZSByZXR1cm4gb2YgdGhlIGludmVyc2lvblxuICogQHBhcmFtIHtBcnJheX0gYSB0cmFuc2Zvcm0gbWF0cml4IHRvIGludmVyc2VcbiAqXG4gKiBAcmV0dXJuIHtBcnJheX0gb3V0XG4gKiAgIG91dHB1dCBhcnJheSB0aGF0IGlzIHN0b3JpbmcgdGhlIHRyYW5zZm9ybSBtYXRyaXhcbiAqL1xuZnVuY3Rpb24gaW52ZXJ0IChvdXQsIGEpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMDAgPSBhMDAgKiBhMTEgLSBhMDEgKiBhMTAsXG4gICAgICAgIGIwMSA9IGEwMCAqIGExMiAtIGEwMiAqIGExMCxcbiAgICAgICAgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwLFxuICAgICAgICBiMDMgPSBhMDEgKiBhMTIgLSBhMDIgKiBhMTEsXG4gICAgICAgIGIwNCA9IGEwMSAqIGExMyAtIGEwMyAqIGExMSxcbiAgICAgICAgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyLFxuICAgICAgICBiMDYgPSBhMjAgKiBhMzEgLSBhMjEgKiBhMzAsXG4gICAgICAgIGIwNyA9IGEyMCAqIGEzMiAtIGEyMiAqIGEzMCxcbiAgICAgICAgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwLFxuICAgICAgICBiMDkgPSBhMjEgKiBhMzIgLSBhMjIgKiBhMzEsXG4gICAgICAgIGIxMCA9IGEyMSAqIGEzMyAtIGEyMyAqIGEzMSxcbiAgICAgICAgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyLFxuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgZGV0ZXJtaW5hbnRcbiAgICAgICAgZGV0ID0gYjAwICogYjExIC0gYjAxICogYjEwICsgYjAyICogYjA5ICsgYjAzICogYjA4IC0gYjA0ICogYjA3ICsgYjA1ICogYjA2O1xuXG4gICAgaWYgKCFkZXQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGRldCA9IDEuMCAvIGRldDtcblxuICAgIG91dFswXSA9IChhMTEgKiBiMTEgLSBhMTIgKiBiMTAgKyBhMTMgKiBiMDkpICogZGV0O1xuICAgIG91dFsxXSA9IChhMDIgKiBiMTAgLSBhMDEgKiBiMTEgLSBhMDMgKiBiMDkpICogZGV0O1xuICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgIG91dFszXSA9IChhMjIgKiBiMDQgLSBhMjEgKiBiMDUgLSBhMjMgKiBiMDMpICogZGV0O1xuICAgIG91dFs0XSA9IChhMTIgKiBiMDggLSBhMTAgKiBiMTEgLSBhMTMgKiBiMDcpICogZGV0O1xuICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgIG91dFs2XSA9IChhMzIgKiBiMDIgLSBhMzAgKiBiMDUgLSBhMzMgKiBiMDEpICogZGV0O1xuICAgIG91dFs3XSA9IChhMjAgKiBiMDUgLSBhMjIgKiBiMDIgKyBhMjMgKiBiMDEpICogZGV0O1xuICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgIG91dFs5XSA9IChhMDEgKiBiMDggLSBhMDAgKiBiMTAgLSBhMDMgKiBiMDYpICogZGV0O1xuICAgIG91dFsxMF0gPSAoYTMwICogYjA0IC0gYTMxICogYjAyICsgYTMzICogYjAwKSAqIGRldDtcbiAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzEyXSA9IChhMTEgKiBiMDcgLSBhMTAgKiBiMDkgLSBhMTIgKiBiMDYpICogZGV0O1xuICAgIG91dFsxM10gPSAoYTAwICogYjA5IC0gYTAxICogYjA3ICsgYTAyICogYjA2KSAqIGRldDtcbiAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgb3V0WzE1XSA9IChhMjAgKiBiMDMgLSBhMjEgKiBiMDEgKyBhMjIgKiBiMDApICogZGV0O1xuXG4gICAgcmV0dXJuIG91dDtcbn1cblxuLyoqXG4gKiBBIG1ldGhvZCBmb3IgbXVsdGlwbHlpbmcgdHdvIG1hdHJpY2llc1xuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBvdXQgYXJyYXkgdG8gc3RvcmUgdGhlIHJldHVybiBvZiB0aGUgbXVsdGlwbGljYXRpb25cbiAqIEBwYXJhbSB7QXJyYXl9IGEgdHJhbnNmb3JtIG1hdHJpeCB0byBtdWx0aXBseVxuICogQHBhcmFtIHtBcnJheX0gYiB0cmFuc2Zvcm0gbWF0cml4IHRvIG11bHRpcGx5XG4gKlxuICogQHJldHVybiB7QXJyYXl9IG91dFxuICogICBvdXRwdXQgYXJyYXkgdGhhdCBpcyBzdG9yaW5nIHRoZSB0cmFuc2Zvcm0gbWF0cml4XG4gKi9cbmZ1bmN0aW9uIG11bHRpcGx5IChvdXQsIGEsIGIpIHtcbiAgICB2YXIgYTAwID0gYVswXSwgYTAxID0gYVsxXSwgYTAyID0gYVsyXSwgYTAzID0gYVszXSxcbiAgICAgICAgYTEwID0gYVs0XSwgYTExID0gYVs1XSwgYTEyID0gYVs2XSwgYTEzID0gYVs3XSxcbiAgICAgICAgYTIwID0gYVs4XSwgYTIxID0gYVs5XSwgYTIyID0gYVsxMF0sIGEyMyA9IGFbMTFdLFxuICAgICAgICBhMzAgPSBhWzEyXSwgYTMxID0gYVsxM10sIGEzMiA9IGFbMTRdLCBhMzMgPSBhWzE1XSxcblxuICAgICAgICBiMCA9IGJbMF0sIGIxID0gYlsxXSwgYjIgPSBiWzJdLCBiMyA9IGJbM10sXG4gICAgICAgIGI0ID0gYls0XSwgYjUgPSBiWzVdLCBiNiA9IGJbNl0sIGI3ID0gYls3XSxcbiAgICAgICAgYjggPSBiWzhdLCBiOSA9IGJbOV0sIGIxMCA9IGJbMTBdLCBiMTEgPSBiWzExXSxcbiAgICAgICAgYjEyID0gYlsxMl0sIGIxMyA9IGJbMTNdLCBiMTQgPSBiWzE0XSwgYjE1ID0gYlsxNV07XG5cbiAgICB2YXIgY2hhbmdlZCA9IGZhbHNlO1xuICAgIHZhciBvdXQwLCBvdXQxLCBvdXQyLCBvdXQzO1xuXG4gICAgb3V0MCA9IGIwKmEwMCArIGIxKmExMCArIGIyKmEyMCArIGIzKmEzMDtcbiAgICBvdXQxID0gYjAqYTAxICsgYjEqYTExICsgYjIqYTIxICsgYjMqYTMxO1xuICAgIG91dDIgPSBiMCphMDIgKyBiMSphMTIgKyBiMiphMjIgKyBiMyphMzI7XG4gICAgb3V0MyA9IGIwKmEwMyArIGIxKmExMyArIGIyKmEyMyArIGIzKmEzMztcblxuICAgIGNoYW5nZWQgPSBjaGFuZ2VkID9cbiAgICAgICAgICAgICAgY2hhbmdlZCA6IG91dDAgPT09IG91dFswXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MSA9PT0gb3V0WzFdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQyID09PSBvdXRbMl0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDMgPT09IG91dFszXTtcblxuICAgIG91dFswXSA9IG91dDA7XG4gICAgb3V0WzFdID0gb3V0MTtcbiAgICBvdXRbMl0gPSBvdXQyO1xuICAgIG91dFszXSA9IG91dDM7XG5cbiAgICBiMCA9IGI0OyBiMSA9IGI1OyBiMiA9IGI2OyBiMyA9IGI3O1xuICAgIG91dDAgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0MSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXQyID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dDMgPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/XG4gICAgICAgICAgICAgIGNoYW5nZWQgOiBvdXQwID09PSBvdXRbNF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDEgPT09IG91dFs1XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MiA9PT0gb3V0WzZdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQzID09PSBvdXRbN107XG5cbiAgICBvdXRbNF0gPSBvdXQwO1xuICAgIG91dFs1XSA9IG91dDE7XG4gICAgb3V0WzZdID0gb3V0MjtcbiAgICBvdXRbN10gPSBvdXQzO1xuXG4gICAgYjAgPSBiODsgYjEgPSBiOTsgYjIgPSBiMTA7IGIzID0gYjExO1xuICAgIG91dDAgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0MSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXQyID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dDMgPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/XG4gICAgICAgICAgICAgIGNoYW5nZWQgOiBvdXQwID09PSBvdXRbOF0gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dDEgPT09IG91dFs5XSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MiA9PT0gb3V0WzEwXSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgb3V0MyA9PT0gb3V0WzExXTtcblxuICAgIG91dFs4XSA9IG91dDA7XG4gICAgb3V0WzldID0gb3V0MTtcbiAgICBvdXRbMTBdID0gb3V0MjtcbiAgICBvdXRbMTFdID0gb3V0MztcblxuICAgIGIwID0gYjEyOyBiMSA9IGIxMzsgYjIgPSBiMTQ7IGIzID0gYjE1O1xuICAgIG91dDAgPSBiMCphMDAgKyBiMSphMTAgKyBiMiphMjAgKyBiMyphMzA7XG4gICAgb3V0MSA9IGIwKmEwMSArIGIxKmExMSArIGIyKmEyMSArIGIzKmEzMTtcbiAgICBvdXQyID0gYjAqYTAyICsgYjEqYTEyICsgYjIqYTIyICsgYjMqYTMyO1xuICAgIG91dDMgPSBiMCphMDMgKyBiMSphMTMgKyBiMiphMjMgKyBiMyphMzM7XG5cbiAgICBjaGFuZ2VkID0gY2hhbmdlZCA/XG4gICAgICAgICAgICAgIGNoYW5nZWQgOiBvdXQwID09PSBvdXRbMTJdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQxID09PSBvdXRbMTNdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQyID09PSBvdXRbMTRdIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBvdXQzID09PSBvdXRbMTVdO1xuXG4gICAgb3V0WzEyXSA9IG91dDA7XG4gICAgb3V0WzEzXSA9IG91dDE7XG4gICAgb3V0WzE0XSA9IG91dDI7XG4gICAgb3V0WzE1XSA9IG91dDM7XG5cbiAgICByZXR1cm4gb3V0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBtdWx0aXBseTogbXVsdGlwbHksXG4gICAgaW52ZXJ0OiBpbnZlcnRcbn07XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWFwIG9mIHZvaWQgZWxlbWVudHMgYXMgZGVmaW5lZCBieSB0aGVcbiAqIFtIVE1MNSBzcGVjXShodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9zeW50YXguaHRtbCNlbGVtZW50cy0wKS5cbiAqXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG52YXIgVm9pZEVsZW1lbnRzID0ge1xuICAgIGFyZWEgIDogdHJ1ZSxcbiAgICBiYXNlICA6IHRydWUsXG4gICAgYnIgICAgOiB0cnVlLFxuICAgIGNvbCAgIDogdHJ1ZSxcbiAgICBlbWJlZCA6IHRydWUsXG4gICAgaHIgICAgOiB0cnVlLFxuICAgIGltZyAgIDogdHJ1ZSxcbiAgICBpbnB1dCA6IHRydWUsXG4gICAga2V5Z2VuOiB0cnVlLFxuICAgIGxpbmsgIDogdHJ1ZSxcbiAgICBtZXRhICA6IHRydWUsXG4gICAgcGFyYW0gOiB0cnVlLFxuICAgIHNvdXJjZTogdHJ1ZSxcbiAgICB0cmFjayA6IHRydWUsXG4gICAgd2JyICAgOiB0cnVlXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFZvaWRFbGVtZW50cztcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxuLyoqXG4gKiBTZWUgW1VJIEV2ZW50cyAoZm9ybWVybHkgRE9NIExldmVsIDMgRXZlbnRzKV0oaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC11aWV2ZW50cy0yMDE1MDQyOC8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzKS5cbiAqXG4gKiBAY2xhc3MgQ29tcG9zaXRpb25FdmVudFxuICogQGF1Z21lbnRzIFVJRXZlbnRcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgbmF0aXZlIERPTSBldmVudC5cbiAqL1xuZnVuY3Rpb24gQ29tcG9zaXRpb25FdmVudChldikge1xuICAgIC8vIFtDb25zdHJ1Y3RvcihET01TdHJpbmcgdHlwZUFyZywgb3B0aW9uYWwgQ29tcG9zaXRpb25FdmVudEluaXQgY29tcG9zaXRpb25FdmVudEluaXREaWN0KV1cbiAgICAvLyBpbnRlcmZhY2UgQ29tcG9zaXRpb25FdmVudCA6IFVJRXZlbnQge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgRE9NU3RyaW5nIGRhdGE7XG4gICAgLy8gfTtcblxuICAgIFVJRXZlbnQuY2FsbCh0aGlzLCBldik7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBDb21wb3NpdGlvbkV2ZW50I2RhdGFcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBldi5kYXRhO1xufVxuXG5Db21wb3NpdGlvbkV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUpO1xuQ29tcG9zaXRpb25FdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDb21wb3NpdGlvbkV2ZW50O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqL1xuQ29tcG9zaXRpb25FdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdDb21wb3NpdGlvbkV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRpb25FdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBUaGUgRXZlbnQgY2xhc3MgaXMgYmVpbmcgdXNlZCBpbiBvcmRlciB0byBub3JtYWxpemUgbmF0aXZlIERPTSBldmVudHMuXG4gKiBFdmVudHMgbmVlZCB0byBiZSBub3JtYWxpemVkIGluIG9yZGVyIHRvIGJlIHNlcmlhbGl6ZWQgdGhyb3VnaCB0aGUgc3RydWN0dXJlZFxuICogY2xvbmluZyBhbGdvcml0aG0gdXNlZCBieSB0aGUgYHBvc3RNZXNzYWdlYCBtZXRob2QgKFdlYiBXb3JrZXJzKS5cbiAqXG4gKiBXcmFwcGluZyBET00gZXZlbnRzIGFsc28gaGFzIHRoZSBhZHZhbnRhZ2Ugb2YgcHJvdmlkaW5nIGEgY29uc2lzdGVudFxuICogaW50ZXJmYWNlIGZvciBpbnRlcmFjdGluZyB3aXRoIERPTSBldmVudHMgYWNyb3NzIGJyb3dzZXJzIGJ5IGNvcHlpbmcgb3ZlciBhXG4gKiBzdWJzZXQgb2YgdGhlIGV4cG9zZWQgcHJvcGVydGllcyB0aGF0IGlzIGd1YXJhbnRlZWQgdG8gYmUgY29uc2lzdGVudCBhY3Jvc3NcbiAqIGJyb3dzZXJzLlxuICpcbiAqIFNlZSBbVUkgRXZlbnRzIChmb3JtZXJseSBET00gTGV2ZWwgMyBFdmVudHMpXShodHRwOi8vd3d3LnczLm9yZy9UUi8yMDE1L1dELXVpZXZlbnRzLTIwMTUwNDI4LyNpbnRlcmZhY2UtRXZlbnQpLlxuICpcbiAqIEBjbGFzcyBFdmVudFxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2IFRoZSBuYXRpdmUgRE9NIGV2ZW50LlxuICovXG5mdW5jdGlvbiBFdmVudChldikge1xuICAgIC8vIFtDb25zdHJ1Y3RvcihET01TdHJpbmcgdHlwZSwgb3B0aW9uYWwgRXZlbnRJbml0IGV2ZW50SW5pdERpY3QpLFxuICAgIC8vICBFeHBvc2VkPVdpbmRvdyxXb3JrZXJdXG4gICAgLy8gaW50ZXJmYWNlIEV2ZW50IHtcbiAgICAvLyAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBET01TdHJpbmcgdHlwZTtcbiAgICAvLyAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBFdmVudFRhcmdldD8gdGFyZ2V0O1xuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIEV2ZW50VGFyZ2V0PyBjdXJyZW50VGFyZ2V0O1xuXG4gICAgLy8gICBjb25zdCB1bnNpZ25lZCBzaG9ydCBOT05FID0gMDtcbiAgICAvLyAgIGNvbnN0IHVuc2lnbmVkIHNob3J0IENBUFRVUklOR19QSEFTRSA9IDE7XG4gICAgLy8gICBjb25zdCB1bnNpZ25lZCBzaG9ydCBBVF9UQVJHRVQgPSAyO1xuICAgIC8vICAgY29uc3QgdW5zaWduZWQgc2hvcnQgQlVCQkxJTkdfUEhBU0UgPSAzO1xuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIHVuc2lnbmVkIHNob3J0IGV2ZW50UGhhc2U7XG5cbiAgICAvLyAgIHZvaWQgc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgLy8gICB2b2lkIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXG4gICAgLy8gICByZWFkb25seSBhdHRyaWJ1dGUgYm9vbGVhbiBidWJibGVzO1xuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIGJvb2xlYW4gY2FuY2VsYWJsZTtcbiAgICAvLyAgIHZvaWQgcHJldmVudERlZmF1bHQoKTtcbiAgICAvLyAgIHJlYWRvbmx5IGF0dHJpYnV0ZSBib29sZWFuIGRlZmF1bHRQcmV2ZW50ZWQ7XG5cbiAgICAvLyAgIFtVbmZvcmdlYWJsZV0gcmVhZG9ubHkgYXR0cmlidXRlIGJvb2xlYW4gaXNUcnVzdGVkO1xuICAgIC8vICAgcmVhZG9ubHkgYXR0cmlidXRlIERPTVRpbWVTdGFtcCB0aW1lU3RhbXA7XG5cbiAgICAvLyAgIHZvaWQgaW5pdEV2ZW50KERPTVN0cmluZyB0eXBlLCBib29sZWFuIGJ1YmJsZXMsIGJvb2xlYW4gY2FuY2VsYWJsZSk7XG4gICAgLy8gfTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIEV2ZW50I3R5cGVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLnR5cGUgPSBldi50eXBlO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgRXZlbnQjZGVmYXVsdFByZXZlbnRlZFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmRlZmF1bHRQcmV2ZW50ZWQgPSBldi5kZWZhdWx0UHJldmVudGVkO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgRXZlbnQjdGltZVN0YW1wXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy50aW1lU3RhbXAgPSBldi50aW1lU3RhbXA7XG5cblxuICAgIC8qKlxuICAgICAqIFVzZWQgZm9yIGV4cG9zaW5nIHRoZSBjdXJyZW50IHRhcmdldCdzIHZhbHVlLlxuICAgICAqXG4gICAgICogQG5hbWUgRXZlbnQjdmFsdWVcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB2YXIgdGFyZ2V0Q29uc3RydWN0b3IgPSBldi50YXJnZXQuY29uc3RydWN0b3I7XG4gICAgLy8gVE9ETyBTdXBwb3J0IEhUTUxLZXlnZW5FbGVtZW50XG4gICAgaWYgKFxuICAgICAgICB0YXJnZXRDb25zdHJ1Y3RvciA9PT0gSFRNTElucHV0RWxlbWVudCB8fFxuICAgICAgICB0YXJnZXRDb25zdHJ1Y3RvciA9PT0gSFRNTFRleHRBcmVhRWxlbWVudCB8fFxuICAgICAgICB0YXJnZXRDb25zdHJ1Y3RvciA9PT0gSFRNTFNlbGVjdEVsZW1lbnRcbiAgICApIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGV2LnRhcmdldC52YWx1ZTtcbiAgICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0eXBlXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICovXG5FdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdFdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vQ29tcG9zaXRpb25FdmVudCcpO1xudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xudmFyIEZvY3VzRXZlbnQgPSByZXF1aXJlKCcuL0ZvY3VzRXZlbnQnKTtcbnZhciBJbnB1dEV2ZW50ID0gcmVxdWlyZSgnLi9JbnB1dEV2ZW50Jyk7XG52YXIgS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vS2V5Ym9hcmRFdmVudCcpO1xudmFyIE1vdXNlRXZlbnQgPSByZXF1aXJlKCcuL01vdXNlRXZlbnQnKTtcbnZhciBUb3VjaEV2ZW50ID0gcmVxdWlyZSgnLi9Ub3VjaEV2ZW50Jyk7XG52YXIgVUlFdmVudCA9IHJlcXVpcmUoJy4vVUlFdmVudCcpO1xudmFyIFdoZWVsRXZlbnQgPSByZXF1aXJlKCcuL1doZWVsRXZlbnQnKTtcblxuLyoqXG4gKiBBIG1hcHBpbmcgb2YgRE9NIGV2ZW50cyB0byB0aGUgY29ycmVzcG9uZGluZyBoYW5kbGVyc1xuICpcbiAqIEBuYW1lIEV2ZW50TWFwXG4gKiBAdHlwZSBPYmplY3RcbiAqL1xudmFyIEV2ZW50TWFwID0ge1xuICAgIGNoYW5nZSAgICAgICAgICAgICAgICAgICAgICAgICA6IFtFdmVudCwgdHJ1ZV0sXG4gICAgc3VibWl0ICAgICAgICAgICAgICAgICAgICAgICAgIDogW0V2ZW50LCB0cnVlXSxcblxuICAgIC8vIFVJIEV2ZW50cyAoaHR0cDovL3d3dy53My5vcmcvVFIvdWlldmVudHMvKVxuICAgIGFib3J0ICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtFdmVudCwgZmFsc2VdLFxuICAgIGJlZm9yZWlucHV0ICAgICAgICAgICAgICAgICAgICA6IFtJbnB1dEV2ZW50LCB0cnVlXSxcbiAgICBibHVyICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbRm9jdXNFdmVudCwgZmFsc2VdLFxuICAgIGNsaWNrICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtNb3VzZUV2ZW50LCB0cnVlXSxcbiAgICBjb21wb3NpdGlvbmVuZCAgICAgICAgICAgICAgICAgOiBbQ29tcG9zaXRpb25FdmVudCwgdHJ1ZV0sXG4gICAgY29tcG9zaXRpb25zdGFydCAgICAgICAgICAgICAgIDogW0NvbXBvc2l0aW9uRXZlbnQsIHRydWVdLFxuICAgIGNvbXBvc2l0aW9udXBkYXRlICAgICAgICAgICAgICA6IFtDb21wb3NpdGlvbkV2ZW50LCB0cnVlXSxcbiAgICBkYmxjbGljayAgICAgICAgICAgICAgICAgICAgICAgOiBbTW91c2VFdmVudCwgdHJ1ZV0sXG4gICAgZm9jdXMgICAgICAgICAgICAgICAgICAgICAgICAgIDogW0ZvY3VzRXZlbnQsIGZhbHNlXSxcbiAgICBmb2N1c2luICAgICAgICAgICAgICAgICAgICAgICAgOiBbRm9jdXNFdmVudCwgdHJ1ZV0sXG4gICAgZm9jdXNvdXQgICAgICAgICAgICAgICAgICAgICAgIDogW0ZvY3VzRXZlbnQsIHRydWVdLFxuICAgIGlucHV0ICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtJbnB1dEV2ZW50LCB0cnVlXSxcbiAgICBrZXlkb3duICAgICAgICAgICAgICAgICAgICAgICAgOiBbS2V5Ym9hcmRFdmVudCwgdHJ1ZV0sXG4gICAga2V5dXAgICAgICAgICAgICAgICAgICAgICAgICAgIDogW0tleWJvYXJkRXZlbnQsIHRydWVdLFxuICAgIGxvYWQgICAgICAgICAgICAgICAgICAgICAgICAgICA6IFtFdmVudCwgZmFsc2VdLFxuICAgIG1vdXNlZG93biAgICAgICAgICAgICAgICAgICAgICA6IFtNb3VzZUV2ZW50LCB0cnVlXSxcbiAgICBtb3VzZWVudGVyICAgICAgICAgICAgICAgICAgICAgOiBbTW91c2VFdmVudCwgZmFsc2VdLFxuICAgIG1vdXNlbGVhdmUgICAgICAgICAgICAgICAgICAgICA6IFtNb3VzZUV2ZW50LCBmYWxzZV0sXG5cbiAgICAvLyBidWJibGVzLCBidXQgd2lsbCBiZSB0cmlnZ2VyZWQgdmVyeSBmcmVxdWVudGx5XG4gICAgbW91c2Vtb3ZlICAgICAgICAgICAgICAgICAgICAgIDogW01vdXNlRXZlbnQsIGZhbHNlXSxcblxuICAgIG1vdXNlb3V0ICAgICAgICAgICAgICAgICAgICAgICA6IFtNb3VzZUV2ZW50LCB0cnVlXSxcbiAgICBtb3VzZW92ZXIgICAgICAgICAgICAgICAgICAgICAgOiBbTW91c2VFdmVudCwgdHJ1ZV0sXG4gICAgbW91c2V1cCAgICAgICAgICAgICAgICAgICAgICAgIDogW01vdXNlRXZlbnQsIHRydWVdLFxuICAgIGNvbnRleHRNZW51ICAgICAgICAgICAgICAgICAgICA6IFtNb3VzZUV2ZW50LCB0cnVlXSxcbiAgICByZXNpemUgICAgICAgICAgICAgICAgICAgICAgICAgOiBbVUlFdmVudCwgZmFsc2VdLFxuXG4gICAgLy8gbWlnaHQgYnViYmxlXG4gICAgc2Nyb2xsICAgICAgICAgICAgICAgICAgICAgICAgIDogW1VJRXZlbnQsIGZhbHNlXSxcblxuICAgIHNlbGVjdCAgICAgICAgICAgICAgICAgICAgICAgICA6IFtFdmVudCwgdHJ1ZV0sXG4gICAgdW5sb2FkICAgICAgICAgICAgICAgICAgICAgICAgIDogW0V2ZW50LCBmYWxzZV0sXG4gICAgd2hlZWwgICAgICAgICAgICAgICAgICAgICAgICAgIDogW1doZWVsRXZlbnQsIHRydWVdLFxuXG4gICAgLy8gVG91Y2ggRXZlbnRzIEV4dGVuc2lvbiAoaHR0cDovL3d3dy53My5vcmcvVFIvdG91Y2gtZXZlbnRzLWV4dGVuc2lvbnMvKVxuICAgIHRvdWNoY2FuY2VsICAgICAgICAgICAgICAgICAgICA6IFtUb3VjaEV2ZW50LCB0cnVlXSxcbiAgICB0b3VjaGVuZCAgICAgICAgICAgICAgICAgICAgICAgOiBbVG91Y2hFdmVudCwgdHJ1ZV0sXG4gICAgdG91Y2htb3ZlICAgICAgICAgICAgICAgICAgICAgIDogW1RvdWNoRXZlbnQsIHRydWVdLFxuICAgIHRvdWNoc3RhcnQgICAgICAgICAgICAgICAgICAgICA6IFtUb3VjaEV2ZW50LCB0cnVlXVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudE1hcDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxuLyoqXG4gKiBTZWUgW1VJIEV2ZW50cyAoZm9ybWVybHkgRE9NIExldmVsIDMgRXZlbnRzKV0oaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC11aWV2ZW50cy0yMDE1MDQyOC8jZXZlbnRzLWZvY3VzZXZlbnQpLlxuICpcbiAqIEBjbGFzcyBGb2N1c0V2ZW50XG4gKiBAYXVnbWVudHMgVUlFdmVudFxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2IFRoZSBuYXRpdmUgRE9NIGV2ZW50LlxuICovXG5mdW5jdGlvbiBGb2N1c0V2ZW50KGV2KSB7XG4gICAgLy8gW0NvbnN0cnVjdG9yKERPTVN0cmluZyB0eXBlQXJnLCBvcHRpb25hbCBGb2N1c0V2ZW50SW5pdCBmb2N1c0V2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBGb2N1c0V2ZW50IDogVUlFdmVudCB7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBFdmVudFRhcmdldD8gcmVsYXRlZFRhcmdldDtcbiAgICAvLyB9O1xuXG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcbn1cblxuRm9jdXNFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFVJRXZlbnQucHJvdG90eXBlKTtcbkZvY3VzRXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRm9jdXNFdmVudDtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0eXBlXG4gKi9cbkZvY3VzRXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnRm9jdXNFdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZvY3VzRXZlbnQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVSUV2ZW50ID0gcmVxdWlyZSgnLi9VSUV2ZW50Jyk7XG5cbi8qKlxuICogU2VlIFtJbnB1dCBFdmVudHNdKGh0dHA6Ly93M2MuZ2l0aHViLmlvL2VkaXRpbmctZXhwbGFpbmVyL2lucHV0LWV2ZW50cy5odG1sI2lkbC1kZWYtSW5wdXRFdmVudCkuXG4gKlxuICogQGNsYXNzIElucHV0RXZlbnRcbiAqIEBhdWdtZW50cyBVSUV2ZW50XG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXYgVGhlIG5hdGl2ZSBET00gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIElucHV0RXZlbnQoZXYpIHtcbiAgICAvLyBbQ29uc3RydWN0b3IoRE9NU3RyaW5nIHR5cGVBcmcsIG9wdGlvbmFsIElucHV0RXZlbnRJbml0IGlucHV0RXZlbnRJbml0RGljdCldXG4gICAgLy8gaW50ZXJmYWNlIElucHV0RXZlbnQgOiBVSUV2ZW50IHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIERPTVN0cmluZyBpbnB1dFR5cGU7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBET01TdHJpbmcgZGF0YTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICBpc0NvbXBvc2luZztcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIFJhbmdlICAgICB0YXJnZXRSYW5nZTtcbiAgICAvLyB9O1xuXG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lICAgIElucHV0RXZlbnQjaW5wdXRUeXBlXG4gICAgICogQHR5cGUgICAgU3RyaW5nXG4gICAgICovXG4gICAgdGhpcy5pbnB1dFR5cGUgPSBldi5pbnB1dFR5cGU7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSAgICBJbnB1dEV2ZW50I2RhdGFcbiAgICAgKiBAdHlwZSAgICBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLmRhdGEgPSBldi5kYXRhO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgICAgSW5wdXRFdmVudCNpc0NvbXBvc2luZ1xuICAgICAqIEB0eXBlICAgIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLmlzQ29tcG9zaW5nID0gZXYuaXNDb21wb3Npbmc7XG5cbiAgICAvKipcbiAgICAgKiAqKkxpbWl0ZWQgYnJvd3NlciBzdXBwb3J0KiouXG4gICAgICpcbiAgICAgKiBAbmFtZSAgICBJbnB1dEV2ZW50I3RhcmdldFJhbmdlXG4gICAgICogQHR5cGUgICAgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMudGFyZ2V0UmFuZ2UgPSBldi50YXJnZXRSYW5nZTtcbn1cblxuSW5wdXRFdmVudC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKFVJRXZlbnQucHJvdG90eXBlKTtcbklucHV0RXZlbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gSW5wdXRFdmVudDtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSBOYW1lIG9mIHRoZSBldmVudCB0eXBlXG4gKi9cbklucHV0RXZlbnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICAgIHJldHVybiAnSW5wdXRFdmVudCc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IElucHV0RXZlbnQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVSUV2ZW50ID0gcmVxdWlyZSgnLi9VSUV2ZW50Jyk7XG5cbi8qKlxuICogU2VlIFtVSSBFdmVudHMgKGZvcm1lcmx5IERPTSBMZXZlbCAzIEV2ZW50cyldKGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTUvV0QtdWlldmVudHMtMjAxNTA0MjgvI2V2ZW50cy1rZXlib2FyZGV2ZW50cykuXG4gKlxuICogQGNsYXNzIEtleWJvYXJkRXZlbnRcbiAqIEBhdWdtZW50cyBVSUV2ZW50XG4gKlxuICogQHBhcmFtIHtFdmVudH0gZXYgVGhlIG5hdGl2ZSBET00gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIEtleWJvYXJkRXZlbnQoZXYpIHtcbiAgICAvLyBbQ29uc3RydWN0b3IoRE9NU3RyaW5nIHR5cGVBcmcsIG9wdGlvbmFsIEtleWJvYXJkRXZlbnRJbml0IGtleWJvYXJkRXZlbnRJbml0RGljdCldXG4gICAgLy8gaW50ZXJmYWNlIEtleWJvYXJkRXZlbnQgOiBVSUV2ZW50IHtcbiAgICAvLyAgICAgLy8gS2V5TG9jYXRpb25Db2RlXG4gICAgLy8gICAgIGNvbnN0IHVuc2lnbmVkIGxvbmcgRE9NX0tFWV9MT0NBVElPTl9TVEFOREFSRCA9IDB4MDA7XG4gICAgLy8gICAgIGNvbnN0IHVuc2lnbmVkIGxvbmcgRE9NX0tFWV9MT0NBVElPTl9MRUZUID0gMHgwMTtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fS0VZX0xPQ0FUSU9OX1JJR0hUID0gMHgwMjtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fS0VZX0xPQ0FUSU9OX05VTVBBRCA9IDB4MDM7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBET01TdHJpbmcgICAgIGtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIERPTVN0cmluZyAgICAgY29kZTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIHVuc2lnbmVkIGxvbmcgbG9jYXRpb247XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIGN0cmxLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIHNoaWZ0S2V5O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgICAgICBhbHRLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIG1ldGFLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgIHJlcGVhdDtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgaXNDb21wb3Npbmc7XG4gICAgLy8gICAgIGJvb2xlYW4gZ2V0TW9kaWZpZXJTdGF0ZSAoRE9NU3RyaW5nIGtleUFyZyk7XG4gICAgLy8gfTtcblxuICAgIFVJRXZlbnQuY2FsbCh0aGlzLCBldik7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBLZXlib2FyZEV2ZW50I0RPTV9LRVlfTE9DQVRJT05fU1RBTkRBUkRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLkRPTV9LRVlfTE9DQVRJT05fU1RBTkRBUkQgPSAweDAwO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNET01fS0VZX0xPQ0FUSU9OX0xFRlRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLkRPTV9LRVlfTE9DQVRJT05fTEVGVCA9IDB4MDE7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBLZXlib2FyZEV2ZW50I0RPTV9LRVlfTE9DQVRJT05fUklHSFRcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLkRPTV9LRVlfTE9DQVRJT05fUklHSFQgPSAweDAyO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNET01fS0VZX0xPQ0FUSU9OX05VTVBBRFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuRE9NX0tFWV9MT0NBVElPTl9OVU1QQUQgPSAweDAzO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNrZXlcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICB0aGlzLmtleSA9IGV2LmtleTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIEtleWJvYXJkRXZlbnQjY29kZVxuICAgICAqIEB0eXBlIFN0cmluZ1xuICAgICAqL1xuICAgIHRoaXMuY29kZSA9IGV2LmNvZGU7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBLZXlib2FyZEV2ZW50I2xvY2F0aW9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5sb2NhdGlvbiA9IGV2LmxvY2F0aW9uO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNjdHJsS2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuY3RybEtleSA9IGV2LmN0cmxLZXk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBLZXlib2FyZEV2ZW50I3NoaWZ0S2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuc2hpZnRLZXkgPSBldi5zaGlmdEtleTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIEtleWJvYXJkRXZlbnQjYWx0S2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuYWx0S2V5ID0gZXYuYWx0S2V5O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNtZXRhS2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMubWV0YUtleSA9IGV2Lm1ldGFLZXk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBLZXlib2FyZEV2ZW50I3JlcGVhdFxuICAgICAqIEB0eXBlIEJvb2xlYW5cbiAgICAgKi9cbiAgICB0aGlzLnJlcGVhdCA9IGV2LnJlcGVhdDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIEtleWJvYXJkRXZlbnQjaXNDb21wb3NpbmdcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5pc0NvbXBvc2luZyA9IGV2LmlzQ29tcG9zaW5nO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgS2V5Ym9hcmRFdmVudCNrZXlDb2RlXG4gICAgICogQHR5cGUgU3RyaW5nXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICB0aGlzLmtleUNvZGUgPSBldi5rZXlDb2RlO1xufVxuXG5LZXlib2FyZEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUpO1xuS2V5Ym9hcmRFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBLZXlib2FyZEV2ZW50O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqL1xuS2V5Ym9hcmRFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdLZXlib2FyZEV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gS2V5Ym9hcmRFdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxuLyoqXG4gKiBTZWUgW1VJIEV2ZW50cyAoZm9ybWVybHkgRE9NIExldmVsIDMgRXZlbnRzKV0oaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC11aWV2ZW50cy0yMDE1MDQyOC8jZXZlbnRzLW1vdXNlZXZlbnRzKS5cbiAqXG4gKiBAY2xhc3MgS2V5Ym9hcmRFdmVudFxuICogQGF1Z21lbnRzIFVJRXZlbnRcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgbmF0aXZlIERPTSBldmVudC5cbiAqL1xuZnVuY3Rpb24gTW91c2VFdmVudChldikge1xuICAgIC8vIFtDb25zdHJ1Y3RvcihET01TdHJpbmcgdHlwZUFyZywgb3B0aW9uYWwgTW91c2VFdmVudEluaXQgbW91c2VFdmVudEluaXREaWN0KV1cbiAgICAvLyBpbnRlcmZhY2UgTW91c2VFdmVudCA6IFVJRXZlbnQge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgbG9uZyAgICAgICAgICAgc2NyZWVuWDtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGxvbmcgICAgICAgICAgIHNjcmVlblk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBsb25nICAgICAgICAgICBjbGllbnRYO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgbG9uZyAgICAgICAgICAgY2xpZW50WTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgIGN0cmxLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgICAgICBzaGlmdEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgIGFsdEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICAgICAgIG1ldGFLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBzaG9ydCAgICAgICAgICBidXR0b247XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBFdmVudFRhcmdldD8gICByZWxhdGVkVGFyZ2V0O1xuICAgIC8vICAgICAvLyBJbnRyb2R1Y2VkIGluIHRoaXMgc3BlY2lmaWNhdGlvblxuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgdW5zaWduZWQgc2hvcnQgYnV0dG9ucztcbiAgICAvLyAgICAgYm9vbGVhbiBnZXRNb2RpZmllclN0YXRlIChET01TdHJpbmcga2V5QXJnKTtcbiAgICAvLyB9O1xuXG4gICAgVUlFdmVudC5jYWxsKHRoaXMsIGV2KTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIE1vdXNlRXZlbnQjc2NyZWVuWFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuc2NyZWVuWCA9IGV2LnNjcmVlblg7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBNb3VzZUV2ZW50I3NjcmVlbllcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnNjcmVlblkgPSBldi5zY3JlZW5ZO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgTW91c2VFdmVudCNjbGllbnRYXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5jbGllbnRYID0gZXYuY2xpZW50WDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIE1vdXNlRXZlbnQjY2xpZW50WVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50WSA9IGV2LmNsaWVudFk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBNb3VzZUV2ZW50I2N0cmxLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5jdHJsS2V5ID0gZXYuY3RybEtleTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIE1vdXNlRXZlbnQjc2hpZnRLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5zaGlmdEtleSA9IGV2LnNoaWZ0S2V5O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgTW91c2VFdmVudCNhbHRLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5hbHRLZXkgPSBldi5hbHRLZXk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBNb3VzZUV2ZW50I21ldGFLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5tZXRhS2V5ID0gZXYubWV0YUtleTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIE1vdXNlRXZlbnQjYnV0dG9uXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5idXR0b24gPSBldi5idXR0b247XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSBNb3VzZUV2ZW50I2J1dHRvbnNcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmJ1dHRvbnMgPSBldi5idXR0b25zO1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgTW91c2VFdmVudCNwYWdlWFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMucGFnZVggPSBldi5wYWdlWDtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIE1vdXNlRXZlbnQjcGFnZVlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnBhZ2VZID0gZXYucGFnZVk7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSBNb3VzZUV2ZW50I3hcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnggPSBldi54O1xuXG4gICAgLyoqXG4gICAgICogQHR5cGUgTW91c2VFdmVudCN5XG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy55ID0gZXYueTtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIE1vdXNlRXZlbnQjb2Zmc2V0WFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMub2Zmc2V0WCA9IGV2Lm9mZnNldFg7XG5cbiAgICAvKipcbiAgICAgKiBAdHlwZSBNb3VzZUV2ZW50I29mZnNldFlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLm9mZnNldFkgPSBldi5vZmZzZXRZO1xufVxuXG5Nb3VzZUV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUpO1xuTW91c2VFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBNb3VzZUV2ZW50O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqL1xuTW91c2VFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdNb3VzZUV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gTW91c2VFdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFVJRXZlbnQgPSByZXF1aXJlKCcuL1VJRXZlbnQnKTtcblxudmFyIEVNUFRZX0FSUkFZID0gW107XG5cbi8qKlxuICogU2VlIFtUb3VjaCBJbnRlcmZhY2VdKGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvUkVDLXRvdWNoLWV2ZW50cy0yMDEzMTAxMC8jdG91Y2gtaW50ZXJmYWNlKS5cbiAqXG4gKiBAY2xhc3MgVG91Y2hcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtIHtUb3VjaH0gdG91Y2ggVGhlIG5hdGl2ZSBUb3VjaCBvYmplY3QuXG4gKi9cbmZ1bmN0aW9uIFRvdWNoKHRvdWNoKSB7XG4gICAgLy8gaW50ZXJmYWNlIFRvdWNoIHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGxvbmcgICAgICAgIGlkZW50aWZpZXI7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBFdmVudFRhcmdldCB0YXJnZXQ7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBzY3JlZW5YO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgc2NyZWVuWTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGRvdWJsZSAgICAgIGNsaWVudFg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBjbGllbnRZO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgcGFnZVg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICBwYWdlWTtcbiAgICAvLyB9O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVG91Y2gjaWRlbnRpZmllclxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuaWRlbnRpZmllciA9IHRvdWNoLmlkZW50aWZpZXI7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaCNzY3JlZW5YXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5zY3JlZW5YID0gdG91Y2guc2NyZWVuWDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFRvdWNoI3NjcmVlbllcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnNjcmVlblkgPSB0b3VjaC5zY3JlZW5ZO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVG91Y2gjY2xpZW50WFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuY2xpZW50WCA9IHRvdWNoLmNsaWVudFg7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaCNjbGllbnRZXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5jbGllbnRZID0gdG91Y2guY2xpZW50WTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFRvdWNoI3BhZ2VYXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5wYWdlWCA9IHRvdWNoLnBhZ2VYO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVG91Y2gjcGFnZVlcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLnBhZ2VZID0gdG91Y2gucGFnZVk7XG59XG5cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSBicm93c2VyJ3MgbmF0aXZlIFRvdWNoTGlzdCBieSBjb252ZXJ0aW5nIGl0IGludG8gYW4gYXJyYXkgb2ZcbiAqIG5vcm1hbGl6ZWQgVG91Y2ggb2JqZWN0cy5cbiAqXG4gKiBAbWV0aG9kICBjbG9uZVRvdWNoTGlzdFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gIHtUb3VjaExpc3R9IHRvdWNoTGlzdCAgICBUaGUgbmF0aXZlIFRvdWNoTGlzdCBhcnJheS5cbiAqIEByZXR1cm4ge0FycmF5LjxUb3VjaD59ICAgICAgICAgIEFuIGFycmF5IG9mIG5vcm1hbGl6ZWQgVG91Y2ggb2JqZWN0cy5cbiAqL1xuZnVuY3Rpb24gY2xvbmVUb3VjaExpc3QodG91Y2hMaXN0KSB7XG4gICAgaWYgKCF0b3VjaExpc3QpIHJldHVybiBFTVBUWV9BUlJBWTtcbiAgICAvLyBpbnRlcmZhY2UgVG91Y2hMaXN0IHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIHVuc2lnbmVkIGxvbmcgbGVuZ3RoO1xuICAgIC8vICAgICBnZXR0ZXIgVG91Y2g/IGl0ZW0gKHVuc2lnbmVkIGxvbmcgaW5kZXgpO1xuICAgIC8vIH07XG5cbiAgICB2YXIgdG91Y2hMaXN0QXJyYXkgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3VjaExpc3RBcnJheVtpXSA9IG5ldyBUb3VjaCh0b3VjaExpc3RbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gdG91Y2hMaXN0QXJyYXk7XG59XG5cbi8qKlxuICogU2VlIFtUb3VjaCBFdmVudCBJbnRlcmZhY2VdKGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTMvUkVDLXRvdWNoLWV2ZW50cy0yMDEzMTAxMC8jdG91Y2hldmVudC1pbnRlcmZhY2UpLlxuICpcbiAqIEBjbGFzcyBUb3VjaEV2ZW50XG4gKiBAYXVnbWVudHMgVUlFdmVudFxuICpcbiAqIEBwYXJhbSB7RXZlbnR9IGV2IFRoZSBuYXRpdmUgRE9NIGV2ZW50LlxuICovXG5mdW5jdGlvbiBUb3VjaEV2ZW50KGV2KSB7XG4gICAgLy8gaW50ZXJmYWNlIFRvdWNoRXZlbnQgOiBVSUV2ZW50IHtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIFRvdWNoTGlzdCB0b3VjaGVzO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgVG91Y2hMaXN0IHRhcmdldFRvdWNoZXM7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBUb3VjaExpc3QgY2hhbmdlZFRvdWNoZXM7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgYWx0S2V5O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgYm9vbGVhbiAgIG1ldGFLZXk7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBib29sZWFuICAgY3RybEtleTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGJvb2xlYW4gICBzaGlmdEtleTtcbiAgICAvLyB9O1xuICAgIFVJRXZlbnQuY2FsbCh0aGlzLCBldik7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaEV2ZW50I3RvdWNoZXNcbiAgICAgKiBAdHlwZSBBcnJheS48VG91Y2g+XG4gICAgICovXG4gICAgdGhpcy50b3VjaGVzID0gY2xvbmVUb3VjaExpc3QoZXYudG91Y2hlcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaEV2ZW50I3RhcmdldFRvdWNoZXNcbiAgICAgKiBAdHlwZSBBcnJheS48VG91Y2g+XG4gICAgICovXG4gICAgdGhpcy50YXJnZXRUb3VjaGVzID0gY2xvbmVUb3VjaExpc3QoZXYudGFyZ2V0VG91Y2hlcyk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaEV2ZW50I2NoYW5nZWRUb3VjaGVzXG4gICAgICogQHR5cGUgVG91Y2hMaXN0XG4gICAgICovXG4gICAgdGhpcy5jaGFuZ2VkVG91Y2hlcyA9IGNsb25lVG91Y2hMaXN0KGV2LmNoYW5nZWRUb3VjaGVzKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFRvdWNoRXZlbnQjYWx0S2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMuYWx0S2V5ID0gZXYuYWx0S2V5O1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgVG91Y2hFdmVudCNtZXRhS2V5XG4gICAgICogQHR5cGUgQm9vbGVhblxuICAgICAqL1xuICAgIHRoaXMubWV0YUtleSA9IGV2Lm1ldGFLZXk7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBUb3VjaEV2ZW50I2N0cmxLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5jdHJsS2V5ID0gZXYuY3RybEtleTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFRvdWNoRXZlbnQjc2hpZnRLZXlcbiAgICAgKiBAdHlwZSBCb29sZWFuXG4gICAgICovXG4gICAgdGhpcy5zaGlmdEtleSA9IGV2LnNoaWZ0S2V5O1xufVxuXG5Ub3VjaEV2ZW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoVUlFdmVudC5wcm90b3R5cGUpO1xuVG91Y2hFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBUb3VjaEV2ZW50O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqL1xuVG91Y2hFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdUb3VjaEV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVG91Y2hFdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50ID0gcmVxdWlyZSgnLi9FdmVudCcpO1xuXG4vKipcbiAqIFNlZSBbVUkgRXZlbnRzIChmb3JtZXJseSBET00gTGV2ZWwgMyBFdmVudHMpXShodHRwOi8vd3d3LnczLm9yZy9UUi8yMDE1L1dELXVpZXZlbnRzLTIwMTUwNDI4KS5cbiAqXG4gKiBAY2xhc3MgVUlFdmVudFxuICogQGF1Z21lbnRzIEV2ZW50XG4gKlxuICogQHBhcmFtICB7RXZlbnR9IGV2ICAgVGhlIG5hdGl2ZSBET00gZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIFVJRXZlbnQoZXYpIHtcbiAgICAvLyBbQ29uc3RydWN0b3IoRE9NU3RyaW5nIHR5cGUsIG9wdGlvbmFsIFVJRXZlbnRJbml0IGV2ZW50SW5pdERpY3QpXVxuICAgIC8vIGludGVyZmFjZSBVSUV2ZW50IDogRXZlbnQge1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgV2luZG93PyB2aWV3O1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgbG9uZyAgICBkZXRhaWw7XG4gICAgLy8gfTtcbiAgICBFdmVudC5jYWxsKHRoaXMsIGV2KTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFVJRXZlbnQjZGV0YWlsXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5kZXRhaWwgPSBldi5kZXRhaWw7XG59XG5cblVJRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudC5wcm90b3R5cGUpO1xuVUlFdmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBVSUV2ZW50O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IE5hbWUgb2YgdGhlIGV2ZW50IHR5cGVcbiAqL1xuVUlFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZyAoKSB7XG4gICAgcmV0dXJuICdVSUV2ZW50Jztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVUlFdmVudDtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIE1vdXNlRXZlbnQgPSByZXF1aXJlKCcuL01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBTZWUgW1VJIEV2ZW50cyAoZm9ybWVybHkgRE9NIExldmVsIDMgRXZlbnRzKV0oaHR0cDovL3d3dy53My5vcmcvVFIvMjAxNS9XRC11aWV2ZW50cy0yMDE1MDQyOC8jZXZlbnRzLXdoZWVsZXZlbnRzKS5cbiAqXG4gKiBAY2xhc3MgV2hlZWxFdmVudFxuICogQGF1Z21lbnRzIFVJRXZlbnRcbiAqXG4gKiBAcGFyYW0ge0V2ZW50fSBldiBUaGUgbmF0aXZlIERPTSBldmVudC5cbiAqL1xuZnVuY3Rpb24gV2hlZWxFdmVudChldikge1xuICAgIC8vIFtDb25zdHJ1Y3RvcihET01TdHJpbmcgdHlwZUFyZywgb3B0aW9uYWwgV2hlZWxFdmVudEluaXQgd2hlZWxFdmVudEluaXREaWN0KV1cbiAgICAvLyBpbnRlcmZhY2UgV2hlZWxFdmVudCA6IE1vdXNlRXZlbnQge1xuICAgIC8vICAgICAvLyBEZWx0YU1vZGVDb2RlXG4gICAgLy8gICAgIGNvbnN0IHVuc2lnbmVkIGxvbmcgRE9NX0RFTFRBX1BJWEVMID0gMHgwMDtcbiAgICAvLyAgICAgY29uc3QgdW5zaWduZWQgbG9uZyBET01fREVMVEFfTElORSA9IDB4MDE7XG4gICAgLy8gICAgIGNvbnN0IHVuc2lnbmVkIGxvbmcgRE9NX0RFTFRBX1BBR0UgPSAweDAyO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgZG91YmxlICAgICAgICBkZWx0YVg7XG4gICAgLy8gICAgIHJlYWRvbmx5ICAgIGF0dHJpYnV0ZSBkb3VibGUgICAgICAgIGRlbHRhWTtcbiAgICAvLyAgICAgcmVhZG9ubHkgICAgYXR0cmlidXRlIGRvdWJsZSAgICAgICAgZGVsdGFaO1xuICAgIC8vICAgICByZWFkb25seSAgICBhdHRyaWJ1dGUgdW5zaWduZWQgbG9uZyBkZWx0YU1vZGU7XG4gICAgLy8gfTtcblxuICAgIE1vdXNlRXZlbnQuY2FsbCh0aGlzLCBldik7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBXaGVlbEV2ZW50I0RPTV9ERUxUQV9QSVhFTFxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuRE9NX0RFTFRBX1BJWEVMID0gMHgwMDtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFdoZWVsRXZlbnQjRE9NX0RFTFRBX0xJTkVcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLkRPTV9ERUxUQV9MSU5FID0gMHgwMTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFdoZWVsRXZlbnQjRE9NX0RFTFRBX1BBR0VcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLkRPTV9ERUxUQV9QQUdFID0gMHgwMjtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFdoZWVsRXZlbnQjZGVsdGFYXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5kZWx0YVggPSBldi5kZWx0YVg7XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBXaGVlbEV2ZW50I2RlbHRhWVxuICAgICAqIEB0eXBlIE51bWJlclxuICAgICAqL1xuICAgIHRoaXMuZGVsdGFZID0gZXYuZGVsdGFZO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgV2hlZWxFdmVudCNkZWx0YVpcbiAgICAgKiBAdHlwZSBOdW1iZXJcbiAgICAgKi9cbiAgICB0aGlzLmRlbHRhWiA9IGV2LmRlbHRhWjtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIFdoZWVsRXZlbnQjZGVsdGFNb2RlXG4gICAgICogQHR5cGUgTnVtYmVyXG4gICAgICovXG4gICAgdGhpcy5kZWx0YU1vZGUgPSBldi5kZWx0YU1vZGU7XG59XG5cbldoZWVsRXZlbnQucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShNb3VzZUV2ZW50LnByb3RvdHlwZSk7XG5XaGVlbEV2ZW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdoZWVsRXZlbnQ7XG5cbi8qKlxuICogUmV0dXJuIHRoZSBuYW1lIG9mIHRoZSBldmVudCB0eXBlXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gTmFtZSBvZiB0aGUgZXZlbnQgdHlwZVxuICovXG5XaGVlbEV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgICByZXR1cm4gJ1doZWVsRXZlbnQnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXaGVlbEV2ZW50O1xuIiwiLy8gaHR0cDovL3BhdWxpcmlzaC5jb20vMjAxMS9yZXF1ZXN0YW5pbWF0aW9uZnJhbWUtZm9yLXNtYXJ0LWFuaW1hdGluZy9cbi8vIGh0dHA6Ly9teS5vcGVyYS5jb20vZW1vbGxlci9ibG9nLzIwMTEvMTIvMjAvcmVxdWVzdGFuaW1hdGlvbmZyYW1lLWZvci1zbWFydC1lci1hbmltYXRpbmdcbi8vIHJlcXVlc3RBbmltYXRpb25GcmFtZSBwb2x5ZmlsbCBieSBFcmlrIE3DtmxsZXIuIGZpeGVzIGZyb20gUGF1bCBJcmlzaCBhbmQgVGlubyBaaWpkZWxcbi8vIE1JVCBsaWNlbnNlXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGxhc3RUaW1lID0gMDtcbnZhciB2ZW5kb3JzID0gWydtcycsICdtb3onLCAnd2Via2l0JywgJ28nXTtcblxudmFyIHJBRiwgY0FGO1xuXG5pZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHtcbiAgICByQUYgPSB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIGNBRiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cuY2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgdmVuZG9ycy5sZW5ndGggJiYgIXJBRjsgKyt4KSB7XG4gICAgICAgIHJBRiA9IHdpbmRvd1t2ZW5kb3JzW3hdICsgJ1JlcXVlc3RBbmltYXRpb25GcmFtZSddO1xuICAgICAgICBjQUYgPSB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXSB8fFxuICAgICAgICAgICAgICB3aW5kb3dbdmVuZG9yc1t4XSArICdDYW5jZWxBbmltYXRpb25GcmFtZSddO1xuICAgIH1cblxuICAgIGlmIChyQUYgJiYgIWNBRikge1xuICAgICAgICAvLyBjQUYgbm90IHN1cHBvcnRlZC5cbiAgICAgICAgLy8gRmFsbCBiYWNrIHRvIHNldEludGVydmFsIGZvciBub3cgKHZlcnkgcmFyZSkuXG4gICAgICAgIHJBRiA9IG51bGw7XG4gICAgfVxufVxuXG5pZiAoIXJBRikge1xuICAgIHZhciBub3cgPSBEYXRlLm5vdyA/IERhdGUubm93IDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gICAgfTtcblxuICAgIHJBRiA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBjdXJyVGltZSA9IG5vdygpO1xuICAgICAgICB2YXIgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKGN1cnJUaW1lIC0gbGFzdFRpbWUpKTtcbiAgICAgICAgdmFyIGlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjdXJyVGltZSArIHRpbWVUb0NhbGwpO1xuICAgICAgICB9LCB0aW1lVG9DYWxsKTtcbiAgICAgICAgbGFzdFRpbWUgPSBjdXJyVGltZSArIHRpbWVUb0NhbGw7XG4gICAgICAgIHJldHVybiBpZDtcbiAgICB9O1xuXG4gICAgY0FGID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcbn1cblxudmFyIGFuaW1hdGlvbkZyYW1lID0ge1xuICAgIC8qKlxuICAgICAqIENyb3NzIGJyb3dzZXIgdmVyc2lvbiBvZiBbcmVxdWVzdEFuaW1hdGlvbkZyYW1lXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L3JlcXVlc3RBbmltYXRpb25GcmFtZX0uXG4gICAgICpcbiAgICAgKiBVc2VkIGJ5IEVuZ2luZSBpbiBvcmRlciB0byBlc3RhYmxpc2ggYSByZW5kZXIgbG9vcC5cbiAgICAgKlxuICAgICAqIElmIG5vICh2ZW5kb3IgcHJlZml4ZWQgdmVyc2lvbiBvZikgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgaXMgYXZhaWxhYmxlLFxuICAgICAqIGBzZXRUaW1lb3V0YCB3aWxsIGJlIHVzZWQgaW4gb3JkZXIgdG8gZW11bGF0ZSBhIHJlbmRlciBsb29wIHJ1bm5pbmcgYXRcbiAgICAgKiBhcHByb3hpbWF0ZWx5IDYwIGZyYW1lcyBwZXIgc2Vjb25kLlxuICAgICAqXG4gICAgICogQG1ldGhvZCAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7RnVuY3Rpb259ICBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBpbnZva2VkIG9uIHRoZSBuZXh0IGZyYW1lLlxuICAgICAqIEByZXR1cm4gIHtOdW1iZXJ9ICAgIHJlcXVlc3RJZCB0byBiZSB1c2VkIHRvIGNhbmNlbCB0aGUgcmVxdWVzdCB1c2luZ1xuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBjYW5jZWxBbmltYXRpb25GcmFtZX0uXG4gICAgICovXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lOiByQUYsXG5cbiAgICAvKipcbiAgICAgKiBDcm9zcyBicm93c2VyIHZlcnNpb24gb2YgW2NhbmNlbEFuaW1hdGlvbkZyYW1lXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvd2luZG93L2NhbmNlbEFuaW1hdGlvbkZyYW1lfS5cbiAgICAgKlxuICAgICAqIENhbmNlbHMgYSBwcmV2aW91c2x5IHVzaW5nIFtyZXF1ZXN0QW5pbWF0aW9uRnJhbWVde0BsaW5rIGFuaW1hdGlvbkZyYW1lI3JlcXVlc3RBbmltYXRpb25GcmFtZX1cbiAgICAgKiBzY2hlZHVsZWQgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIFVzZWQgZm9yIGltbWVkaWF0ZWx5IHN0b3BwaW5nIHRoZSByZW5kZXIgbG9vcCB3aXRoaW4gdGhlIEVuZ2luZS5cbiAgICAgKlxuICAgICAqIEBtZXRob2QgIGNhbmNlbEFuaW1hdGlvbkZyYW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0gICB7TnVtYmVyfSAgICByZXF1ZXN0SWQgb2YgdGhlIHNjaGVkdWxlZCBjYWxsYmFjayBmdW5jdGlvblxuICAgICAqICAgICAgICAgICAgICAgICAgICAgIHJldHVybmVkIGJ5IFtyZXF1ZXN0QW5pbWF0aW9uRnJhbWVde0BsaW5rIGFuaW1hdGlvbkZyYW1lI3JlcXVlc3RBbmltYXRpb25GcmFtZX0uXG4gICAgICovXG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWU6IGNBRlxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBhbmltYXRpb25GcmFtZTtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFuaW1hdGlvbkZyYW1lID0gcmVxdWlyZSgnLi4vcG9seWZpbGxzL2FuaW1hdGlvbkZyYW1lJyk7XG52YXIgckFGID0gYW5pbWF0aW9uRnJhbWUucmVxdWVzdEFuaW1hdGlvbkZyYW1lO1xudmFyIGNBRiA9IGFuaW1hdGlvbkZyYW1lLmNhbmNlbEFuaW1hdGlvbkZyYW1lO1xuXG4vKipcbiAqIEJvb2xlYW4gY29uc3RhbnQgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wIGhhcyBhY2Nlc3NcbiAqIHRvIHRoZSBkb2N1bWVudC4gVGhlIGRvY3VtZW50IGlzIGJlaW5nIHVzZWQgaW4gb3JkZXIgdG8gc3Vic2NyaWJlIGZvclxuICogdmlzaWJpbGl0eWNoYW5nZSBldmVudHMgdXNlZCBmb3Igbm9ybWFsaXppbmcgdGhlIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3BcbiAqIHRpbWUgd2hlbiBlLmcuIHdoZW4gc3dpdGNoaW5nIHRhYnMuXG4gKlxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7Qm9vbGVhbn1cbiAqL1xudmFyIERPQ1VNRU5UX0FDQ0VTUyA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG5cbmlmIChET0NVTUVOVF9BQ0NFU1MpIHtcbiAgICB2YXIgVkVORE9SX0hJRERFTiwgVkVORE9SX1ZJU0lCSUxJVFlfQ0hBTkdFO1xuXG4gICAgLy8gT3BlcmEgMTIuMTAgYW5kIEZpcmVmb3ggMTggYW5kIGxhdGVyIHN1cHBvcnRcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgVkVORE9SX0hJRERFTiA9ICdoaWRkZW4nO1xuICAgICAgICBWRU5ET1JfVklTSUJJTElUWV9DSEFOR0UgPSAndmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudC5tb3pIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIFZFTkRPUl9ISURERU4gPSAnbW96SGlkZGVuJztcbiAgICAgICAgVkVORE9SX1ZJU0lCSUxJVFlfQ0hBTkdFID0gJ21venZpc2liaWxpdHljaGFuZ2UnO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZG9jdW1lbnQubXNIaWRkZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIFZFTkRPUl9ISURERU4gPSAnbXNIaWRkZW4nO1xuICAgICAgICBWRU5ET1JfVklTSUJJTElUWV9DSEFOR0UgPSAnbXN2aXNpYmlsaXR5Y2hhbmdlJztcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRvY3VtZW50LndlYmtpdEhpZGRlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgVkVORE9SX0hJRERFTiA9ICd3ZWJraXRIaWRkZW4nO1xuICAgICAgICBWRU5ET1JfVklTSUJJTElUWV9DSEFOR0UgPSAnd2Via2l0dmlzaWJpbGl0eWNoYW5nZSc7XG4gICAgfVxufVxuXG4vKipcbiAqIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AgY2xhc3MgdXNlZCBmb3IgdXBkYXRpbmcgb2JqZWN0cyBvbiBhIGZyYW1lLWJ5LWZyYW1lLlxuICogU3luY2hyb25pemVzIHRoZSBgdXBkYXRlYCBtZXRob2QgaW52b2NhdGlvbnMgdG8gdGhlIHJlZnJlc2ggcmF0ZSBvZiB0aGVcbiAqIHNjcmVlbi4gTWFuYWdlcyB0aGUgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAtbG9vcCBieSBub3JtYWxpemluZyB0aGUgcGFzc2VkIGluXG4gKiB0aW1lc3RhbXAgd2hlbiBzd2l0Y2hpbmcgdGFicy5cbiAqXG4gKiBAY2xhc3MgUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcFxuICovXG5mdW5jdGlvbiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wKCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBSZWZlcmVuY2VzIHRvIG9iamVjdHMgdG8gYmUgdXBkYXRlZCBvbiBuZXh0IGZyYW1lLlxuICAgIHRoaXMuX3VwZGF0ZXMgPSBbXTtcblxuICAgIHRoaXMuX2xvb3BlciA9IGZ1bmN0aW9uKHRpbWUpIHtcbiAgICAgICAgX3RoaXMubG9vcCh0aW1lKTtcbiAgICB9O1xuICAgIHRoaXMuX3RpbWUgPSAwO1xuICAgIHRoaXMuX3N0b3BwZWRBdCA9IDA7XG4gICAgdGhpcy5fc2xlZXAgPSAwO1xuXG4gICAgLy8gSW5kaWNhdGVzIHdoZXRoZXIgdGhlIGVuZ2luZSBzaG91bGQgYmUgcmVzdGFydGVkIHdoZW4gdGhlIHRhYi8gd2luZG93IGlzXG4gICAgLy8gYmVpbmcgZm9jdXNlZCBhZ2FpbiAodmlzaWJpbGl0eSBjaGFuZ2UpLlxuICAgIHRoaXMuX3N0YXJ0T25WaXNpYmlsaXR5Q2hhbmdlID0gdHJ1ZTtcblxuICAgIC8vIHJlcXVlc3RJZCBhcyByZXR1cm5lZCBieSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgZnVuY3Rpb247XG4gICAgdGhpcy5fckFGID0gbnVsbDtcblxuICAgIHRoaXMuX3NsZWVwRGlmZiA9IHRydWU7XG5cbiAgICAvLyBUaGUgZW5naW5lIGlzIGJlaW5nIHN0YXJ0ZWQgb24gaW5zdGFudGlhdGlvbi5cbiAgICAvLyBUT0RPKGFsZXhhbmRlckd1Z2VsKVxuICAgIHRoaXMuc3RhcnQoKTtcblxuICAgIC8vIFRoZSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wIHN1cHBvcnRzIHJ1bm5pbmcgaW4gYSBub24tYnJvd3NlclxuICAgIC8vIGVudmlyb25tZW50IChlLmcuIFdvcmtlcikuXG4gICAgaWYgKERPQ1VNRU5UX0FDQ0VTUykge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFZFTkRPUl9WSVNJQklMSVRZX0NIQU5HRSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBfdGhpcy5fb25WaXNpYmlsaXR5Q2hhbmdlKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgdGhlIHN3aXRjaGluZyBvZiB0YWJzLlxuICpcbiAqIEBtZXRob2RcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5wcm90b3R5cGUuX29uVmlzaWJpbGl0eUNoYW5nZSA9IGZ1bmN0aW9uIF9vblZpc2liaWxpdHlDaGFuZ2UoKSB7XG4gICAgaWYgKGRvY3VtZW50W1ZFTkRPUl9ISURERU5dKSB7XG4gICAgICAgIHRoaXMuX29uVW5mb2N1cygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5fb25Gb2N1cygpO1xuICAgIH1cbn07XG5cbi8qKlxuICogSW50ZXJuYWwgaGVscGVyIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgYXMgc29vbiBhcyB0aGUgd2luZG93LyB0YWIgaXMgYmVpbmdcbiAqIGZvY3VzZWQgYWZ0ZXIgYSB2aXNpYmlsdGl5IGNoYW5nZS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AucHJvdG90eXBlLl9vbkZvY3VzID0gZnVuY3Rpb24gX29uRm9jdXMoKSB7XG4gICAgaWYgKHRoaXMuX3N0YXJ0T25WaXNpYmlsaXR5Q2hhbmdlKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0KCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgZnVuY3Rpb24gdG8gYmUgaW52b2tlZCBhcyBzb29uIGFzIHRoZSB3aW5kb3cvIHRhYiBpcyBiZWluZ1xuICogdW5mb2N1c2VkIChoaWRkZW4pIGFmdGVyIGEgdmlzaWJpbHRpeSBjaGFuZ2UuXG4gKlxuICogQG1ldGhvZCAgX29uRm9jdXNcbiAqIEBwcml2YXRlXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5wcm90b3R5cGUuX29uVW5mb2N1cyA9IGZ1bmN0aW9uIF9vblVuZm9jdXMoKSB7XG4gICAgdGhpcy5fc3RvcCgpO1xufTtcblxuLyoqXG4gKiBTdGFydHMgdGhlIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AuIFdoZW4gc3dpdGNoaW5nIHRvIGEgZGlmZmVybnQgdGFiL1xuICogd2luZG93IChjaGFuZ2luZyB0aGUgdmlzaWJpbHRpeSksIHRoZSBlbmdpbmUgd2lsbCBiZSByZXRhcnRlZCB3aGVuIHN3aXRjaGluZ1xuICogYmFjayB0byBhIHZpc2libGUgc3RhdGUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3RBbmltYXRpb25GcmFtZUxvb3B9IHRoaXNcbiAqL1xuUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiBzdGFydCgpIHtcbiAgICBpZiAoIXRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRPblZpc2liaWxpdHlDaGFuZ2UgPSB0cnVlO1xuICAgICAgICB0aGlzLl9zdGFydCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgdmVyc2lvbiBvZiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wJ3Mgc3RhcnQgZnVuY3Rpb24sIG5vdCBhZmZlY3RpbmdcbiAqIGJlaGF2aW9yIG9uIHZpc2liaWx0eSBjaGFuZ2UuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbipcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uIF9zdGFydCgpIHtcbiAgICB0aGlzLl9ydW5uaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl9zbGVlcERpZmYgPSB0cnVlO1xuICAgIHRoaXMuX3JBRiA9IHJBRih0aGlzLl9sb29wZXIpO1xufTtcblxuLyoqXG4gKiBTdG9wcyB0aGUgUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3RBbmltYXRpb25GcmFtZUxvb3B9IHRoaXNcbiAqL1xuUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIHN0b3AoKSB7XG4gICAgaWYgKHRoaXMuX3J1bm5pbmcpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRPblZpc2liaWxpdHlDaGFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fc3RvcCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW50ZXJuYWwgdmVyc2lvbiBvZiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wJ3Mgc3RvcCBmdW5jdGlvbiwgbm90IGFmZmVjdGluZ1xuICogYmVoYXZpb3Igb24gdmlzaWJpbHR5IGNoYW5nZS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cblJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AucHJvdG90eXBlLl9zdG9wID0gZnVuY3Rpb24gX3N0b3AoKSB7XG4gICAgdGhpcy5fcnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3BwZWRBdCA9IHRoaXMuX3RpbWU7XG5cbiAgICAvLyBCdWcgaW4gb2xkIHZlcnNpb25zIG9mIEZ4LiBFeHBsaWNpdGx5IGNhbmNlbC5cbiAgICBjQUYodGhpcy5fckFGKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wIGlzIGN1cnJlbnRseSBydW5uaW5nIG9yIG5vdC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7Qm9vbGVhbn0gYm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIHdoZXRoZXIgdGhlXG4gKiBSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wIGlzIGN1cnJlbnRseSBydW5uaW5nIG9yIG5vdFxuICovXG5SZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wLnByb3RvdHlwZS5pc1J1bm5pbmcgPSBmdW5jdGlvbiBpc1J1bm5pbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3J1bm5pbmc7XG59O1xuXG4vKipcbiAqIFVwZGF0ZXMgYWxsIHJlZ2lzdGVyZWQgb2JqZWN0cy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHRpbWUgaGlnaCByZXNvbHV0aW9uIHRpbXN0YW1wIHVzZWQgZm9yIGludm9raW5nIHRoZSBgdXBkYXRlYFxuICogbWV0aG9kIG9uIGFsbCByZWdpc3RlcmVkIG9iamVjdHNcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wfSB0aGlzXG4gKi9cblJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AucHJvdG90eXBlLnN0ZXAgPSBmdW5jdGlvbiBzdGVwICh0aW1lKSB7XG4gICAgdGhpcy5fdGltZSA9IHRpbWU7XG4gICAgaWYgKHRoaXMuX3NsZWVwRGlmZikge1xuICAgICAgICB0aGlzLl9zbGVlcCArPSB0aW1lIC0gdGhpcy5fc3RvcHBlZEF0O1xuICAgICAgICB0aGlzLl9zbGVlcERpZmYgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUaGUgc2FtZSB0aW1ldGFtcCB3aWxsIGJlIGVtaXR0ZWQgaW1tZWRpYXRlbHkgYmVmb3JlIGFuZCBhZnRlciB2aXNpYmlsaXR5XG4gICAgLy8gY2hhbmdlLlxuICAgIHZhciBub3JtYWxpemVkVGltZSA9IHRpbWUgLSB0aGlzLl9zbGVlcDtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fdXBkYXRlcy5sZW5ndGggOyBpIDwgbGVuIDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXNbaV0udXBkYXRlKG5vcm1hbGl6ZWRUaW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIE1ldGhvZCBiZWluZyBjYWxsZWQgYnkgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAgb24gZXZlcnkgcGFpbnQuIEluZGlyZWN0bHlcbiAqIHJlY3Vyc2l2ZSBieSBzY2hlZHVsaW5nIGEgZnV0dXJlIGludm9jYXRpb24gb2YgaXRzZWxmIG9uIHRoZSBuZXh0IHBhaW50LlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZSBoaWdoIHJlc29sdXRpb24gdGltc3RhbXAgdXNlZCBmb3IgaW52b2tpbmcgdGhlIGB1cGRhdGVgXG4gKiBtZXRob2Qgb24gYWxsIHJlZ2lzdGVyZWQgb2JqZWN0c1xuICogQHJldHVybiB7UmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcH0gdGhpc1xuICovXG5SZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wLnByb3RvdHlwZS5sb29wID0gZnVuY3Rpb24gbG9vcCh0aW1lKSB7XG4gICAgdGhpcy5zdGVwKHRpbWUpO1xuICAgIHRoaXMuX3JBRiA9IHJBRih0aGlzLl9sb29wZXIpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBSZWdpc3RlcmVzIGFuIHVwZGF0ZWFibGUgb2JqZWN0IHdoaWNoIGB1cGRhdGVgIG1ldGhvZCBzaG91bGQgYmUgaW52b2tlZCBvblxuICogZXZlcnkgcGFpbnQsIHN0YXJ0aW5nIG9uIHRoZSBuZXh0IHBhaW50IChhc3N1bWluZyB0aGVcbiAqIFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AgaXMgcnVubmluZykuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB1cGRhdGVhYmxlIG9iamVjdCB0byBiZSB1cGRhdGVkXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB1cGRhdGVhYmxlLnVwZGF0ZSB1cGRhdGUgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIG9uIHRoZVxuICogcmVnaXN0ZXJlZCBvYmplY3RcbiAqXG4gKiBAcmV0dXJuIHtSZXF1ZXN0QW5pbWF0aW9uRnJhbWVMb29wfSB0aGlzXG4gKi9cblJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3AucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZSh1cGRhdGVhYmxlKSB7XG4gICAgaWYgKHRoaXMuX3VwZGF0ZXMuaW5kZXhPZih1cGRhdGVhYmxlKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlcy5wdXNoKHVwZGF0ZWFibGUpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRGVyZWdpc3RlcnMgYW4gdXBkYXRlYWJsZSBvYmplY3QgcHJldmlvdXNseSByZWdpc3RlcmVkIHVzaW5nIGB1cGRhdGVgIHRvIGJlXG4gKiBubyBsb25nZXIgdXBkYXRlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHVwZGF0ZWFibGUgdXBkYXRlYWJsZSBvYmplY3QgcHJldmlvdXNseSByZWdpc3RlcmVkIHVzaW5nXG4gKiBgdXBkYXRlYFxuICpcbiAqIEByZXR1cm4ge1JlcXVlc3RBbmltYXRpb25GcmFtZUxvb3B9IHRoaXNcbiAqL1xuUmVxdWVzdEFuaW1hdGlvbkZyYW1lTG9vcC5wcm90b3R5cGUubm9Mb25nZXJVcGRhdGUgPSBmdW5jdGlvbiBub0xvbmdlclVwZGF0ZSh1cGRhdGVhYmxlKSB7XG4gICAgdmFyIGluZGV4ID0gdGhpcy5fdXBkYXRlcy5pbmRleE9mKHVwZGF0ZWFibGUpO1xuICAgIGlmIChpbmRleCA+IC0xKSB7XG4gICAgICAgIHRoaXMuX3VwZGF0ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlcXVlc3RBbmltYXRpb25GcmFtZUxvb3A7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb250ZXh0ID0gcmVxdWlyZSgnLi9Db250ZXh0Jyk7XG52YXIgaW5qZWN0Q1NTID0gcmVxdWlyZSgnLi9pbmplY3QtY3NzJyk7XG52YXIgQ29tbWFuZHMgPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1hbmRzJyk7XG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGEgbmV3IENvbXBvc2l0b3IuXG4gKiBUaGUgQ29tcG9zaXRvciByZWNlaXZlcyBkcmF3IGNvbW1hbmRzIGZybSB0aGUgVUlNYW5hZ2VyIGFuZCByb3V0ZXMgdGhlIHRvIHRoZVxuICogcmVzcGVjdGl2ZSBjb250ZXh0IG9iamVjdHMuXG4gKlxuICogVXBvbiBjcmVhdGlvbiwgaXQgaW5qZWN0cyBhIHN0eWxlc2hlZXQgdXNlZCBmb3Igc3R5bGluZyB0aGUgaW5kaXZpZHVhbFxuICogcmVuZGVyZXJzIHVzZWQgaW4gdGhlIGNvbnRleHQgb2JqZWN0cy5cbiAqXG4gKiBAY2xhc3MgQ29tcG9zaXRvclxuICogQGNvbnN0cnVjdG9yXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5mdW5jdGlvbiBDb21wb3NpdG9yKCkge1xuICAgIGluamVjdENTUygpO1xuXG4gICAgdGhpcy5fY29udGV4dHMgPSB7fTtcbiAgICB0aGlzLl9vdXRDb21tYW5kcyA9IFtdO1xuICAgIHRoaXMuX2luQ29tbWFuZHMgPSBbXTtcbiAgICB0aGlzLl90aW1lID0gbnVsbDtcblxuICAgIHRoaXMuX3Jlc2l6ZWQgPSBmYWxzZTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBfdGhpcy5vblJlc2l6ZSgpO1xuICAgIH0pO1xufVxuXG5Db21wb3NpdG9yLnByb3RvdHlwZS5vblJlc2l6ZSA9IGZ1bmN0aW9uIG9uUmVzaXplICgpIHtcbiAgICB0aGlzLl9yZXNpemVkID0gdHJ1ZTtcbiAgICBmb3IgKHZhciBzZWxlY3RvciBpbiB0aGlzLl9jb250ZXh0cykge1xuICAgICAgICB0aGlzLl9jb250ZXh0c1tzZWxlY3Rvcl0udXBkYXRlU2l6ZSgpO1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB0aW1lIGJlaW5nIHVzZWQgYnkgdGhlIGludGVybmFsIGNsb2NrIG1hbmFnZWQgYnlcbiAqIGBGYW1vdXNFbmdpbmVgLlxuICpcbiAqIFRoZSB0aW1lIGlzIGJlaW5nIHBhc3NlZCBpbnRvIGNvcmUgYnkgdGhlIEVuZ2luZSB0aHJvdWdoIHRoZSBVSU1hbmFnZXIuXG4gKiBTaW5jZSBjb3JlIGhhcyB0aGUgYWJpbGl0eSB0byBzY2FsZSB0aGUgdGltZSwgdGhlIHRpbWUgbmVlZHMgdG8gYmUgcGFzc2VkXG4gKiBiYWNrIHRvIHRoZSByZW5kZXJpbmcgc3lzdGVtLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IHRpbWUgVGhlIGNsb2NrIHRpbWUgdXNlZCBpbiBjb3JlLlxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5nZXRUaW1lID0gZnVuY3Rpb24gZ2V0VGltZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdGltZTtcbn07XG5cbi8qKlxuICogU2NoZWR1bGVzIGFuIGV2ZW50IHRvIGJlIHNlbnQgdGhlIG5leHQgdGltZSB0aGUgb3V0IGNvbW1hbmQgcXVldWUgaXMgYmVpbmdcbiAqIGZsdXNoZWQuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHBhdGggUmVuZGVyIHBhdGggdG8gdGhlIG5vZGUgdGhlIGV2ZW50IHNob3VsZCBiZSB0cmlnZ2VyZWRcbiAqIG9uICgqdGFyZ2V0ZWQgZXZlbnQqKVxuICogQHBhcmFtICB7U3RyaW5nfSBldiBFdmVudCB0eXBlXG4gKiBAcGFyYW0gIHtPYmplY3R9IHBheWxvYWQgRXZlbnQgb2JqZWN0IChzZXJpYWxpemFibGUgdXNpbmcgc3RydWN0dXJlZCBjbG9uaW5nXG4gKiBhbGdvcml0aG0pXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuc2VuZEV2ZW50ID0gZnVuY3Rpb24gc2VuZEV2ZW50KHBhdGgsIGV2LCBwYXlsb2FkKSB7XG4gICAgdGhpcy5fb3V0Q29tbWFuZHMucHVzaChDb21tYW5kcy5XSVRILCBwYXRoLCBDb21tYW5kcy5UUklHR0VSLCBldiwgcGF5bG9hZCk7XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBtZXRob2QgdXNlZCBmb3Igbm90aWZ5aW5nIGV4dGVybmFsbHlcbiAqIHJlc2l6ZWQgY29udGV4dHMgKGUuZy4gYnkgcmVzaXppbmcgdGhlIGJyb3dzZXIgd2luZG93KS5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gc2VsZWN0b3IgcmVuZGVyIHBhdGggdG8gdGhlIG5vZGUgKGNvbnRleHQpIHRoYXQgc2hvdWxkIGJlXG4gKiByZXNpemVkXG4gKiBAcGFyYW0gIHtBcnJheX0gc2l6ZSBuZXcgY29udGV4dCBzaXplXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuc2VuZFJlc2l6ZSA9IGZ1bmN0aW9uIHNlbmRSZXNpemUgKHNlbGVjdG9yLCBzaXplKSB7XG4gICAgdGhpcy5zZW5kRXZlbnQoc2VsZWN0b3IsICdDT05URVhUX1JFU0laRScsIHNpemUpO1xufTtcblxuLyoqXG4gKiBJbnRlcm5hbCBoZWxwZXIgbWV0aG9kIHVzZWQgYnkgYGRyYXdDb21tYW5kc2AuXG4gKiBTdWJzZXF1ZW50IGNvbW1hbmRzIGFyZSBiZWluZyBhc3NvY2lhdGVkIHdpdGggdGhlIG5vZGUgZGVmaW5lZCB0aGUgdGhlIHBhdGhcbiAqIGZvbGxvd2luZyB0aGUgYFdJVEhgIGNvbW1hbmQuXG4gKlxuICogQG1ldGhvZFxuICogQHByaXZhdGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ9IGl0ZXJhdG9yIHBvc2l0aW9uIGluZGV4IHdpdGhpbiB0aGUgY29tbWFuZHMgcXVldWVcbiAqIEBwYXJhbSAge0FycmF5fSBjb21tYW5kcyByZW1haW5pbmcgbWVzc2FnZSBxdWV1ZSByZWNlaXZlZCwgdXNlZCB0b1xuICogc2hpZnQgc2luZ2xlIG1lc3NhZ2VzIGZyb21cbiAqXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9IHVuZGVmaW5lZFxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5oYW5kbGVXaXRoID0gZnVuY3Rpb24gaGFuZGxlV2l0aCAoaXRlcmF0b3IsIGNvbW1hbmRzKSB7XG4gICAgdmFyIHBhdGggPSBjb21tYW5kc1tpdGVyYXRvcl07XG4gICAgdmFyIHBhdGhBcnIgPSBwYXRoLnNwbGl0KCcvJyk7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLmdldE9yU2V0Q29udGV4dChwYXRoQXJyLnNoaWZ0KCkpO1xuICAgIHJldHVybiBjb250ZXh0LnJlY2VpdmUocGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKTtcbn07XG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSB0b3AtbGV2ZWwgQ29udGV4dCBhc3NvY2lhdGVkIHdpdGggdGhlIHBhc3NlZCBpbiBkb2N1bWVudFxuICogcXVlcnkgc2VsZWN0b3IuIElmIG5vIHN1Y2ggQ29udGV4dCBleGlzdHMsIGEgbmV3IG9uZSB3aWxsIGJlIGluc3RhbnRpYXRlZC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzZWxlY3RvciBkb2N1bWVudCBxdWVyeSBzZWxlY3RvciB1c2VkIGZvciByZXRyaWV2aW5nIHRoZVxuICogRE9NIG5vZGUgdGhhdCBzaG91bGQgYmUgdXNlZCBhcyBhIHJvb3QgZWxlbWVudCBieSB0aGUgQ29udGV4dFxuICpcbiAqIEByZXR1cm4ge0NvbnRleHR9IGNvbnRleHRcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuZ2V0T3JTZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0T3JTZXRDb250ZXh0KHNlbGVjdG9yKSB7XG4gICAgaWYgKHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dHNbc2VsZWN0b3JdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dChzZWxlY3RvciwgdGhpcyk7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXSA9IGNvbnRleHQ7XG4gICAgICAgIHJldHVybiBjb250ZXh0O1xuICAgIH1cbn07XG5cbi8qKlxuICogUmV0cmlldmVzIGEgY29udGV4dCBvYmplY3QgcmVnaXN0ZXJlZCB1bmRlciB0aGUgcGFzc2VkIGluIHNlbGVjdG9yLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9IHNlbGVjdG9yICAgIFF1ZXJ5IHNlbGVjdG9yIHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiB1c2VkIHRvXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZ2lzdGVyIHRoZSBjb250ZXh0LlxuICogQHJldHVybiB7Q29udGV4dH0gICAgICAgICAgICBUaGUgcmVwc2VjdGl2ZSBjb250ZXh0LlxuICovXG5Db21wb3NpdG9yLnByb3RvdHlwZS5nZXRDb250ZXh0ID0gZnVuY3Rpb24gZ2V0Q29udGV4dChzZWxlY3Rvcikge1xuICAgIGlmICh0aGlzLl9jb250ZXh0c1tzZWxlY3Rvcl0pXG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0c1tzZWxlY3Rvcl07XG59O1xuXG4vKipcbiAqIFByb2Nlc3NlcyB0aGUgcHJldmlvdXNseSB2aWEgYHJlY2VpdmVDb21tYW5kc2AgdXBkYXRlZCBpbmNvbWluZyBcImluXCJcbiAqIGNvbW1hbmQgcXVldWUuXG4gKiBDYWxsZWQgYnkgVUlNYW5hZ2VyIG9uIGEgZnJhbWUgYnkgZnJhbWUgYmFzaXMuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0FycmF5fSBvdXRDb21tYW5kcyBzZXQgb2YgY29tbWFuZHMgdG8gYmUgc2VudCBiYWNrXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLmRyYXdDb21tYW5kcyA9IGZ1bmN0aW9uIGRyYXdDb21tYW5kcygpIHtcbiAgICB2YXIgY29tbWFuZHMgPSB0aGlzLl9pbkNvbW1hbmRzO1xuICAgIHZhciBsb2NhbEl0ZXJhdG9yID0gMDtcbiAgICB2YXIgY29tbWFuZCA9IGNvbW1hbmRzW2xvY2FsSXRlcmF0b3JdO1xuICAgIHdoaWxlIChjb21tYW5kKSB7XG4gICAgICAgIHN3aXRjaCAoY29tbWFuZCkge1xuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5USU1FOlxuICAgICAgICAgICAgICAgIHRoaXMuX3RpbWUgPSBjb21tYW5kc1srK2xvY2FsSXRlcmF0b3JdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5XSVRIOlxuICAgICAgICAgICAgICAgIGxvY2FsSXRlcmF0b3IgPSB0aGlzLmhhbmRsZVdpdGgoKytsb2NhbEl0ZXJhdG9yLCBjb21tYW5kcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENvbW1hbmRzLk5FRURfU0laRV9GT1I6XG4gICAgICAgICAgICAgICAgdGhpcy5naXZlU2l6ZUZvcigrK2xvY2FsSXRlcmF0b3IsIGNvbW1hbmRzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjb21tYW5kID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiBTd2l0Y2ggdG8gYXNzb2NpYXRpdmUgYXJyYXlzIGhlcmUuLi5cblxuICAgIGZvciAodmFyIGtleSBpbiB0aGlzLl9jb250ZXh0cykge1xuICAgICAgICB0aGlzLl9jb250ZXh0c1trZXldLmRyYXcoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fcmVzaXplZCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fb3V0Q29tbWFuZHM7XG59O1xuXG5cbi8qKlxuICogVXBkYXRlcyB0aGUgc2l6ZSBvZiBhbGwgcHJldmlvdXNseSByZWdpc3RlcmVkIGNvbnRleHQgb2JqZWN0cy5cbiAqIFRoaXMgcmVzdWx0cyBpbnRvIENPTlRFWFRfUkVTSVpFIGV2ZW50cyBiZWluZyBzZW50IGFuZCB0aGUgcm9vdCBlbGVtZW50c1xuICogdXNlZCBieSB0aGUgaW5kaXZpZHVhbCByZW5kZXJlcnMgYmVpbmcgcmVzaXplZCB0byB0aGUgdGhlIERPTVJlbmRlcmVyJ3Mgcm9vdFxuICogc2l6ZS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUudXBkYXRlU2l6ZSA9IGZ1bmN0aW9uIHVwZGF0ZVNpemUoKSB7XG4gICAgZm9yICh2YXIgc2VsZWN0b3IgaW4gdGhpcy5fY29udGV4dHMpIHtcbiAgICAgICAgdGhpcy5fY29udGV4dHNbc2VsZWN0b3JdLnVwZGF0ZVNpemUoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFVzZWQgYnkgVGhyZWFkTWFuYWdlciB0byB1cGRhdGUgdGhlIGludGVybmFsIHF1ZXVlIG9mIGluY29taW5nIGNvbW1hbmRzLlxuICogUmVjZWl2aW5nIGNvbW1hbmRzIGRvZXMgbm90IGltbWVkaWF0ZWx5IHN0YXJ0IHRoZSByZW5kZXJpbmcgcHJvY2Vzcy5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtICB7QXJyYXl9IGNvbW1hbmRzIGNvbW1hbmQgcXVldWUgdG8gYmUgcHJvY2Vzc2VkIGJ5IHRoZSBjb21wb3NpdG9yJ3NcbiAqIGBkcmF3Q29tbWFuZHNgIG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLnJlY2VpdmVDb21tYW5kcyA9IGZ1bmN0aW9uIHJlY2VpdmVDb21tYW5kcyhjb21tYW5kcykge1xuICAgIHZhciBsZW4gPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLl9pbkNvbW1hbmRzLnB1c2goY29tbWFuZHNbaV0pO1xuICAgIH1cblxuICAgIGZvciAodmFyIHNlbGVjdG9yIGluIHRoaXMuX2NvbnRleHRzKSB7XG4gICAgICAgIHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXS5jaGVja0luaXQoKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBtZXRob2QgdXNlZCBieSBgZHJhd0NvbW1hbmRzYC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEBwYXJhbSAge051bWJlcn0gaXRlcmF0b3IgcG9zaXRpb24gaW5kZXggd2l0aGluIHRoZSBjb21tYW5kIHF1ZXVlXG4gKiBAcGFyYW0gIHtBcnJheX0gY29tbWFuZHMgcmVtYWluaW5nIG1lc3NhZ2UgcXVldWUgcmVjZWl2ZWQsIHVzZWQgdG9cbiAqIHNoaWZ0IHNpbmdsZSBtZXNzYWdlc1xuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNvbXBvc2l0b3IucHJvdG90eXBlLmdpdmVTaXplRm9yID0gZnVuY3Rpb24gZ2l2ZVNpemVGb3IoaXRlcmF0b3IsIGNvbW1hbmRzKSB7XG4gICAgdmFyIHNlbGVjdG9yID0gY29tbWFuZHNbaXRlcmF0b3JdO1xuICAgIHZhciBjb250ZXh0ID0gdGhpcy5nZXRDb250ZXh0KHNlbGVjdG9yKTtcbiAgICBpZiAoY29udGV4dCkge1xuICAgICAgICB2YXIgc2l6ZSA9IGNvbnRleHQuZ2V0Um9vdFNpemUoKTtcbiAgICAgICAgdGhpcy5zZW5kUmVzaXplKHNlbGVjdG9yLCBzaXplKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZ2V0T3JTZXRDb250ZXh0KHNlbGVjdG9yKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEZsdXNoZXMgdGhlIHF1ZXVlIG9mIG91dGdvaW5nIFwib3V0XCIgY29tbWFuZHMuXG4gKiBDYWxsZWQgYnkgVGhyZWFkTWFuYWdlci5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUuY2xlYXJDb21tYW5kcyA9IGZ1bmN0aW9uIGNsZWFyQ29tbWFuZHMoKSB7XG4gICAgdGhpcy5faW5Db21tYW5kcy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX291dENvbW1hbmRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcmVzaXplZCA9IGZhbHNlO1xufTtcblxuIC8qKlxuICogUmVtb3ZlcyB0aGUgY29udGV4dCBmcm9tIHRoZSBpbnRlcm5hbCByZWdpc3RyeS5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtICB7U3RyaW5nfSBzZWxlY3RvciAgICBTZWxlY3RvciB1c2VkIGZvciBhY2Nlc3NpbmcgdGhlIHJlZ2lzZXJlZFxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0LlxuICogQHJldHVybiB7dW5kZWZpbmVkfSAgICAgICAgICB1bmRlZmluZWRcbiAqL1xuQ29tcG9zaXRvci5wcm90b3R5cGUucmVtb3ZlQ29udGV4dCA9IGZ1bmN0aW9uIHJlbW92ZUNvbnRleHQgKHNlbGVjdG9yKSB7XG4gICAgdmFyIGNvbnRleHQgPSB0aGlzLl9jb250ZXh0c1tzZWxlY3Rvcl07XG4gICAgZGVsZXRlIHRoaXMuX2NvbnRleHRzW3NlbGVjdG9yXTtcbiAgICBjb250ZXh0LmNsZWFudXAoKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29tcG9zaXRvcjtcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbWVyYSA9IHJlcXVpcmUoJy4uL2NvbXBvbmVudHMvQ2FtZXJhJyk7XG52YXIgRE9NUmVuZGVyZXIgPSByZXF1aXJlKCcuLi9kb20tcmVuZGVyZXJzL0RPTVJlbmRlcmVyJyk7XG52YXIgQ29tbWFuZHMgPSByZXF1aXJlKCcuLi9jb3JlL0NvbW1hbmRzJyk7XG5cbi8qKlxuICogQ29udGV4dCBpcyBhIHJlbmRlciBsYXllciB3aXRoIGl0cyBvd24gV2ViR0xSZW5kZXJlciBhbmQgRE9NUmVuZGVyZXIuXG4gKiBJdCBpcyB0aGUgaW50ZXJmYWNlIGJldHdlZW4gdGhlIENvbXBvc2l0b3Igd2hpY2ggcmVjZWl2ZXMgY29tbWFuZHNcbiAqIGFuZCB0aGUgcmVuZGVyZXJzIHRoYXQgaW50ZXJwcmV0IHRoZW0uIEl0IGFsc28gcmVsYXlzIGluZm9ybWF0aW9uIHRvXG4gKiB0aGUgcmVuZGVyZXJzIGFib3V0IHJlc2l6aW5nLlxuICpcbiAqIFRoZSBET01FbGVtZW50IGF0IHRoZSBnaXZlbiBxdWVyeSBzZWxlY3RvciBpcyB1c2VkIGFzIHRoZSByb290LiBBXG4gKiBuZXcgRE9NRWxlbWVudCBpcyBhcHBlbmRlZCB0byB0aGlzIHJvb3QgZWxlbWVudCwgYW5kIHVzZWQgYXMgdGhlXG4gKiBwYXJlbnQgZWxlbWVudCBmb3IgYWxsIEZhbW91cyBET00gcmVuZGVyaW5nIGF0IHRoaXMgY29udGV4dC4gQVxuICogY2FudmFzIGlzIGFkZGVkIGFuZCB1c2VkIGZvciBhbGwgV2ViR0wgcmVuZGVyaW5nIGF0IHRoaXMgY29udGV4dC5cbiAqXG4gKiBAY2xhc3MgQ29udGV4dFxuICogQGNvbnN0cnVjdG9yXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yIFF1ZXJ5IHNlbGVjdG9yIHVzZWQgdG8gbG9jYXRlIHJvb3QgZWxlbWVudCBvZlxuICogY29udGV4dCBsYXllci5cbiAqIEBwYXJhbSB7Q29tcG9zaXRvcn0gY29tcG9zaXRvciBDb21wb3NpdG9yIHJlZmVyZW5jZSB0byBwYXNzIGRvd24gdG9cbiAqIFdlYkdMUmVuZGVyZXIuXG4gKi9cbmZ1bmN0aW9uIENvbnRleHQoc2VsZWN0b3IsIGNvbXBvc2l0b3IpIHtcbiAgICB0aGlzLl9jb21wb3NpdG9yID0gY29tcG9zaXRvcjtcbiAgICB0aGlzLl9yb290RWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKTtcbiAgICB0aGlzLl9zZWxlY3RvciA9IHNlbGVjdG9yO1xuXG4gICAgaWYgKHRoaXMuX3Jvb3RFbCA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnRmFpbGVkIHRvIGNyZWF0ZSBDb250ZXh0OiAnICtcbiAgICAgICAgICAgICdObyBtYXRjaGVzIGZvciBcIicgKyBzZWxlY3RvciArICdcIiBmb3VuZC4nXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuICAgIC8vIEluaXRpYWxpemVzIHRoZSBET01SZW5kZXJlci5cbiAgICAvLyBFdmVyeSBDb250ZXh0IGhhcyBhdCBsZWFzdCBhIERPTVJlbmRlcmVyIGZvciBub3cuXG4gICAgdGhpcy5faW5pdERPTVJlbmRlcmVyKCk7XG4gICAgdGhpcy5fY2FudmFzRWwgPSBudWxsO1xuXG4gICAgLy8gU3RhdGUgaG9sZGVyc1xuXG4gICAgdGhpcy5fcmVuZGVyU3RhdGUgPSB7XG4gICAgICAgIHByb2plY3Rpb25UeXBlOiBDYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT04sXG4gICAgICAgIHBlcnNwZWN0aXZlVHJhbnNmb3JtOiBuZXcgRmxvYXQzMkFycmF5KFsxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxXSksXG4gICAgICAgIHZpZXdUcmFuc2Zvcm06IG5ldyBGbG9hdDMyQXJyYXkoWzEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDFdKSxcbiAgICAgICAgdmlld0RpcnR5OiBmYWxzZSxcbiAgICAgICAgcGVyc3BlY3RpdmVEaXJ0eTogZmFsc2VcbiAgICB9O1xuXG4gICAgdGhpcy5fc2l6ZSA9IFtdO1xuXG4gICAgdGhpcy5faW5pdERPTSA9IGZhbHNlO1xuICAgIHRoaXMuX2N1cnJlbnRUcmFuc2Zvcm0gPSBuZXcgRmxvYXQzMkFycmF5KDE2KTtcblxuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3MgPSBbXTtcbiAgICB0aGlzLmluaXRDb21tYW5kQ2FsbGJhY2tzKCk7XG5cbiAgICB0aGlzLnVwZGF0ZVNpemUoKTtcbn1cblxuLyoqXG4gKiBRdWVyaWVzIERPTVJlbmRlcmVyIHNpemUgYW5kIHVwZGF0ZXMgY2FudmFzIHNpemUuIFJlbGF5cyBzaXplIGluZm9ybWF0aW9uIHRvXG4gKiBXZWJHTFJlbmRlcmVyLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtDb250ZXh0fSB0aGlzXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLnVwZGF0ZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5fcm9vdEVsLm9mZnNldFdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLl9yb290RWwub2Zmc2V0SGVpZ2h0O1xuXG4gICAgdGhpcy5fc2l6ZVswXSA9IHdpZHRoO1xuICAgIHRoaXMuX3NpemVbMV0gPSBoZWlnaHQ7XG4gICAgdGhpcy5fc2l6ZVsyXSA9ICh3aWR0aCA+IGhlaWdodCkgPyB3aWR0aCA6IGhlaWdodDtcblxuICAgIHRoaXMuX2NvbXBvc2l0b3Iuc2VuZFJlc2l6ZSh0aGlzLl9zZWxlY3RvciwgdGhpcy5fc2l6ZSk7XG5cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogRHJhdyBmdW5jdGlvbiBjYWxsZWQgYWZ0ZXIgYWxsIGNvbW1hbmRzIGhhdmUgYmVlbiBoYW5kbGVkIGZvciBjdXJyZW50IGZyYW1lLlxuICogSXNzdWVzIGRyYXcgY29tbWFuZHMgdG8gYWxsIHJlbmRlcmVycyB3aXRoIGN1cnJlbnQgcmVuZGVyU3RhdGUuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLmRyYXcgPSBmdW5jdGlvbiBkcmF3KCkge1xuICAgIHRoaXMuX2RvbVJlbmRlcmVyLmRyYXcodGhpcy5fcmVuZGVyU3RhdGUpO1xuXG4gICAgaWYgKHRoaXMuX3JlbmRlclN0YXRlLnBlcnNwZWN0aXZlRGlydHkpIHRoaXMuX3JlbmRlclN0YXRlLnBlcnNwZWN0aXZlRGlydHkgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fcmVuZGVyU3RhdGUudmlld0RpcnR5KSB0aGlzLl9yZW5kZXJTdGF0ZS52aWV3RGlydHkgPSBmYWxzZTtcbn07XG5cbi8qKlxuICogSW5pdGlhbGl6ZXMgdGhlIERPTVJlbmRlcmVyIGJ5IGNyZWF0aW5nIGEgcm9vdCBESVYgZWxlbWVudCBhbmQgYXBwZW5kaW5nIGl0XG4gKiB0byB0aGUgY29udGV4dC5cbiAqXG4gKiBAbWV0aG9kXG4gKiBAcHJpdmF0ZVxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLl9pbml0RE9NUmVuZGVyZXIgPSBmdW5jdGlvbiBfaW5pdERPTVJlbmRlcmVyKCkge1xuICAgIHRoaXMuX2RvbVJlbmRlcmVyUm9vdEVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGhpcy5fcm9vdEVsLmFwcGVuZENoaWxkKHRoaXMuX2RvbVJlbmRlcmVyUm9vdEVsKTtcbiAgICB0aGlzLl9kb21SZW5kZXJlclJvb3RFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cbiAgICB0aGlzLl9kb21SZW5kZXJlciA9IG5ldyBET01SZW5kZXJlcihcbiAgICAgICAgdGhpcy5fZG9tUmVuZGVyZXJSb290RWwsXG4gICAgICAgIHRoaXMuX3NlbGVjdG9yLFxuICAgICAgICB0aGlzLl9jb21wb3NpdG9yXG4gICAgKTtcbn07XG5cbkNvbnRleHQucHJvdG90eXBlLmluaXRDb21tYW5kQ2FsbGJhY2tzID0gZnVuY3Rpb24gaW5pdENvbW1hbmRDYWxsYmFja3MgKCkge1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuSU5JVF9ET01dID0gaW5pdERPTTtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLkRPTV9SRU5ERVJfU0laRV0gPSBkb21SZW5kZXJTaXplO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuQ0hBTkdFX1RSQU5TRk9STV0gPSBjaGFuZ2VUcmFuc2Zvcm07XG4gICAgdGhpcy5fY29tbWFuZENhbGxiYWNrc1tDb21tYW5kcy5DSEFOR0VfU0laRV0gPSBjaGFuZ2VTaXplO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuQ0hBTkdFX1NUWUxFXSA9IGNoYW5nZVByb3BlcnR5O1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuQ0hBTkdFX0NPTlRFTlRdID0gY2hhbmdlQ29udGVudDtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLkNIQU5HRV9BVFRSSUJVVEVdID0gY2hhbmdlQXR0cmlidXRlO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuQUREX0NMQVNTXSA9IGFkZENsYXNzO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuUkVNT1ZFX0NMQVNTXSA9IHJlbW92ZUNsYXNzO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuU1VCU0NSSUJFXSA9IHN1YnNjcmliZTtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLlVOU1VCU0NSSUJFXSA9IHVuc3Vic2NyaWJlO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuUElOSE9MRV9QUk9KRUNUSU9OXSA9IHBpbmhvbGVQcm9qZWN0aW9uO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuT1JUSE9HUkFQSElDX1BST0pFQ1RJT05dID0gb3J0aG9ncmFwaGljUHJvamVjdGlvbjtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLkNIQU5HRV9WSUVXX1RSQU5TRk9STV0gPSBjaGFuZ2VWaWV3VHJhbnNmb3JtO1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuUFJFVkVOVF9ERUZBVUxUXSA9IHByZXZlbnREZWZhdWx0O1xuICAgIHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbQ29tbWFuZHMuQUxMT1dfREVGQVVMVF0gPSBhbGxvd0RlZmF1bHQ7XG4gICAgdGhpcy5fY29tbWFuZENhbGxiYWNrc1tDb21tYW5kcy5SRUFEWV0gPSByZWFkeTtcbiAgICB0aGlzLl9jb21tYW5kQ2FsbGJhY2tzW0NvbW1hbmRzLlJFTU9WRV9TQ0VORV0gPSByZW1vdmVTY2VuZTtcbn07XG5cbi8qKlxuICogR2V0cyB0aGUgc2l6ZSBvZiB0aGUgcGFyZW50IGVsZW1lbnQgb2YgdGhlIERPTVJlbmRlcmVyIGZvciB0aGlzIGNvbnRleHQuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge3VuZGVmaW5lZH0gdW5kZWZpbmVkXG4gKi9cbkNvbnRleHQucHJvdG90eXBlLmdldFJvb3RTaXplID0gZnVuY3Rpb24gZ2V0Um9vdFNpemUoKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdGhpcy5fcm9vdEVsLm9mZnNldFdpZHRoLFxuICAgICAgICB0aGlzLl9yb290RWwub2Zmc2V0SGVpZ2h0XG4gICAgXTtcbn07XG5cblxuLyoqXG4gKiBJbml0aWFsaXplcyB0aGUgY29udGV4dCBpZiB0aGUgYFJFQURZYCBjb21tYW5kIGhhcyBiZWVuIHJlY2VpdmVkIGVhcmxpZXIuXG4gKlxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuY2hlY2tJbml0ID0gZnVuY3Rpb24gY2hlY2tJbml0ICgpIHtcbiAgICBpZiAodGhpcy5faW5pdERPTSkge1xuICAgICAgICB0aGlzLl9kb21SZW5kZXJlclJvb3RFbC5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICB0aGlzLl9pbml0RE9NID0gZmFsc2U7XG4gICAgfVxufTtcblxuLyoqXG4gKiBIYW5kbGVzIGRlbGVnYXRpb24gb2YgY29tbWFuZHMgdG8gcmVuZGVyZXJzIG9mIHRoaXMgY29udGV4dC5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHBhdGggU3RyaW5nIHVzZWQgYXMgaWRlbnRpZmllciBvZiBhIGdpdmVuIG5vZGUgaW4gdGhlXG4gKiBzY2VuZSBncmFwaC5cbiAqIEBwYXJhbSB7QXJyYXl9IGNvbW1hbmRzIExpc3Qgb2YgYWxsIGNvbW1hbmRzIGZyb20gdGhpcyBmcmFtZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBpdGVyYXRvciBOdW1iZXIgaW5kaWNhdGluZyBwcm9ncmVzcyB0aHJvdWdoIHRoZSBjb21tYW5kXG4gKiBxdWV1ZS5cbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGl0ZXJhdG9yIGluZGljYXRpbmcgcHJvZ3Jlc3MgdGhyb3VnaCB0aGUgY29tbWFuZCBxdWV1ZS5cbiAqL1xuQ29udGV4dC5wcm90b3R5cGUucmVjZWl2ZSA9IGZ1bmN0aW9uIHJlY2VpdmUocGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgdmFyIGxvY2FsSXRlcmF0b3IgPSBpdGVyYXRvcjtcblxuICAgIHZhciBjb21tYW5kID0gY29tbWFuZHNbKytsb2NhbEl0ZXJhdG9yXTtcblxuICAgIHRoaXMuX2RvbVJlbmRlcmVyLmxvYWRQYXRoKHBhdGgpO1xuXG4gICAgd2hpbGUgKGNvbW1hbmQgIT0gbnVsbCkge1xuICAgICAgICBpZiAoY29tbWFuZCA9PT0gQ29tbWFuZHMuV0lUSCB8fCBjb21tYW5kID09PSBDb21tYW5kcy5USU1FKSByZXR1cm4gbG9jYWxJdGVyYXRvciAtIDE7XG4gICAgICAgIGVsc2UgbG9jYWxJdGVyYXRvciA9IHRoaXMuX2NvbW1hbmRDYWxsYmFja3NbY29tbWFuZF0odGhpcywgcGF0aCwgY29tbWFuZHMsIGxvY2FsSXRlcmF0b3IpICsgMTtcbiAgICAgICAgY29tbWFuZCA9IGNvbW1hbmRzW2xvY2FsSXRlcmF0b3JdO1xuICAgIH1cblxuICAgIHJldHVybiBsb2NhbEl0ZXJhdG9yO1xufTtcblxuLyoqXG4gKiBHZXR0ZXIgbWV0aG9kIHVzZWQgZm9yIHJldHJpZXZpbmcgdGhlIHVzZWQgRE9NUmVuZGVyZXIuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge0RPTVJlbmRlcmVyfSAgICBUaGUgRE9NUmVuZGVyZXIgYmVpbmcgdXNlZCBieSB0aGUgQ29udGV4dC5cbiAqL1xuQ29udGV4dC5wcm90b3R5cGUuZ2V0RE9NUmVuZGVyZXIgPSBmdW5jdGlvbiBnZXRET01SZW5kZXJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fZG9tUmVuZGVyZXI7XG59O1xuXG5Db250ZXh0LnByb3RvdHlwZS5jbGVhbnVwID0gZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgdGhpcy5fcm9vdEVsLnJlbW92ZUNoaWxkKHRoaXMuX2RvbVJlbmRlcmVyUm9vdEVsKTtcbiAgICBpZiAodGhpcy5fd2ViR0xSZW5kZXJlclJvb3RFbClcbiAgICAgICAgdGhpcy5fcm9vdEVsLnJlbW92ZUNoaWxkKHRoaXMuX3dlYkdMUmVuZGVyZXJSb290RWwpO1xufTtcblxuLy8gQ29tbWFuZCBDYWxsYmFja3NcbmZ1bmN0aW9uIHByZXZlbnREZWZhdWx0IChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBjb250ZXh0Ll9kb21SZW5kZXJlci5wcmV2ZW50RGVmYXVsdChjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBhbGxvd0RlZmF1bHQgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLmFsbG93RGVmYXVsdChjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiByZWFkeSAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgY29udGV4dC5faW5pdERPTSA9IHRydWU7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBpbml0RE9NIChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBjb250ZXh0Ll9kb21SZW5kZXJlci5pbnNlcnRFbChjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBkb21SZW5kZXJTaXplIChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBjb250ZXh0Ll9kb21SZW5kZXJlci5nZXRTaXplT2YoY29tbWFuZHNbKytpdGVyYXRvcl0pO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gY2hhbmdlVHJhbnNmb3JtIChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICB2YXIgdGVtcCA9IGNvbnRleHQuX2N1cnJlbnRUcmFuc2Zvcm07XG5cbiAgICB0ZW1wWzBdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgdGVtcFsxXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHRlbXBbMl0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB0ZW1wWzNdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgdGVtcFs0XSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHRlbXBbNV0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB0ZW1wWzZdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgdGVtcFs3XSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHRlbXBbOF0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB0ZW1wWzldID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgdGVtcFsxMF0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB0ZW1wWzExXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHRlbXBbMTJdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgdGVtcFsxM10gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICB0ZW1wWzE0XSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHRlbXBbMTVdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG5cbiAgICBjb250ZXh0Ll9kb21SZW5kZXJlci5zZXRNYXRyaXgodGVtcCk7XG5cbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZVNpemUgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIHZhciB3aWR0aCA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIHZhciBoZWlnaHQgPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcblxuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLnNldFNpemUod2lkdGgsIGhlaWdodCk7XG5cbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZVByb3BlcnR5IChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBjb250ZXh0Ll9kb21SZW5kZXJlci5zZXRQcm9wZXJ0eShjb21tYW5kc1srK2l0ZXJhdG9yXSwgY29tbWFuZHNbKytpdGVyYXRvcl0pO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gY2hhbmdlQ29udGVudCAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgY29udGV4dC5fZG9tUmVuZGVyZXIuc2V0Q29udGVudChjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBjaGFuZ2VBdHRyaWJ1dGUgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLnNldEF0dHJpYnV0ZShjb21tYW5kc1srK2l0ZXJhdG9yXSwgY29tbWFuZHNbKytpdGVyYXRvcl0pO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gYWRkQ2xhc3MgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLmFkZENsYXNzKGNvbW1hbmRzWysraXRlcmF0b3JdKTtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChjb250ZXh0LCBwYXRoLCBjb21tYW5kcywgaXRlcmF0b3IpIHtcbiAgICBjb250ZXh0Ll9kb21SZW5kZXJlci5yZW1vdmVDbGFzcyhjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmUgKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGNvbnRleHQuX2RvbVJlbmRlcmVyLnN1YnNjcmliZShjb21tYW5kc1srK2l0ZXJhdG9yXSk7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiB1bnN1YnNjcmliZSAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgY29udGV4dC5fZG9tUmVuZGVyZXIudW5zdWJzY3JpYmUoY29tbWFuZHNbKytpdGVyYXRvcl0pO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gcGluaG9sZVByb2plY3Rpb24gKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnByb2plY3Rpb25UeXBlID0gQ2FtZXJhLlBJTkhPTEVfUFJPSkVDVElPTjtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZVRyYW5zZm9ybVsxMV0gPSAtMSAvIGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnBlcnNwZWN0aXZlRGlydHkgPSB0cnVlO1xuICAgIHJldHVybiBpdGVyYXRvcjtcbn1cblxuZnVuY3Rpb24gb3J0aG9ncmFwaGljUHJvamVjdGlvbiAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUucHJvamVjdGlvblR5cGUgPSBDYW1lcmEuT1JUSE9HUkFQSElDX1BST0pFQ1RJT047XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUucGVyc3BlY3RpdmVUcmFuc2Zvcm1bMTFdID0gMDtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS5wZXJzcGVjdGl2ZURpcnR5ID0gdHJ1ZTtcbiAgICByZXR1cm4gaXRlcmF0b3I7XG59XG5cbmZ1bmN0aW9uIGNoYW5nZVZpZXdUcmFuc2Zvcm0gKGNvbnRleHQsIHBhdGgsIGNvbW1hbmRzLCBpdGVyYXRvcikge1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMF0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzFdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsyXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bM10gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcblxuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bNF0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzVdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVs2XSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bN10gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcblxuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bOF0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzldID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsxMF0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzExXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuXG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsxMl0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcbiAgICBjb250ZXh0Ll9yZW5kZXJTdGF0ZS52aWV3VHJhbnNmb3JtWzEzXSA9IGNvbW1hbmRzWysraXRlcmF0b3JdO1xuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdUcmFuc2Zvcm1bMTRdID0gY29tbWFuZHNbKytpdGVyYXRvcl07XG4gICAgY29udGV4dC5fcmVuZGVyU3RhdGUudmlld1RyYW5zZm9ybVsxNV0gPSBjb21tYW5kc1srK2l0ZXJhdG9yXTtcblxuICAgIGNvbnRleHQuX3JlbmRlclN0YXRlLnZpZXdEaXJ0eSA9IHRydWU7XG4gICAgcmV0dXJuIGl0ZXJhdG9yO1xufVxuXG5mdW5jdGlvbiByZW1vdmVTY2VuZSAoY29udGV4dCwgcGF0aCwgY29tbWFuZHMsIGl0ZXJhdG9yKSB7XG4gICAgY29udGV4dC5fY29tcG9zaXRvci5yZW1vdmVDb250ZXh0KHBhdGgpO1xuICAgIHJldHVybiBjb21tYW5kcy5sZW5ndGggLSAxO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbnRleHQ7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBDb21tYW5kcyA9IHJlcXVpcmUoJy4uL2NvcmUvQ29tbWFuZHMnKTtcblxuLyoqXG4gKiBUaGUgVUlNYW5hZ2VyIGlzIGJlaW5nIHVwZGF0ZWQgYnkgYW4gRW5naW5lIGJ5IGNvbnNlY3V0aXZlbHkgY2FsbGluZyBpdHNcbiAqIGB1cGRhdGVgIG1ldGhvZC4gSXQgY2FuIGVpdGhlciBtYW5hZ2UgYSByZWFsIFdlYi1Xb3JrZXIgb3IgdGhlIGdsb2JhbFxuICogRmFtb3VzRW5naW5lIGNvcmUgc2luZ2xldG9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgY29tcG9zaXRvciA9IG5ldyBDb21wb3NpdG9yKCk7XG4gKiB2YXIgZW5naW5lID0gbmV3IEVuZ2luZSgpO1xuICpcbiAqIC8vIFVzaW5nIGEgV2ViIFdvcmtlclxuICogdmFyIHdvcmtlciA9IG5ldyBXb3JrZXIoJ3dvcmtlci5idW5kbGUuanMnKTtcbiAqIHZhciB0aHJlYWRtYW5nZXIgPSBuZXcgVUlNYW5hZ2VyKHdvcmtlciwgY29tcG9zaXRvciwgZW5naW5lKTtcbiAqXG4gKiAvLyBXaXRob3V0IHVzaW5nIGEgV2ViIFdvcmtlclxuICogdmFyIHRocmVhZG1hbmdlciA9IG5ldyBVSU1hbmFnZXIoRmFtb3VzLCBjb21wb3NpdG9yLCBlbmdpbmUpO1xuICpcbiAqIEBjbGFzcyAgVUlNYW5hZ2VyXG4gKiBAY29uc3RydWN0b3JcbiAqXG4gKiBAcGFyYW0ge0ZhbW91c3xXb3JrZXJ9IHRocmVhZCBUaGUgdGhyZWFkIGJlaW5nIHVzZWQgdG8gcmVjZWl2ZSBtZXNzYWdlc1xuICogZnJvbSBhbmQgcG9zdCBtZXNzYWdlcyB0by4gRXhwZWN0ZWQgdG8gZXhwb3NlIGEgV2ViV29ya2VyLWxpa2UgQVBJLCB3aGljaFxuICogbWVhbnMgcHJvdmlkaW5nIGEgd2F5IHRvIGxpc3RlbiBmb3IgdXBkYXRlcyBieSBzZXR0aW5nIGl0cyBgb25tZXNzYWdlYFxuICogcHJvcGVydHkgYW5kIHNlbmRpbmcgdXBkYXRlcyB1c2luZyBgcG9zdE1lc3NhZ2VgLlxuICogQHBhcmFtIHtDb21wb3NpdG9yfSBjb21wb3NpdG9yIGFuIGluc3RhbmNlIG9mIENvbXBvc2l0b3IgdXNlZCB0byBleHRyYWN0XG4gKiBlbnF1ZXVlZCBkcmF3IGNvbW1hbmRzIGZyb20gdG8gYmUgc2VudCB0byB0aGUgdGhyZWFkLlxuICogQHBhcmFtIHtSZW5kZXJMb29wfSByZW5kZXJMb29wIGFuIGluc3RhbmNlIG9mIEVuZ2luZSB1c2VkIGZvciBleGVjdXRpbmdcbiAqIHRoZSBgRU5HSU5FYCBjb21tYW5kcyBvbi5cbiAqL1xuZnVuY3Rpb24gVUlNYW5hZ2VyICh0aHJlYWQsIGNvbXBvc2l0b3IsIHJlbmRlckxvb3ApIHtcbiAgICB0aGlzLl90aHJlYWQgPSB0aHJlYWQ7XG4gICAgdGhpcy5fY29tcG9zaXRvciA9IGNvbXBvc2l0b3I7XG4gICAgdGhpcy5fcmVuZGVyTG9vcCA9IHJlbmRlckxvb3A7XG5cbiAgICB0aGlzLl9yZW5kZXJMb29wLnVwZGF0ZSh0aGlzKTtcblxuICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgdGhpcy5fdGhyZWFkLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICB2YXIgbWVzc2FnZSA9IGV2LmRhdGEgPyBldi5kYXRhIDogZXY7XG4gICAgICAgIGlmIChtZXNzYWdlWzBdID09PSBDb21tYW5kcy5FTkdJTkUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWVzc2FnZVsxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgQ29tbWFuZHMuU1RBUlQ6XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9lbmdpbmUuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBDb21tYW5kcy5TVE9QOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fZW5naW5lLnN0b3AoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgICAgICAgICAgICAgICdVbmtub3duIEVOR0lORSBjb21tYW5kIFwiJyArIG1lc3NhZ2VbMV0gKyAnXCInXG4gICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX3RoaXMuX2NvbXBvc2l0b3IucmVjZWl2ZUNvbW1hbmRzKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB0aGlzLl90aHJlYWQub25lcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHRocmVhZCBiZWluZyB1c2VkIGJ5IHRoZSBVSU1hbmFnZXIuXG4gKiBUaGlzIGNvdWxkIGVpdGhlciBiZSBhbiBhbiBhY3R1YWwgd2ViIHdvcmtlciBvciBhIGBGYW1vdXNFbmdpbmVgIHNpbmdsZXRvbi5cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHJldHVybiB7V29ya2VyfEZhbW91c0VuZ2luZX0gRWl0aGVyIGEgd2ViIHdvcmtlciBvciBhIGBGYW1vdXNFbmdpbmVgIHNpbmdsZXRvbi5cbiAqL1xuVUlNYW5hZ2VyLnByb3RvdHlwZS5nZXRUaHJlYWQgPSBmdW5jdGlvbiBnZXRUaHJlYWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RocmVhZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29tcG9zaXRvciBiZWluZyB1c2VkIGJ5IHRoaXMgVUlNYW5hZ2VyLlxuICpcbiAqIEBtZXRob2RcbiAqXG4gKiBAcmV0dXJuIHtDb21wb3NpdG9yfSBUaGUgY29tcG9zaXRvciB1c2VkIGJ5IHRoZSBVSU1hbmFnZXIuXG4gKi9cblVJTWFuYWdlci5wcm90b3R5cGUuZ2V0Q29tcG9zaXRvciA9IGZ1bmN0aW9uIGdldENvbXBvc2l0b3IoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbXBvc2l0b3I7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJlbmRlciBsb29wIGN1cnJlbnRseSBiZWluZyB1c2VkIGJ5IHRoZSBVSU1hbmFnZXIuXG4gKlxuICogQG1ldGhvZFxuICpcbiAqIEByZXR1cm4ge1JlbmRlckxvb3B9ICBUaGUgcmVnaXN0ZXJlZCByZW5kZXIgbG9vcCB1c2VkIGZvciB1cGRhdGluZyB0aGVcbiAqIFVJTWFuYWdlci5cbiAqL1xuVUlNYW5hZ2VyLnByb3RvdHlwZS5nZXRSZW5kZXJMb29wID0gZnVuY3Rpb24gZ2V0UmVuZGVyTG9vcCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVuZGVyTG9vcDtcbn07XG5cbi8qKlxuICogVXBkYXRlIG1ldGhvZCBiZWluZyBpbnZva2VkIGJ5IHRoZSBFbmdpbmUgb24gZXZlcnkgYHJlcXVlc3RBbmltYXRpb25GcmFtZWAuXG4gKiBVc2VkIGZvciB1cGRhdGluZyB0aGUgbm90aW9uIG9mIHRpbWUgd2l0aGluIHRoZSBtYW5hZ2VkIHRocmVhZCBieSBzZW5kaW5nXG4gKiBhIEZSQU1FIGNvbW1hbmQgYW5kIHNlbmRpbmcgbWVzc2FnZXMgdG9cbiAqXG4gKiBAbWV0aG9kXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfSB0aW1lIHVuaXggdGltZXN0YW1wIHRvIGJlIHBhc3NlZCBkb3duIHRvIHRoZSB3b3JrZXIgYXMgYVxuICogRlJBTUUgY29tbWFuZFxuICogQHJldHVybiB7dW5kZWZpbmVkfSB1bmRlZmluZWRcbiAqL1xuVUlNYW5hZ2VyLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUgKHRpbWUpIHtcbiAgICB0aGlzLl90aHJlYWQucG9zdE1lc3NhZ2UoW0NvbW1hbmRzLkZSQU1FLCB0aW1lXSk7XG4gICAgdmFyIHRocmVhZE1lc3NhZ2VzID0gdGhpcy5fY29tcG9zaXRvci5kcmF3Q29tbWFuZHMoKTtcbiAgICB0aGlzLl90aHJlYWQucG9zdE1lc3NhZ2UodGhyZWFkTWVzc2FnZXMpO1xuICAgIHRoaXMuX2NvbXBvc2l0b3IuY2xlYXJDb21tYW5kcygpO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBVSU1hbmFnZXI7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjc3MgPSAnLmZhbW91cy1kb20tcmVuZGVyZXIgeycgK1xuICAgICd3aWR0aDoxMDAlOycgK1xuICAgICdoZWlnaHQ6MTAwJTsnICtcbiAgICAndHJhbnNmb3JtLXN0eWxlOnByZXNlcnZlLTNkOycgK1xuICAgICctd2Via2l0LXRyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZDsnICtcbiAgICAnLXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWigwKTsnICtcbiAgICAndHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7JyArXG4nfScgK1xuXG4nLmZhbW91cy1kb20tZWxlbWVudCB7JyArXG4gICAgJy13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjowJSAwJTsnICtcbiAgICAndHJhbnNmb3JtLW9yaWdpbjowJSAwJTsnICtcbiAgICAnLXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OnZpc2libGU7JyArXG4gICAgJ2JhY2tmYWNlLXZpc2liaWxpdHk6dmlzaWJsZTsnICtcbiAgICAnLXdlYmtpdC10cmFuc2Zvcm0tc3R5bGU6cHJlc2VydmUtM2Q7JyArXG4gICAgJ3RyYW5zZm9ybS1zdHlsZTpwcmVzZXJ2ZS0zZDsnICtcbiAgICAnLXdlYmtpdC10YXAtaGlnaGxpZ2h0LWNvbG9yOnRyYW5zcGFyZW50OycgK1xuICAgICdwb2ludGVyLWV2ZW50czphdXRvOycgK1xuICAgICd6LWluZGV4OjE7JyArXG4nfScgK1xuXG4nLmZhbW91cy1kb20tZWxlbWVudC1jb250ZW50LCcgK1xuJy5mYW1vdXMtZG9tLWVsZW1lbnQgeycgK1xuICAgICdwb3NpdGlvbjphYnNvbHV0ZTsnICtcbiAgICAnYm94LXNpemluZzpib3JkZXItYm94OycgK1xuICAgICctbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDsnICtcbiAgICAnLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7JyArXG4nfScgK1xuXG4nLmZhbW91cy13ZWJnbC1yZW5kZXJlciB7JyArXG4gICAgJy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMTAwMDAwMHB4KTsnICsgIC8qIFRPRE86IEZpeCB3aGVuIFNhZmFyaSBGaXhlcyovXG4gICAgJ3RyYW5zZm9ybTp0cmFuc2xhdGVaKDEwMDAwMDBweCk7JyArXG4gICAgJ3BvaW50ZXItZXZlbnRzOm5vbmU7JyArXG4gICAgJ3Bvc2l0aW9uOmFic29sdXRlOycgK1xuICAgICd6LWluZGV4OjE7JyArXG4gICAgJ3RvcDowOycgK1xuICAgICd3aWR0aDoxMDAlOycgK1xuICAgICdoZWlnaHQ6MTAwJTsnICtcbid9JztcblxudmFyIElOSkVDVEVEID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJztcblxuZnVuY3Rpb24gaW5qZWN0Q1NTKCkge1xuICAgIGlmIChJTkpFQ1RFRCkgcmV0dXJuO1xuICAgIElOSkVDVEVEID0gdHJ1ZTtcbiAgICBpZiAoZG9jdW1lbnQuY3JlYXRlU3R5bGVTaGVldCkge1xuICAgICAgICB2YXIgc2hlZXQgPSBkb2N1bWVudC5jcmVhdGVTdHlsZVNoZWV0KCk7XG4gICAgICAgIHNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgICAgIHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJyk7XG5cbiAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgICAgIHN0eWxlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGNzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgKGhlYWQgPyBoZWFkIDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluamVjdENTUztcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbi8qanNoaW50IC1XMDA4ICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGxpYnJhcnkgb2YgY3VydmVzIHdoaWNoIG1hcCBhbiBhbmltYXRpb24gZXhwbGljaXRseSBhcyBhIGZ1bmN0aW9uIG9mIHRpbWUuXG4gKlxuICogQG5hbWVzcGFjZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gbGluZWFyXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBlYXNlSW5cbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVhc2VPdXRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGVhc2VJbk91dFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gZWFzZU91dEJvdW5jZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gc3ByaW5nXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpblF1YWRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG91dFF1YWRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluT3V0UXVhZFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5DdWJpY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb3V0Q3ViaWNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluT3V0Q3ViaWNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluUXVhcnRcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG91dFF1YXJ0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpbk91dFF1YXJ0XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpblF1aW50XG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvdXRRdWludFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5PdXRRdWludFxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5TaW5lXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBvdXRTaW5lXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpbk91dFNpbmVcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluRXhwb1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb3V0RXhwb1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5PdXRFeHBcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluQ2lyY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gb3V0Q2lyY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5PdXRDaXJjXG4gKiBAcHJvcGVydHkge0Z1bmN0aW9ufSBpbkVsYXN0aWNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG91dEVsYXN0aWNcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGluT3V0RWxhc3RpY1xuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5Cb3VuY2VcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IG91dEJvdW5jZVxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gaW5PdXRCb3VuY2VcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGZsYXQgICAgICAgICAgICAtIFVzZWZ1bCBmb3IgZGVsYXlpbmcgdGhlIGV4ZWN1dGlvbiBvZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYSBzdWJzZXF1ZW50IHRyYW5zaXRpb24uXG4gKi9cbnZhciBDdXJ2ZXMgPSB7XG4gICAgbGluZWFyOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0O1xuICAgIH0sXG5cbiAgICBlYXNlSW46IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdDtcbiAgICB9LFxuXG4gICAgZWFzZU91dDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCooMi10KTtcbiAgICB9LFxuXG4gICAgZWFzZUluT3V0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDw9IDAuNSkgcmV0dXJuIDIqdCp0O1xuICAgICAgICBlbHNlIHJldHVybiAtMip0KnQgKyA0KnQgLSAxO1xuICAgIH0sXG5cbiAgICBlYXNlT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KigzIC0gMip0KTtcbiAgICB9LFxuXG4gICAgc3ByaW5nOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAoMSAtIHQpICogTWF0aC5zaW4oNiAqIE1hdGguUEkgKiB0KSArIHQ7XG4gICAgfSxcblxuICAgIGluUXVhZDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0O1xuICAgIH0sXG5cbiAgICBvdXRRdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAtKHQtPTEpKnQrMTtcbiAgICB9LFxuXG4gICAgaW5PdXRRdWFkOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdDtcbiAgICAgICAgcmV0dXJuIC0uNSooKC0tdCkqKHQtMikgLSAxKTtcbiAgICB9LFxuXG4gICAgaW5DdWJpYzogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gdCp0KnQ7XG4gICAgfSxcblxuICAgIG91dEN1YmljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAoKC0tdCkqdCp0ICsgMSk7XG4gICAgfSxcblxuICAgIGluT3V0Q3ViaWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0KnQ7XG4gICAgICAgIHJldHVybiAuNSooKHQtPTIpKnQqdCArIDIpO1xuICAgIH0sXG5cbiAgICBpblF1YXJ0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiB0KnQqdCp0O1xuICAgIH0sXG5cbiAgICBvdXRRdWFydDogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLSgoLS10KSp0KnQqdCAtIDEpO1xuICAgIH0sXG5cbiAgICBpbk91dFF1YXJ0OiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41KnQqdCp0KnQ7XG4gICAgICAgIHJldHVybiAtLjUgKiAoKHQtPTIpKnQqdCp0IC0gMik7XG4gICAgfSxcblxuICAgIGluUXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIHQqdCp0KnQqdDtcbiAgICB9LFxuXG4gICAgb3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICgoLS10KSp0KnQqdCp0ICsgMSk7XG4gICAgfSxcblxuICAgIGluT3V0UXVpbnQ6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKCh0Lz0uNSkgPCAxKSByZXR1cm4gLjUqdCp0KnQqdCp0O1xuICAgICAgICByZXR1cm4gLjUqKCh0LT0yKSp0KnQqdCp0ICsgMik7XG4gICAgfSxcblxuICAgIGluU2luZTogZnVuY3Rpb24odCkge1xuICAgICAgICByZXR1cm4gLTEuMCpNYXRoLmNvcyh0ICogKE1hdGguUEkvMikpICsgMS4wO1xuICAgIH0sXG5cbiAgICBvdXRTaW5lOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiBNYXRoLnNpbih0ICogKE1hdGguUEkvMikpO1xuICAgIH0sXG5cbiAgICBpbk91dFNpbmU6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0uNSooTWF0aC5jb3MoTWF0aC5QSSp0KSAtIDEpO1xuICAgIH0sXG5cbiAgICBpbkV4cG86IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuICh0PT09MCkgPyAwLjAgOiBNYXRoLnBvdygyLCAxMCAqICh0IC0gMSkpO1xuICAgIH0sXG5cbiAgICBvdXRFeHBvOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHJldHVybiAodD09PTEuMCkgPyAxLjAgOiAoLU1hdGgucG93KDIsIC0xMCAqIHQpICsgMSk7XG4gICAgfSxcblxuICAgIGluT3V0RXhwbzogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7XG4gICAgICAgIGlmICh0PT09MS4wKSByZXR1cm4gMS4wO1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAuNSAqIE1hdGgucG93KDIsIDEwICogKHQgLSAxKSk7XG4gICAgICAgIHJldHVybiAuNSAqICgtTWF0aC5wb3coMiwgLTEwICogLS10KSArIDIpO1xuICAgIH0sXG5cbiAgICBpbkNpcmM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIC0oTWF0aC5zcXJ0KDEgLSB0KnQpIC0gMSk7XG4gICAgfSxcblxuICAgIG91dENpcmM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydCgxIC0gKC0tdCkqdCk7XG4gICAgfSxcblxuICAgIGluT3V0Q2lyYzogZnVuY3Rpb24odCkge1xuICAgICAgICBpZiAoKHQvPS41KSA8IDEpIHJldHVybiAtLjUgKiAoTWF0aC5zcXJ0KDEgLSB0KnQpIC0gMSk7XG4gICAgICAgIHJldHVybiAuNSAqIChNYXRoLnNxcnQoMSAtICh0LT0yKSp0KSArIDEpO1xuICAgIH0sXG5cbiAgICBpbkVsYXN0aWM6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgdmFyIHM9MS43MDE1ODt2YXIgcD0wO3ZhciBhPTEuMDtcbiAgICAgICAgaWYgKHQ9PT0wKSByZXR1cm4gMC4wOyAgaWYgKHQ9PT0xKSByZXR1cm4gMS4wOyAgaWYgKCFwKSBwPS4zO1xuICAgICAgICBzID0gcC8oMipNYXRoLlBJKSAqIE1hdGguYXNpbigxLjAvYSk7XG4gICAgICAgIHJldHVybiAtKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvIHApKTtcbiAgICB9LFxuXG4gICAgb3V0RWxhc3RpYzogZnVuY3Rpb24odCkge1xuICAgICAgICB2YXIgcz0xLjcwMTU4O3ZhciBwPTA7dmFyIGE9MS4wO1xuICAgICAgICBpZiAodD09PTApIHJldHVybiAwLjA7ICBpZiAodD09PTEpIHJldHVybiAxLjA7ICBpZiAoIXApIHA9LjM7XG4gICAgICAgIHMgPSBwLygyKk1hdGguUEkpICogTWF0aC5hc2luKDEuMC9hKTtcbiAgICAgICAgcmV0dXJuIGEqTWF0aC5wb3coMiwtMTAqdCkgKiBNYXRoLnNpbigodC1zKSooMipNYXRoLlBJKS9wKSArIDEuMDtcbiAgICB9LFxuXG4gICAgaW5PdXRFbGFzdGljOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIHZhciBzPTEuNzAxNTg7dmFyIHA9MDt2YXIgYT0xLjA7XG4gICAgICAgIGlmICh0PT09MCkgcmV0dXJuIDAuMDsgIGlmICgodC89LjUpPT09MikgcmV0dXJuIDEuMDsgIGlmICghcCkgcD0oLjMqMS41KTtcbiAgICAgICAgcyA9IHAvKDIqTWF0aC5QSSkgKiBNYXRoLmFzaW4oMS4wL2EpO1xuICAgICAgICBpZiAodCA8IDEpIHJldHVybiAtLjUqKGEqTWF0aC5wb3coMiwxMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvcCkpO1xuICAgICAgICByZXR1cm4gYSpNYXRoLnBvdygyLC0xMCoodC09MSkpICogTWF0aC5zaW4oKHQtcykqKDIqTWF0aC5QSSkvcCkqLjUgKyAxLjA7XG4gICAgfSxcblxuICAgIGluQmFjazogZnVuY3Rpb24odCwgcykge1xuICAgICAgICBpZiAocyA9PT0gdW5kZWZpbmVkKSBzID0gMS43MDE1ODtcbiAgICAgICAgcmV0dXJuIHQqdCooKHMrMSkqdCAtIHMpO1xuICAgIH0sXG5cbiAgICBvdXRCYWNrOiBmdW5jdGlvbih0LCBzKSB7XG4gICAgICAgIGlmIChzID09PSB1bmRlZmluZWQpIHMgPSAxLjcwMTU4O1xuICAgICAgICByZXR1cm4gKCgtLXQpKnQqKChzKzEpKnQgKyBzKSArIDEpO1xuICAgIH0sXG5cbiAgICBpbk91dEJhY2s6IGZ1bmN0aW9uKHQsIHMpIHtcbiAgICAgICAgaWYgKHMgPT09IHVuZGVmaW5lZCkgcyA9IDEuNzAxNTg7XG4gICAgICAgIGlmICgodC89LjUpIDwgMSkgcmV0dXJuIC41Kih0KnQqKCgocyo9KDEuNTI1KSkrMSkqdCAtIHMpKTtcbiAgICAgICAgcmV0dXJuIC41KigodC09MikqdCooKChzKj0oMS41MjUpKSsxKSp0ICsgcykgKyAyKTtcbiAgICB9LFxuXG4gICAgaW5Cb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgcmV0dXJuIDEuMCAtIEN1cnZlcy5vdXRCb3VuY2UoMS4wLXQpO1xuICAgIH0sXG5cbiAgICBvdXRCb3VuY2U6IGZ1bmN0aW9uKHQpIHtcbiAgICAgICAgaWYgKHQgPCAoMS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqdCp0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IDwgKDIvMi43NSkpIHtcbiAgICAgICAgICAgIHJldHVybiAoNy41NjI1Kih0LT0oMS41LzIuNzUpKSp0ICsgLjc1KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0IDwgKDIuNS8yLjc1KSkge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgyLjI1LzIuNzUpKSp0ICsgLjkzNzUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICg3LjU2MjUqKHQtPSgyLjYyNS8yLjc1KSkqdCArIC45ODQzNzUpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGluT3V0Qm91bmNlOiBmdW5jdGlvbih0KSB7XG4gICAgICAgIGlmICh0IDwgLjUpIHJldHVybiBDdXJ2ZXMuaW5Cb3VuY2UodCoyKSAqIC41O1xuICAgICAgICByZXR1cm4gQ3VydmVzLm91dEJvdW5jZSh0KjItMS4wKSAqIC41ICsgLjU7XG4gICAgfSxcblxuICAgIGZsYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEN1cnZlcztcbiIsIi8qKlxuICogVGhlIE1JVCBMaWNlbnNlIChNSVQpXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDE1IEZhbW91cyBJbmR1c3RyaWVzIEluYy5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuICogVEhFIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEN1cnZlcyA9IHJlcXVpcmUoJy4vQ3VydmVzJyk7XG52YXIgRmFtb3VzRW5naW5lID0gcmVxdWlyZSgnLi4vY29yZS9GYW1vdXNFbmdpbmUnKTtcblxuLyoqXG4gKiBBIHN0YXRlIG1haW50YWluZXIgZm9yIGEgc21vb3RoIHRyYW5zaXRpb24gYmV0d2VlblxuICogICAgbnVtZXJpY2FsbHktc3BlY2lmaWVkIHN0YXRlcy4gRXhhbXBsZSBudW1lcmljIHN0YXRlcyBpbmNsdWRlIGZsb2F0cyBhbmRcbiAqICAgIGFycmF5cyBvZiBmbG9hdHMgb2JqZWN0cy5cbiAqXG4gKiBBbiBpbml0aWFsIHN0YXRlIGlzIHNldCB3aXRoIHRoZSBjb25zdHJ1Y3RvciBvciB1c2luZ1xuICogICAgIHtAbGluayBUcmFuc2l0aW9uYWJsZSNmcm9tfS4gU3Vic2VxdWVudCB0cmFuc2l0aW9ucyBjb25zaXN0IG9mIGFuXG4gKiAgICAgaW50ZXJtZWRpYXRlIHN0YXRlLCBlYXNpbmcgY3VydmUsIGR1cmF0aW9uIGFuZCBjYWxsYmFjay4gVGhlIGZpbmFsIHN0YXRlXG4gKiAgICAgb2YgZWFjaCB0cmFuc2l0aW9uIGlzIHRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZSBzdWJzZXF1ZW50IG9uZS4gQ2FsbHMgdG9cbiAqICAgICB7QGxpbmsgVHJhbnNpdGlvbmFibGUjZ2V0fSBwcm92aWRlIHRoZSBpbnRlcnBvbGF0ZWQgc3RhdGUgYWxvbmcgdGhlIHdheS5cbiAqXG4gKiBOb3RlIHRoYXQgdGhlcmUgaXMgbm8gZXZlbnQgbG9vcCBoZXJlIC0gY2FsbHMgdG8ge0BsaW5rIFRyYW5zaXRpb25hYmxlI2dldH1cbiAqICAgIGFyZSB0aGUgb25seSB3YXkgdG8gZmluZCBzdGF0ZSBwcm9qZWN0ZWQgdG8gdGhlIGN1cnJlbnQgKG9yIHByb3ZpZGVkKVxuICogICAgdGltZSBhbmQgYXJlIHRoZSBvbmx5IHdheSB0byB0cmlnZ2VyIGNhbGxiYWNrcyBhbmQgbXV0YXRlIHRoZSBpbnRlcm5hbFxuICogICAgdHJhbnNpdGlvbiBxdWV1ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHQgPSBuZXcgVHJhbnNpdGlvbmFibGUoWzAsIDBdKTtcbiAqIHRcbiAqICAgICAudG8oWzEwMCwgMF0sICdsaW5lYXInLCAxMDAwKVxuICogICAgIC5kZWxheSgxMDAwKVxuICogICAgIC50byhbMjAwLCAwXSwgJ291dEJvdW5jZScsIDEwMDApO1xuICpcbiAqIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAqIGRpdi5zdHlsZS5iYWNrZ3JvdW5kID0gJ2JsdWUnO1xuICogZGl2LnN0eWxlLndpZHRoID0gJzEwMHB4JztcbiAqIGRpdi5zdHlsZS5oZWlnaHQgPSAnMTAwcHgnO1xuICogZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuICpcbiAqIGRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICogICAgIHQuaXNQYXVzZWQoKSA/IHQucmVzdW1lKCkgOiB0LnBhdXNlKCk7XG4gKiB9KTtcbiAqXG4gKiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gbG9vcCgpIHtcbiAqICAgICBkaXYuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZVgoJyArIHQuZ2V0KClbMF0gKyAncHgpJyArICcgdHJhbnNsYXRlWSgnICsgdC5nZXQoKVsxXSArICdweCknO1xuICogICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShsb29wKTtcbiAqIH0pO1xuICpcbiAqIEBjbGFzcyBUcmFuc2l0aW9uYWJsZVxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge051bWJlcnxBcnJheS5OdW1iZXJ9IGluaXRpYWxTdGF0ZSAgICBpbml0aWFsIHN0YXRlIHRvIHRyYW5zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gLSBlcXVpdmFsZW50IHRvIGEgcHVyc3VhbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludm9jYXRpb24gb2ZcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtAbGluayBUcmFuc2l0aW9uYWJsZSNmcm9tfVxuICovXG5mdW5jdGlvbiBUcmFuc2l0aW9uYWJsZShpbml0aWFsU3RhdGUpIHtcbiAgICB0aGlzLl9xdWV1ZSA9IFtdO1xuICAgIHRoaXMuX2Zyb20gPSBudWxsO1xuICAgIHRoaXMuX3N0YXRlID0gbnVsbDtcbiAgICB0aGlzLl9zdGFydGVkQXQgPSBudWxsO1xuICAgIHRoaXMuX3BhdXNlZEF0ID0gbnVsbDtcbiAgICBpZiAoaW5pdGlhbFN0YXRlICE9IG51bGwpIHRoaXMuZnJvbShpbml0aWFsU3RhdGUpO1xufVxuXG4vKipcbiAqIEludGVybmFsIENsb2NrIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSBjdXJyZW50IHRpbWUgZm9yIHRoZSBvbmdvaW5nXG4gKiB0cmFuc2l0aW9ucy5cbiAqXG4gKiBAdHlwZSB7UGVyZm9ybWFuY2V8RGF0ZXxDbG9ja31cbiAqL1xuVHJhbnNpdGlvbmFibGUuQ2xvY2sgPSBGYW1vdXNFbmdpbmUuZ2V0Q2xvY2soKTtcblxuLyoqXG4gKiBSZWdpc3RlcnMgYSB0cmFuc2l0aW9uIHRvIGJlIHB1c2hlZCBvbnRvIHRoZSBpbnRlcm5hbCBxdWV1ZS5cbiAqXG4gKiBAbWV0aG9kIHRvXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfEFycmF5Lk51bWJlcn0gICAgZmluYWxTdGF0ZSAgICAgICAgICAgICAgZmluYWwgc3RhdGUgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRvbiB0b1xuICogQHBhcmFtICB7U3RyaW5nfEZ1bmN0aW9ufSAgICAgICAgW2N1cnZlPUN1cnZlcy5saW5lYXJdICAgZWFzaW5nIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGluZ1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWzAsIDFdXG4gKiBAcGFyYW0gIHtOdW1iZXJ9ICAgICAgICAgICAgICAgICBbZHVyYXRpb249MTAwXSAgICAgICAgICBkdXJhdGlvbiBvZlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvblxuICogQHBhcmFtICB7RnVuY3Rpb259ICAgICAgICAgICAgICAgW2NhbGxiYWNrXSAgICAgICAgICAgICAgY2FsbGJhY2sgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIGJlIGNhbGxlZCBhZnRlclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlIHRyYW5zaXRpb24gaXNcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAgICAgICAgICAgICAgICBbbWV0aG9kXSAgICAgICAgICAgICAgICBtZXRob2QgdXNlZCBmb3JcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlLmcuIHNsZXJwKVxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUudG8gPSBmdW5jdGlvbiB0byhmaW5hbFN0YXRlLCBjdXJ2ZSwgZHVyYXRpb24sIGNhbGxiYWNrLCBtZXRob2QpIHtcbiAgICBjdXJ2ZSA9IGN1cnZlICE9IG51bGwgJiYgY3VydmUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IEN1cnZlc1tjdXJ2ZV0gOiBjdXJ2ZTtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgICAgIHRoaXMuX3BhdXNlZEF0ID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fcXVldWUucHVzaChcbiAgICAgICAgZmluYWxTdGF0ZSxcbiAgICAgICAgY3VydmUgIT0gbnVsbCA/IGN1cnZlIDogQ3VydmVzLmxpbmVhcixcbiAgICAgICAgZHVyYXRpb24gIT0gbnVsbCA/IGR1cmF0aW9uIDogMTAwLFxuICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgbWV0aG9kXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogUmVzZXRzIHRoZSB0cmFuc2l0aW9uIHF1ZXVlIHRvIGEgc3RhYmxlIGluaXRpYWwgc3RhdGUuXG4gKlxuICogQG1ldGhvZCBmcm9tXG4gKiBAY2hhaW5hYmxlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfEFycmF5Lk51bWJlcn0gICAgaW5pdGlhbFN0YXRlICAgIGluaXRpYWwgc3RhdGUgdG9cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uIGZyb21cbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSAgICAgICAgIHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmZyb20gPSBmdW5jdGlvbiBmcm9tKGluaXRpYWxTdGF0ZSkge1xuICAgIHRoaXMuX3N0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIHRoaXMuX2Zyb20gPSB0aGlzLl9zeW5jKG51bGwsIHRoaXMuX3N0YXRlKTtcbiAgICB0aGlzLl9xdWV1ZS5sZW5ndGggPSAwO1xuICAgIHRoaXMuX3N0YXJ0ZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgdGhpcy5fcGF1c2VkQXQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBEZWxheXMgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgc3Vic2VxdWVudCB0cmFuc2l0aW9uIGZvciBhIGNlcnRhaW4gcGVyaW9kIG9mXG4gKiB0aW1lLlxuICpcbiAqIEBtZXRob2QgZGVsYXlcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gICAgICBkdXJhdGlvbiAgICBkZWxheSB0aW1lIGluIG1zXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSAgICBbY2FsbGJhY2tdICBaZXJvLWFyZ3VtZW50IGZ1bmN0aW9uIHRvIGNhbGwgb24gb2JzZXJ2ZWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb24gKHQ9MSlcbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSAgICAgICAgIHRoaXNcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkoZHVyYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGVuZFN0YXRlID0gdGhpcy5fcXVldWUubGVuZ3RoID4gMCA/IHRoaXMuX3F1ZXVlW3RoaXMuX3F1ZXVlLmxlbmd0aCAtIDVdIDogdGhpcy5fc3RhdGU7XG4gICAgcmV0dXJuIHRoaXMudG8oZW5kU3RhdGUsIEN1cnZlcy5mbGF0LCBkdXJhdGlvbiwgY2FsbGJhY2spO1xufTtcblxuLyoqXG4gKiBPdmVycmlkZXMgY3VycmVudCB0cmFuc2l0aW9uLlxuICpcbiAqIEBtZXRob2Qgb3ZlcnJpZGVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSAgICBbZmluYWxTdGF0ZV0gICAgZmluYWwgc3RhdGUgdG8gdHJhbnNpdG9uIHRvXG4gKiBAcGFyYW0gIHtTdHJpbmd8RnVuY3Rpb259ICAgICAgICBbY3VydmVdICAgICAgICAgZWFzaW5nIGZ1bmN0aW9uIHVzZWQgZm9yXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJwb2xhdGluZyBbMCwgMV1cbiAqIEBwYXJhbSAge051bWJlcn0gICAgICAgICAgICAgICAgIFtkdXJhdGlvbl0gICAgICBkdXJhdGlvbiBvZiB0cmFuc2l0aW9uXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gICAgICAgICAgICAgICBbY2FsbGJhY2tdICAgICAgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsZWQgYWZ0ZXIgdGhlIHRyYW5zaXRpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpcyBjb21wbGV0ZVxuICogQHBhcmFtIHtTdHJpbmd9ICAgICAgICAgICAgICAgICAgW21ldGhvZF0gICAgICAgIG9wdGlvbmFsIG1ldGhvZCB1c2VkIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVycG9sYXRpbmcgYmV0d2VlbiB0aGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXMuIFNldCB0byBgc2xlcnBgIGZvclxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwaGVyaWNhbCBsaW5lYXJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnBvbGF0aW9uLlxuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUub3ZlcnJpZGUgPSBmdW5jdGlvbiBvdmVycmlkZShmaW5hbFN0YXRlLCBjdXJ2ZSwgZHVyYXRpb24sIGNhbGxiYWNrLCBtZXRob2QpIHtcbiAgICBpZiAodGhpcy5fcXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICBpZiAoZmluYWxTdGF0ZSAhPSBudWxsKSB0aGlzLl9xdWV1ZVswXSA9IGZpbmFsU3RhdGU7XG4gICAgICAgIGlmIChjdXJ2ZSAhPSBudWxsKSAgICAgIHRoaXMuX3F1ZXVlWzFdID0gY3VydmUuY29uc3RydWN0b3IgPT09IFN0cmluZyA/IEN1cnZlc1tjdXJ2ZV0gOiBjdXJ2ZTtcbiAgICAgICAgaWYgKGR1cmF0aW9uICE9IG51bGwpICAgdGhpcy5fcXVldWVbMl0gPSBkdXJhdGlvbjtcbiAgICAgICAgaWYgKGNhbGxiYWNrICE9IG51bGwpICAgdGhpcy5fcXVldWVbM10gPSBjYWxsYmFjaztcbiAgICAgICAgaWYgKG1ldGhvZCAhPSBudWxsKSAgICAgdGhpcy5fcXVldWVbNF0gPSBtZXRob2Q7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xufTtcblxuXG4vKipcbiAqIFVzZWQgZm9yIGludGVycG9sYXRpbmcgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBzdGF0ZSBvZiB0aGUgY3VycmVudGx5XG4gKiBydW5uaW5nIHRyYW5zaXRpb25cbiAqXG4gKiBAbWV0aG9kICBfaW50ZXJwb2xhdGVcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7T2JqZWN0fEFycmF5fE51bWJlcn0gb3V0cHV0ICAgICBXaGVyZSB0byB3cml0ZSB0byAoaW4gb3JkZXIgdG8gYXZvaWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IGFsbG9jYXRpb24gYW5kIHRoZXJlZm9yZSBHQykuXG4gKiBAcGFyYW0gIHtPYmplY3R8QXJyYXl8TnVtYmVyfSBmcm9tICAgICAgIFN0YXJ0IHN0YXRlIG9mIGN1cnJlbnQgdHJhbnNpdGlvbi5cbiAqIEBwYXJhbSAge09iamVjdHxBcnJheXxOdW1iZXJ9IHRvICAgICAgICAgRW5kIHN0YXRlIG9mIGN1cnJlbnQgdHJhbnNpdGlvbi5cbiAqIEBwYXJhbSAge051bWJlcn0gcHJvZ3Jlc3MgICAgICAgICAgICAgICAgUHJvZ3Jlc3Mgb2YgdGhlIGN1cnJlbnQgdHJhbnNpdGlvbixcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW4gWzAsIDFdXG4gKiBAcGFyYW0gIHtTdHJpbmd9IG1ldGhvZCAgICAgICAgICAgICAgICAgIE1ldGhvZCB1c2VkIGZvciBpbnRlcnBvbGF0aW9uIChlLmcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNsZXJwKVxuICogQHJldHVybiB7T2JqZWN0fEFycmF5fE51bWJlcn0gICAgICAgICAgICBvdXRwdXRcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLl9pbnRlcnBvbGF0ZSA9IGZ1bmN0aW9uIF9pbnRlcnBvbGF0ZShvdXRwdXQsIGZyb20sIHRvLCBwcm9ncmVzcywgbWV0aG9kKSB7XG4gICAgaWYgKHRvIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdzbGVycCcpIHtcbiAgICAgICAgICAgIHZhciB4LCB5LCB6LCB3O1xuICAgICAgICAgICAgdmFyIHF4LCBxeSwgcXosIHF3O1xuICAgICAgICAgICAgdmFyIG9tZWdhLCBjb3NvbWVnYSwgc2lub21lZ2EsIHNjYWxlRnJvbSwgc2NhbGVUbztcblxuICAgICAgICAgICAgeCA9IGZyb21bMF07XG4gICAgICAgICAgICB5ID0gZnJvbVsxXTtcbiAgICAgICAgICAgIHogPSBmcm9tWzJdO1xuICAgICAgICAgICAgdyA9IGZyb21bM107XG5cbiAgICAgICAgICAgIHF4ID0gdG9bMF07XG4gICAgICAgICAgICBxeSA9IHRvWzFdO1xuICAgICAgICAgICAgcXogPSB0b1syXTtcbiAgICAgICAgICAgIHF3ID0gdG9bM107XG5cbiAgICAgICAgICAgIGlmIChwcm9ncmVzcyA9PT0gMSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFswXSA9IHF4O1xuICAgICAgICAgICAgICAgIG91dHB1dFsxXSA9IHF5O1xuICAgICAgICAgICAgICAgIG91dHB1dFsyXSA9IHF6O1xuICAgICAgICAgICAgICAgIG91dHB1dFszXSA9IHF3O1xuICAgICAgICAgICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvc29tZWdhID0gdyAqIHF3ICsgeCAqIHF4ICsgeSAqIHF5ICsgeiAqIHF6O1xuICAgICAgICAgICAgaWYgKCgxLjAgLSBjb3NvbWVnYSkgPiAxZS01KSB7XG4gICAgICAgICAgICAgICAgb21lZ2EgPSBNYXRoLmFjb3MoY29zb21lZ2EpO1xuICAgICAgICAgICAgICAgIHNpbm9tZWdhID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgICAgICAgICAgIHNjYWxlRnJvbSA9IE1hdGguc2luKCgxLjAgLSBwcm9ncmVzcykgKiBvbWVnYSkgLyBzaW5vbWVnYTtcbiAgICAgICAgICAgICAgICBzY2FsZVRvID0gTWF0aC5zaW4ocHJvZ3Jlc3MgKiBvbWVnYSkgLyBzaW5vbWVnYTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjYWxlRnJvbSA9IDEuMCAtIHByb2dyZXNzO1xuICAgICAgICAgICAgICAgIHNjYWxlVG8gPSBwcm9ncmVzcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb3V0cHV0WzBdID0geCAqIHNjYWxlRnJvbSArIHF4ICogc2NhbGVUbztcbiAgICAgICAgICAgIG91dHB1dFsxXSA9IHkgKiBzY2FsZUZyb20gKyBxeSAqIHNjYWxlVG87XG4gICAgICAgICAgICBvdXRwdXRbMl0gPSB6ICogc2NhbGVGcm9tICsgcXogKiBzY2FsZVRvO1xuICAgICAgICAgICAgb3V0cHV0WzNdID0gdyAqIHNjYWxlRnJvbSArIHF3ICogc2NhbGVUbztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0byBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG8ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbaV0gPSB0aGlzLl9pbnRlcnBvbGF0ZShvdXRwdXRbaV0sIGZyb21baV0sIHRvW2ldLCBwcm9ncmVzcywgbWV0aG9kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSBpbiB0bykge1xuICAgICAgICAgICAgICAgIG91dHB1dFtrZXldID0gdGhpcy5faW50ZXJwb2xhdGUob3V0cHV0W2tleV0sIGZyb21ba2V5XSwgdG9ba2V5XSwgcHJvZ3Jlc3MsIG1ldGhvZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG91dHB1dCA9IGZyb20gKyBwcm9ncmVzcyAqICh0byAtIGZyb20pO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuXG4vKipcbiAqIEludGVybmFsIGhlbHBlciBtZXRob2QgdXNlZCBmb3Igc3luY2hyb25pemluZyB0aGUgY3VycmVudCwgYWJzb2x1dGUgc3RhdGUgb2ZcbiAqIGEgdHJhbnNpdGlvbiB0byBhIGdpdmVuIG91dHB1dCBhcnJheSwgb2JqZWN0IGxpdGVyYWwgb3IgbnVtYmVyLiBTdXBwb3J0c1xuICogbmVzdGVkIHN0YXRlIG9iamVjdHMgYnkgdGhyb3VnaCByZWN1cnNpb24uXG4gKlxuICogQG1ldGhvZCAgX3N5bmNcbiAqIEBwcml2YXRlXG4gKlxuICogQHBhcmFtICB7TnVtYmVyfEFycmF5fE9iamVjdH0gb3V0cHV0ICAgICBXaGVyZSB0byB3cml0ZSB0byAoaW4gb3JkZXIgdG8gYXZvaWRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqZWN0IGFsbG9jYXRpb24gYW5kIHRoZXJlZm9yZSBHQykuXG4gKiBAcGFyYW0gIHtOdW1iZXJ8QXJyYXl8T2JqZWN0fSBpbnB1dCAgICAgIElucHV0IHN0YXRlIHRvIHByb3h5IG9udG8gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dC5cbiAqIEByZXR1cm4ge051bWJlcnxBcnJheXxPYmplY3R9IG91dHB1dCAgICAgUGFzc2VkIGluIG91dHB1dCBvYmplY3QuXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5fc3luYyA9IGZ1bmN0aW9uIF9zeW5jKG91dHB1dCwgaW5wdXQpIHtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSAnbnVtYmVyJykgb3V0cHV0ID0gaW5wdXQ7XG4gICAgZWxzZSBpZiAoaW5wdXQgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICBpZiAob3V0cHV0ID09IG51bGwpIG91dHB1dCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaW5wdXQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dFtpXSA9IF9zeW5jKG91dHB1dFtpXSwgaW5wdXRbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKGlucHV0IGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgICAgIGlmIChvdXRwdXQgPT0gbnVsbCkgb3V0cHV0ID0ge307XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBfc3luYyhvdXRwdXRba2V5XSwgaW5wdXRba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn07XG5cbi8qKlxuICogR2V0IGludGVycG9sYXRlZCBzdGF0ZSBvZiBjdXJyZW50IGFjdGlvbiBhdCBwcm92aWRlZCB0aW1lLiBJZiB0aGUgbGFzdFxuICogICAgYWN0aW9uIGhhcyBjb21wbGV0ZWQsIGludm9rZSBpdHMgY2FsbGJhY2suXG4gKlxuICogQG1ldGhvZCBnZXRcbiAqXG4gKiBAcGFyYW0ge051bWJlcj19IHQgICAgICAgICAgICAgICBFdmFsdWF0ZSB0aGUgY3VydmUgYXQgYSBub3JtYWxpemVkIHZlcnNpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mIHRoaXMgdGltZS4gSWYgb21pdHRlZCwgdXNlIGN1cnJlbnQgdGltZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFVuaXggZXBvY2ggdGltZSByZXRyaWV2ZWQgZnJvbSBDbG9jaykuXG4gKiBAcmV0dXJuIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfSAgICBCZWdpbm5pbmcgc3RhdGUgaW50ZXJwb2xhdGVkIHRvIHRoaXMgcG9pbnRcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluIHRpbWUuXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiBnZXQodCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZS5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLl9zdGF0ZTtcblxuICAgIHQgPSB0aGlzLl9wYXVzZWRBdCA/IHRoaXMuX3BhdXNlZEF0IDogdDtcbiAgICB0ID0gdCA/IHQgOiB0aGlzLmNvbnN0cnVjdG9yLkNsb2NrLm5vdygpO1xuXG4gICAgdmFyIHByb2dyZXNzID0gKHQgLSB0aGlzLl9zdGFydGVkQXQpIC8gdGhpcy5fcXVldWVbMl07XG4gICAgdGhpcy5fc3RhdGUgPSB0aGlzLl9pbnRlcnBvbGF0ZShcbiAgICAgICAgdGhpcy5fc3RhdGUsXG4gICAgICAgIHRoaXMuX2Zyb20sXG4gICAgICAgIHRoaXMuX3F1ZXVlWzBdLFxuICAgICAgICB0aGlzLl9xdWV1ZVsxXShwcm9ncmVzcyA+IDEgPyAxIDogcHJvZ3Jlc3MpLFxuICAgICAgICB0aGlzLl9xdWV1ZVs0XVxuICAgICk7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgaWYgKHByb2dyZXNzID49IDEpIHtcbiAgICAgICAgdGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5fc3RhcnRlZEF0ICsgdGhpcy5fcXVldWVbMl07XG4gICAgICAgIHRoaXMuX2Zyb20gPSB0aGlzLl9zeW5jKHRoaXMuX2Zyb20sIHRoaXMuX3N0YXRlKTtcbiAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgdGhpcy5fcXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjaygpO1xuICAgIH1cbiAgICByZXR1cm4gcHJvZ3Jlc3MgPiAxID8gdGhpcy5nZXQoKSA6IHN0YXRlO1xufTtcblxuLyoqXG4gKiBJcyB0aGVyZSBhdCBsZWFzdCBvbmUgdHJhbnNpdGlvbiBwZW5kaW5nIGNvbXBsZXRpb24/XG4gKlxuICogQG1ldGhvZCBpc0FjdGl2ZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59ICAgIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBwZW5kaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICB0cmFuc2l0aW9uLiBQYXVzZWQgdHJhbnNpdGlvbnMgYXJlIHN0aWxsIGJlaW5nXG4gKiAgICAgICAgICAgICAgICAgICAgICBjb25zaWRlcmVkIGFjdGl2ZS5cbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmlzQWN0aXZlID0gZnVuY3Rpb24gaXNBY3RpdmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXVlLmxlbmd0aCA+IDA7XG59O1xuXG4vKipcbiAqIEhhbHQgdHJhbnNpdGlvbiBhdCBjdXJyZW50IHN0YXRlIGFuZCBlcmFzZSBhbGwgcGVuZGluZyBhY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgaGFsdFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge1RyYW5zaXRpb25hYmxlfSB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5oYWx0ID0gZnVuY3Rpb24gaGFsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5mcm9tKHRoaXMuZ2V0KCkpO1xufTtcblxuLyoqXG4gKiBQYXVzZSB0cmFuc2l0aW9uLiBUaGlzIHdpbGwgbm90IGVyYXNlIGFueSBhY3Rpb25zLlxuICpcbiAqIEBtZXRob2QgcGF1c2VcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICB0aGlzLl9wYXVzZWRBdCA9IHRoaXMuY29uc3RydWN0b3IuQ2xvY2subm93KCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIEhhcyB0aGUgY3VycmVudCBhY3Rpb24gYmVlbiBwYXVzZWQ/XG4gKlxuICogQG1ldGhvZCBpc1BhdXNlZFxuICogQGNoYWluYWJsZVxuICpcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGlmIHRoZSBjdXJyZW50IGFjdGlvbiBoYXMgYmVlbiBwYXVzZWRcbiAqL1xuVHJhbnNpdGlvbmFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gaXNQYXVzZWQoKSB7XG4gICAgcmV0dXJuICEhdGhpcy5fcGF1c2VkQXQ7XG59O1xuXG4vKipcbiAqIFJlc3VtZSBhIHByZXZpb3VzbHkgcGF1c2VkIHRyYW5zaXRpb24uXG4gKlxuICogQG1ldGhvZCByZXN1bWVcbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gcmVzdW1lKCkge1xuICAgIHZhciBkaWZmID0gdGhpcy5fcGF1c2VkQXQgLSB0aGlzLl9zdGFydGVkQXQ7XG4gICAgdGhpcy5fc3RhcnRlZEF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5DbG9jay5ub3coKSAtIGRpZmY7XG4gICAgdGhpcy5fcGF1c2VkQXQgPSBudWxsO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuLyoqXG4gKiBDYW5jZWwgYWxsIHRyYW5zaXRpb25zIGFuZCByZXNldCB0byBhIHN0YWJsZSBzdGF0ZVxuICpcbiAqIEBtZXRob2QgcmVzZXRcbiAqIEBjaGFpbmFibGVcbiAqIEBkZXByZWNhdGVkIFVzZSBgLmZyb21gIGluc3RlYWQhXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ8QXJyYXkuTnVtYmVyfE9iamVjdC48bnVtYmVyLCBudW1iZXI+fSBzdGFydFxuICogICAgc3RhYmxlIHN0YXRlIHRvIHNldCB0b1xuICogQHJldHVybiB7VHJhbnNpdGlvbmFibGV9ICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzXG4gKi9cblRyYW5zaXRpb25hYmxlLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uKHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXMuZnJvbShzdGFydCk7XG59O1xuXG4vKipcbiAqIEFkZCB0cmFuc2l0aW9uIHRvIGVuZCBzdGF0ZSB0byB0aGUgcXVldWUgb2YgcGVuZGluZyB0cmFuc2l0aW9ucy4gU3BlY2lhbFxuICogICAgVXNlOiBjYWxsaW5nIHdpdGhvdXQgYSB0cmFuc2l0aW9uIHJlc2V0cyB0aGUgb2JqZWN0IHRvIHRoYXQgc3RhdGUgd2l0aFxuICogICAgbm8gcGVuZGluZyBhY3Rpb25zXG4gKlxuICogQG1ldGhvZCBzZXRcbiAqIEBjaGFpbmFibGVcbiAqIEBkZXByZWNhdGVkIFVzZSBgLnRvYCBpbnN0ZWFkIVxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfEZhbW91c0VuZ2luZU1hdHJpeHxBcnJheS5OdW1iZXJ8T2JqZWN0LjxudW1iZXIsIG51bWJlcj59IHN0YXRlXG4gKiAgICBlbmQgc3RhdGUgdG8gd2hpY2ggd2UgaW50ZXJwb2xhdGVcbiAqIEBwYXJhbSB7dHJhbnNpdGlvbj19IHRyYW5zaXRpb24gb2JqZWN0IG9mIHR5cGUge2R1cmF0aW9uOiBudW1iZXIsIGN1cnZlOlxuICogICAgZlswLDFdIC0+IFswLDFdIG9yIG5hbWV9LiBJZiB0cmFuc2l0aW9uIGlzIG9taXR0ZWQsIGNoYW5nZSB3aWxsIGJlXG4gKiAgICBpbnN0YW50YW5lb3VzLlxuICogQHBhcmFtIHtmdW5jdGlvbigpPX0gY2FsbGJhY2sgWmVyby1hcmd1bWVudCBmdW5jdGlvbiB0byBjYWxsIG9uIG9ic2VydmVkXG4gKiAgICBjb21wbGV0aW9uICh0PTEpXG4gKiBAcmV0dXJuIHtUcmFuc2l0aW9uYWJsZX0gdGhpc1xuICovXG5UcmFuc2l0aW9uYWJsZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24oc3RhdGUsIHRyYW5zaXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmZyb20oc3RhdGUpO1xuICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnRvKHN0YXRlLCB0cmFuc2l0aW9uLmN1cnZlLCB0cmFuc2l0aW9uLmR1cmF0aW9uLCBjYWxsYmFjaywgdHJhbnNpdGlvbi5tZXRob2QpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNpdGlvbmFibGU7XG4iLCIvKipcbiAqIFRoZSBNSVQgTGljZW5zZSAoTUlUKVxuICpcbiAqIENvcHlyaWdodCAoYykgMjAxNSBGYW1vdXMgSW5kdXN0cmllcyBJbmMuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU5cbiAqIFRIRSBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQSBsaWdodHdlaWdodCwgZmVhdHVyZWxlc3MgRXZlbnRFbWl0dGVyLlxuICpcbiAqIEBjbGFzcyBFdmVudEVtaXR0ZXJcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIgKCkge1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xufVxuXG4vKipcbiAqIEFkZHMgYSBsaXN0ZW5lciBmb3IgdGhlIHNwZWNpZmllZCBldmVudCAoPSBrZXkpLlxuICpcbiAqIEBtZXRob2Qgb25cbiAqIEBjaGFpbmFibGVcbiAqXG4gKiBAcGFyYW0gIHtTdHJpbmd9ICAga2V5ICAgICAgIFRoZSBldmVudCB0eXBlIChlLmcuIGBjbGlja2ApLlxuICogQHBhcmFtICB7RnVuY3Rpb259IGNhbGxiYWNrICBBIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGludm9rZWQgd2hlbmV2ZXIgYGtleWBcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgaXMgYmVpbmcgdHJpZ2dlcmVkLlxuICogQHJldHVybiB7RnVuY3Rpb259IGRlc3Ryb3kgICBBIGZ1bmN0aW9uIHRvIGNhbGwgaWYgeW91IHdhbnQgdG8gcmVtb3ZlIHRoZVxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5cbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIG9uIChrZXksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHNba2V5XSkgdGhpcy5fZXZlbnRzW2tleV0gPSBbXTtcbiAgICB2YXIgY2FsbGJhY2tMaXN0ID0gdGhpcy5fZXZlbnRzW2tleV07XG4gICAgY2FsbGJhY2tMaXN0LnB1c2goY2FsbGJhY2spO1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNhbGxiYWNrTGlzdC5zcGxpY2UoY2FsbGJhY2tMaXN0LmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICB9O1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgcHJldmlvdXNseSBhZGRlZCBldmVudCBsaXN0ZW5lci5cbiAqXG4gKiBAbWV0aG9kIG9mZlxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30ga2V5ICAgICAgICAgVGhlIGV2ZW50IHR5cGUgZnJvbSB3aGljaCB0aGUgY2FsbGJhY2sgZnVuY3Rpb25cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkIGJlIHJlbW92ZWQuXG4gKiBAcGFyYW0gIHtGdW5jdGlvbn0gY2FsbGJhY2sgIFRoZSBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSByZW1vdmVkIGZyb20gdGhlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycyBmb3Iga2V5LlxuICogQHJldHVybiB7RXZlbnRFbWl0dGVyfSB0aGlzXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gb2ZmIChrZXksIGNhbGxiYWNrKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1trZXldO1xuICAgIGlmIChldmVudHMpIGV2ZW50cy5zcGxpY2UoZXZlbnRzLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8qKlxuICogSW52b2tlcyBhbGwgdGhlIHByZXZpb3VzbHkgZm9yIHRoaXMga2V5IHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxuICpcbiAqIEBtZXRob2QgdHJpZ2dlclxuICogQGNoYWluYWJsZVxuICpcbiAqIEBwYXJhbSAge1N0cmluZ30gICAgICAgIGtleSAgICAgIFRoZSBldmVudCB0eXBlLlxuICogQHBhcmFtICB7T2JqZWN0fSAgICAgICAgcGF5bG9hZCAgVGhlIGV2ZW50IHBheWxvYWQgKGV2ZW50IG9iamVjdCkuXG4gKiBAcmV0dXJuIHtFdmVudEVtaXR0ZXJ9IHRoaXNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS50cmlnZ2VyID0gZnVuY3Rpb24gdHJpZ2dlciAoa2V5LCBwYXlsb2FkKSB7XG4gICAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50c1trZXldO1xuICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBsZW4gOyBpKyspIGV2ZW50c1tpXShwYXlsb2FkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gYXNzZXJ0KG9rLCBlcnJvck1zZykge1xuICAgIGlmICghb2spIHtcbiAgICAgICAgaWYgKCFlcnJvck1zZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdDb25kaXRpb24gbm90IG1ldC4gRGVidWcgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnQgZm9yICcgK1xuICAgICAgICAgICAgICAgICdmdXJ0aGVyIGluc3BlY3Rpb24gYW5kIGVycm9yIG1lc3NhZ2UuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIGFzc2VydGlvbjogJyArIGVycm9yTXNnKTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0O1xuIiwiLyoqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTUgRmFtb3VzIEluZHVzdHJpZXMgSW5jLlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAqIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICogZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICogSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAqIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG4gKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG4gKiBUSEUgU09GVFdBUkUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUFJFRklYRVMgPSBbJycsICctbXMtJywgJy13ZWJraXQtJywgJy1tb3otJywgJy1vLSddO1xuXG4vKipcbiAqIEEgaGVscGVyIGZ1bmN0aW9uIHVzZWQgZm9yIGRldGVybWluaW5nIHRoZSB2ZW5kb3IgcHJlZml4ZWQgdmVyc2lvbiBvZiB0aGVcbiAqIHBhc3NlZCBpbiBDU1MgcHJvcGVydHkuXG4gKlxuICogVmVuZG9yIGNoZWNrcyBhcmUgYmVpbmcgY29uZHVjdGVkIGluIHRoZSBmb2xsb3dpbmcgb3JkZXI6XG4gKlxuICogMS4gKG5vIHByZWZpeClcbiAqIDIuIGAtbXotYFxuICogMy4gYC13ZWJraXQtYFxuICogNC4gYC1tb3otYFxuICogNS4gYC1vLWBcbiAqXG4gKiBAbWV0aG9kIHZlbmRvclByZWZpeFxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcm9wZXJ0eSAgICAgQ1NTIHByb3BlcnR5IChubyBjYW1lbENhc2UpLCBlLmcuXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGBib3JkZXItcmFkaXVzYC5cbiAqIEByZXR1cm4ge1N0cmluZ30gcHJlZml4ZWQgICAgVmVuZG9yIHByZWZpeGVkIHZlcnNpb24gb2YgcGFzc2VkIGluIENTU1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eSAoZS5nLiBgLXdlYmtpdC1ib3JkZXItcmFkaXVzYCkuXG4gKi9cbmZ1bmN0aW9uIHZlbmRvclByZWZpeChwcm9wZXJ0eSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgUFJFRklYRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByZWZpeGVkID0gUFJFRklYRVNbaV0gKyBwcm9wZXJ0eTtcbiAgICAgICAgaWYgKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZVtwcmVmaXhlZF0gPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4ZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHByb3BlcnR5O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHZlbmRvclByZWZpeDtcbiJdfQ==
